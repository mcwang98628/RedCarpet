// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: cvs.proto

#include "cvs.pb.h"
#include "cvs.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace AR51 {

static const char* Cvs_method_names[] = {
  "/AR51.Cvs/SayHelloSingle",
  "/AR51.Cvs/SayHello",
};

std::unique_ptr< Cvs::Stub> Cvs::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< Cvs::Stub> stub(new Cvs::Stub(channel));
  return stub;
}

Cvs::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_SayHelloSingle_(Cvs_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SayHello_(Cvs_method_names[1], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  {}

::grpc::Status Cvs::Stub::SayHelloSingle(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::AR51::HelloReply* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SayHelloSingle_, context, request, response);
}

void Cvs::Stub::experimental_async::SayHelloSingle(::grpc::ClientContext* context, const ::AR51::HelloRequest* request, ::AR51::HelloReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SayHelloSingle_, context, request, response, std::move(f));
}

void Cvs::Stub::experimental_async::SayHelloSingle(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::HelloReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SayHelloSingle_, context, request, response, std::move(f));
}

void Cvs::Stub::experimental_async::SayHelloSingle(::grpc::ClientContext* context, const ::AR51::HelloRequest* request, ::AR51::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SayHelloSingle_, context, request, response, reactor);
}

void Cvs::Stub::experimental_async::SayHelloSingle(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SayHelloSingle_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::HelloReply>* Cvs::Stub::AsyncSayHelloSingleRaw(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::HelloReply>::Create(channel_.get(), cq, rpcmethod_SayHelloSingle_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::HelloReply>* Cvs::Stub::PrepareAsyncSayHelloSingleRaw(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::HelloReply>::Create(channel_.get(), cq, rpcmethod_SayHelloSingle_, context, request, false);
}

::grpc::ClientReader< ::AR51::HelloReply>* Cvs::Stub::SayHelloRaw(::grpc::ClientContext* context, const ::AR51::HelloRequest& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::HelloReply>::Create(channel_.get(), rpcmethod_SayHello_, context, request);
}

void Cvs::Stub::experimental_async::SayHello(::grpc::ClientContext* context, ::AR51::HelloRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::HelloReply>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::HelloReply>::Create(stub_->channel_.get(), stub_->rpcmethod_SayHello_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::HelloReply>* Cvs::Stub::AsyncSayHelloRaw(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::HelloReply>::Create(channel_.get(), cq, rpcmethod_SayHello_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::HelloReply>* Cvs::Stub::PrepareAsyncSayHelloRaw(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::HelloReply>::Create(channel_.get(), cq, rpcmethod_SayHello_, context, request, false, nullptr);
}

Cvs::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Cvs_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Cvs::Service, ::AR51::HelloRequest, ::AR51::HelloReply>(
          std::mem_fn(&Cvs::Service::SayHelloSingle), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Cvs_method_names[1],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< Cvs::Service, ::AR51::HelloRequest, ::AR51::HelloReply>(
          std::mem_fn(&Cvs::Service::SayHello), this)));
}

Cvs::Service::~Service() {
}

::grpc::Status Cvs::Service::SayHelloSingle(::grpc::ServerContext* context, const ::AR51::HelloRequest* request, ::AR51::HelloReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Cvs::Service::SayHello(::grpc::ServerContext* context, const ::AR51::HelloRequest* request, ::grpc::ServerWriter< ::AR51::HelloReply>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* SkeletonService_method_names[] = {
  "/AR51.SkeletonService/GetSkeleton",
  "/AR51.SkeletonService/Register",
  "/AR51.SkeletonService/SendHands",
  "/AR51.SkeletonService/SendControllerInfo",
  "/AR51.SkeletonService/StartRecording",
  "/AR51.SkeletonService/StopRecording",
  "/AR51.SkeletonService/GetIsRecording",
};

std::unique_ptr< SkeletonService::Stub> SkeletonService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< SkeletonService::Stub> stub(new SkeletonService::Stub(channel));
  return stub;
}

SkeletonService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_GetSkeleton_(SkeletonService_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Register_(SkeletonService_method_names[1], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  , rpcmethod_SendHands_(SkeletonService_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SendControllerInfo_(SkeletonService_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_StartRecording_(SkeletonService_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_StopRecording_(SkeletonService_method_names[5], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetIsRecording_(SkeletonService_method_names[6], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status SkeletonService::Stub::GetSkeleton(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::SkeletonReply* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetSkeleton_, context, request, response);
}

void SkeletonService::Stub::experimental_async::GetSkeleton(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::SkeletonReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetSkeleton_, context, request, response, std::move(f));
}

void SkeletonService::Stub::experimental_async::GetSkeleton(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SkeletonReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetSkeleton_, context, request, response, std::move(f));
}

void SkeletonService::Stub::experimental_async::GetSkeleton(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::SkeletonReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetSkeleton_, context, request, response, reactor);
}

void SkeletonService::Stub::experimental_async::GetSkeleton(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SkeletonReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetSkeleton_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::SkeletonReply>* SkeletonService::Stub::AsyncGetSkeletonRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::SkeletonReply>::Create(channel_.get(), cq, rpcmethod_GetSkeleton_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::SkeletonReply>* SkeletonService::Stub::PrepareAsyncGetSkeletonRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::SkeletonReply>::Create(channel_.get(), cq, rpcmethod_GetSkeleton_, context, request, false);
}

::grpc::ClientReader< ::AR51::SkeletonReply>* SkeletonService::Stub::RegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::SkeletonReply>::Create(channel_.get(), rpcmethod_Register_, context, request);
}

void SkeletonService::Stub::experimental_async::Register(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::SkeletonReply>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::SkeletonReply>::Create(stub_->channel_.get(), stub_->rpcmethod_Register_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::SkeletonReply>* SkeletonService::Stub::AsyncRegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::SkeletonReply>::Create(channel_.get(), cq, rpcmethod_Register_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::SkeletonReply>* SkeletonService::Stub::PrepareAsyncRegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::SkeletonReply>::Create(channel_.get(), cq, rpcmethod_Register_, context, request, false, nullptr);
}

::grpc::Status SkeletonService::Stub::SendHands(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SendHands_, context, request, response);
}

void SkeletonService::Stub::experimental_async::SendHands(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SendHands_, context, request, response, std::move(f));
}

void SkeletonService::Stub::experimental_async::SendHands(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SendHands_, context, request, response, std::move(f));
}

void SkeletonService::Stub::experimental_async::SendHands(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SendHands_, context, request, response, reactor);
}

void SkeletonService::Stub::experimental_async::SendHands(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SendHands_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* SkeletonService::Stub::AsyncSendHandsRaw(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SendHands_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* SkeletonService::Stub::PrepareAsyncSendHandsRaw(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SendHands_, context, request, false);
}

::grpc::Status SkeletonService::Stub::SendControllerInfo(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SendControllerInfo_, context, request, response);
}

void SkeletonService::Stub::experimental_async::SendControllerInfo(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SendControllerInfo_, context, request, response, std::move(f));
}

void SkeletonService::Stub::experimental_async::SendControllerInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SendControllerInfo_, context, request, response, std::move(f));
}

void SkeletonService::Stub::experimental_async::SendControllerInfo(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SendControllerInfo_, context, request, response, reactor);
}

void SkeletonService::Stub::experimental_async::SendControllerInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SendControllerInfo_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* SkeletonService::Stub::AsyncSendControllerInfoRaw(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SendControllerInfo_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* SkeletonService::Stub::PrepareAsyncSendControllerInfoRaw(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SendControllerInfo_, context, request, false);
}

::grpc::Status SkeletonService::Stub::StartRecording(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_StartRecording_, context, request, response);
}

void SkeletonService::Stub::experimental_async::StartRecording(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StartRecording_, context, request, response, std::move(f));
}

void SkeletonService::Stub::experimental_async::StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StartRecording_, context, request, response, std::move(f));
}

void SkeletonService::Stub::experimental_async::StartRecording(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StartRecording_, context, request, response, reactor);
}

void SkeletonService::Stub::experimental_async::StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StartRecording_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* SkeletonService::Stub::AsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_StartRecording_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* SkeletonService::Stub::PrepareAsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_StartRecording_, context, request, false);
}

::grpc::Status SkeletonService::Stub::StopRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_StopRecording_, context, request, response);
}

void SkeletonService::Stub::experimental_async::StopRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StopRecording_, context, request, response, std::move(f));
}

void SkeletonService::Stub::experimental_async::StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StopRecording_, context, request, response, std::move(f));
}

void SkeletonService::Stub::experimental_async::StopRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StopRecording_, context, request, response, reactor);
}

void SkeletonService::Stub::experimental_async::StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StopRecording_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* SkeletonService::Stub::AsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_StopRecording_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* SkeletonService::Stub::PrepareAsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_StopRecording_, context, request, false);
}

::grpc::Status SkeletonService::Stub::GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetIsRecording_, context, request, response);
}

void SkeletonService::Stub::experimental_async::GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetIsRecording_, context, request, response, std::move(f));
}

void SkeletonService::Stub::experimental_async::GetIsRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetIsRecording_, context, request, response, std::move(f));
}

void SkeletonService::Stub::experimental_async::GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetIsRecording_, context, request, response, reactor);
}

void SkeletonService::Stub::experimental_async::GetIsRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetIsRecording_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* SkeletonService::Stub::AsyncGetIsRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetIsRecording_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* SkeletonService::Stub::PrepareAsyncGetIsRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetIsRecording_, context, request, false);
}

SkeletonService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      SkeletonService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< SkeletonService::Service, ::AR51::Empty, ::AR51::SkeletonReply>(
          std::mem_fn(&SkeletonService::Service::GetSkeleton), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      SkeletonService_method_names[1],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< SkeletonService::Service, ::AR51::Empty, ::AR51::SkeletonReply>(
          std::mem_fn(&SkeletonService::Service::Register), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      SkeletonService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< SkeletonService::Service, ::AR51::HandsInfoRequest, ::AR51::Empty>(
          std::mem_fn(&SkeletonService::Service::SendHands), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      SkeletonService_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< SkeletonService::Service, ::AR51::MultiControllerInfoRequest, ::AR51::Empty>(
          std::mem_fn(&SkeletonService::Service::SendControllerInfo), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      SkeletonService_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< SkeletonService::Service, ::AR51::StringMessage, ::AR51::Empty>(
          std::mem_fn(&SkeletonService::Service::StartRecording), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      SkeletonService_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< SkeletonService::Service, ::AR51::Empty, ::AR51::Empty>(
          std::mem_fn(&SkeletonService::Service::StopRecording), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      SkeletonService_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< SkeletonService::Service, ::AR51::Empty, ::AR51::BoolMessage>(
          std::mem_fn(&SkeletonService::Service::GetIsRecording), this)));
}

SkeletonService::Service::~Service() {
}

::grpc::Status SkeletonService::Service::GetSkeleton(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SkeletonReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status SkeletonService::Service::Register(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::SkeletonReply>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status SkeletonService::Service::SendHands(::grpc::ServerContext* context, const ::AR51::HandsInfoRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status SkeletonService::Service::SendControllerInfo(::grpc::ServerContext* context, const ::AR51::MultiControllerInfoRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status SkeletonService::Service::StartRecording(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status SkeletonService::Service::StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status SkeletonService::Service::GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* Calibration_method_names[] = {
  "/AR51.Calibration/RunCameraCalibration",
  "/AR51.Calibration/RunCVtoDeviceCalibration",
  "/AR51.Calibration/DownloadAnchor",
  "/AR51.Calibration/GetCaptureBounds",
  "/AR51.Calibration/SetCaptureBounds",
  "/AR51.Calibration/GetVisualization",
};

std::unique_ptr< Calibration::Stub> Calibration::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< Calibration::Stub> stub(new Calibration::Stub(channel));
  return stub;
}

Calibration::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_RunCameraCalibration_(Calibration_method_names[0], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  , rpcmethod_RunCVtoDeviceCalibration_(Calibration_method_names[1], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  , rpcmethod_DownloadAnchor_(Calibration_method_names[2], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  , rpcmethod_GetCaptureBounds_(Calibration_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetCaptureBounds_(Calibration_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetVisualization_(Calibration_method_names[5], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  {}

::grpc::ClientReader< ::AR51::CalibrationStatus>* Calibration::Stub::RunCameraCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::CalibrationStatus>::Create(channel_.get(), rpcmethod_RunCameraCalibration_, context, request);
}

void Calibration::Stub::experimental_async::RunCameraCalibration(::grpc::ClientContext* context, ::AR51::DeviceInfo* request, ::grpc::experimental::ClientReadReactor< ::AR51::CalibrationStatus>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::CalibrationStatus>::Create(stub_->channel_.get(), stub_->rpcmethod_RunCameraCalibration_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::CalibrationStatus>* Calibration::Stub::AsyncRunCameraCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::CalibrationStatus>::Create(channel_.get(), cq, rpcmethod_RunCameraCalibration_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::CalibrationStatus>* Calibration::Stub::PrepareAsyncRunCameraCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::CalibrationStatus>::Create(channel_.get(), cq, rpcmethod_RunCameraCalibration_, context, request, false, nullptr);
}

::grpc::ClientReader< ::AR51::CalibrationStatus>* Calibration::Stub::RunCVtoDeviceCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::CalibrationStatus>::Create(channel_.get(), rpcmethod_RunCVtoDeviceCalibration_, context, request);
}

void Calibration::Stub::experimental_async::RunCVtoDeviceCalibration(::grpc::ClientContext* context, ::AR51::DeviceInfo* request, ::grpc::experimental::ClientReadReactor< ::AR51::CalibrationStatus>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::CalibrationStatus>::Create(stub_->channel_.get(), stub_->rpcmethod_RunCVtoDeviceCalibration_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::CalibrationStatus>* Calibration::Stub::AsyncRunCVtoDeviceCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::CalibrationStatus>::Create(channel_.get(), cq, rpcmethod_RunCVtoDeviceCalibration_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::CalibrationStatus>* Calibration::Stub::PrepareAsyncRunCVtoDeviceCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::CalibrationStatus>::Create(channel_.get(), cq, rpcmethod_RunCVtoDeviceCalibration_, context, request, false, nullptr);
}

::grpc::ClientReader< ::AR51::AnchorBytes>* Calibration::Stub::DownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::AnchorBytes>::Create(channel_.get(), rpcmethod_DownloadAnchor_, context, request);
}

void Calibration::Stub::experimental_async::DownloadAnchor(::grpc::ClientContext* context, ::AR51::AnchorRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::AnchorBytes>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::AnchorBytes>::Create(stub_->channel_.get(), stub_->rpcmethod_DownloadAnchor_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::AnchorBytes>* Calibration::Stub::AsyncDownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::AnchorBytes>::Create(channel_.get(), cq, rpcmethod_DownloadAnchor_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::AnchorBytes>* Calibration::Stub::PrepareAsyncDownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::AnchorBytes>::Create(channel_.get(), cq, rpcmethod_DownloadAnchor_, context, request, false, nullptr);
}

::grpc::Status Calibration::Stub::GetCaptureBounds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoundInfo* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetCaptureBounds_, context, request, response);
}

void Calibration::Stub::experimental_async::GetCaptureBounds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoundInfo* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetCaptureBounds_, context, request, response, std::move(f));
}

void Calibration::Stub::experimental_async::GetCaptureBounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoundInfo* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetCaptureBounds_, context, request, response, std::move(f));
}

void Calibration::Stub::experimental_async::GetCaptureBounds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoundInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetCaptureBounds_, context, request, response, reactor);
}

void Calibration::Stub::experimental_async::GetCaptureBounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoundInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetCaptureBounds_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoundInfo>* Calibration::Stub::AsyncGetCaptureBoundsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoundInfo>::Create(channel_.get(), cq, rpcmethod_GetCaptureBounds_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoundInfo>* Calibration::Stub::PrepareAsyncGetCaptureBoundsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoundInfo>::Create(channel_.get(), cq, rpcmethod_GetCaptureBounds_, context, request, false);
}

::grpc::Status Calibration::Stub::SetCaptureBounds(::grpc::ClientContext* context, const ::AR51::BoundInfo& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetCaptureBounds_, context, request, response);
}

void Calibration::Stub::experimental_async::SetCaptureBounds(::grpc::ClientContext* context, const ::AR51::BoundInfo* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetCaptureBounds_, context, request, response, std::move(f));
}

void Calibration::Stub::experimental_async::SetCaptureBounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetCaptureBounds_, context, request, response, std::move(f));
}

void Calibration::Stub::experimental_async::SetCaptureBounds(::grpc::ClientContext* context, const ::AR51::BoundInfo* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetCaptureBounds_, context, request, response, reactor);
}

void Calibration::Stub::experimental_async::SetCaptureBounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetCaptureBounds_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* Calibration::Stub::AsyncSetCaptureBoundsRaw(::grpc::ClientContext* context, const ::AR51::BoundInfo& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetCaptureBounds_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* Calibration::Stub::PrepareAsyncSetCaptureBoundsRaw(::grpc::ClientContext* context, const ::AR51::BoundInfo& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetCaptureBounds_, context, request, false);
}

::grpc::ClientReader< ::AR51::CalibrationVisualizationMessage>* Calibration::Stub::GetVisualizationRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::CalibrationVisualizationMessage>::Create(channel_.get(), rpcmethod_GetVisualization_, context, request);
}

void Calibration::Stub::experimental_async::GetVisualization(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::CalibrationVisualizationMessage>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::CalibrationVisualizationMessage>::Create(stub_->channel_.get(), stub_->rpcmethod_GetVisualization_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::CalibrationVisualizationMessage>* Calibration::Stub::AsyncGetVisualizationRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::CalibrationVisualizationMessage>::Create(channel_.get(), cq, rpcmethod_GetVisualization_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::CalibrationVisualizationMessage>* Calibration::Stub::PrepareAsyncGetVisualizationRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::CalibrationVisualizationMessage>::Create(channel_.get(), cq, rpcmethod_GetVisualization_, context, request, false, nullptr);
}

Calibration::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Calibration_method_names[0],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< Calibration::Service, ::AR51::DeviceInfo, ::AR51::CalibrationStatus>(
          std::mem_fn(&Calibration::Service::RunCameraCalibration), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Calibration_method_names[1],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< Calibration::Service, ::AR51::DeviceInfo, ::AR51::CalibrationStatus>(
          std::mem_fn(&Calibration::Service::RunCVtoDeviceCalibration), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Calibration_method_names[2],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< Calibration::Service, ::AR51::AnchorRequest, ::AR51::AnchorBytes>(
          std::mem_fn(&Calibration::Service::DownloadAnchor), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Calibration_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Calibration::Service, ::AR51::Empty, ::AR51::BoundInfo>(
          std::mem_fn(&Calibration::Service::GetCaptureBounds), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Calibration_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Calibration::Service, ::AR51::BoundInfo, ::AR51::Empty>(
          std::mem_fn(&Calibration::Service::SetCaptureBounds), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Calibration_method_names[5],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< Calibration::Service, ::AR51::Empty, ::AR51::CalibrationVisualizationMessage>(
          std::mem_fn(&Calibration::Service::GetVisualization), this)));
}

Calibration::Service::~Service() {
}

::grpc::Status Calibration::Service::RunCameraCalibration(::grpc::ServerContext* context, const ::AR51::DeviceInfo* request, ::grpc::ServerWriter< ::AR51::CalibrationStatus>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Calibration::Service::RunCVtoDeviceCalibration(::grpc::ServerContext* context, const ::AR51::DeviceInfo* request, ::grpc::ServerWriter< ::AR51::CalibrationStatus>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Calibration::Service::DownloadAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::grpc::ServerWriter< ::AR51::AnchorBytes>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Calibration::Service::GetCaptureBounds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoundInfo* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Calibration::Service::SetCaptureBounds(::grpc::ServerContext* context, const ::AR51::BoundInfo* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Calibration::Service::GetVisualization(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::CalibrationVisualizationMessage>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* CameraFeedService_method_names[] = {
  "/AR51.CameraFeedService/GetAvailableCameras",
  "/AR51.CameraFeedService/GetCameraFeed",
  "/AR51.CameraFeedService/SetCameraFeedSettings",
  "/AR51.CameraFeedService/GetRecordingReady",
  "/AR51.CameraFeedService/StartRecording",
  "/AR51.CameraFeedService/StopRecording",
  "/AR51.CameraFeedService/GetFieldValue",
  "/AR51.CameraFeedService/SetFieldValue",
  "/AR51.CameraFeedService/SaveCameraJson",
  "/AR51.CameraFeedService/VideoControlGetCurrentTime",
  "/AR51.CameraFeedService/VideoControlGetDuration",
  "/AR51.CameraFeedService/VideoControlGetIsPlaying",
  "/AR51.CameraFeedService/VideoControlGetIsPaused",
  "/AR51.CameraFeedService/VideoControlSeek",
  "/AR51.CameraFeedService/VideoControlPlay",
  "/AR51.CameraFeedService/VideoControlPause",
  "/AR51.CameraFeedService/VideoControlNextFrame",
  "/AR51.CameraFeedService/VideoControlPrevFrame",
};

std::unique_ptr< CameraFeedService::Stub> CameraFeedService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< CameraFeedService::Stub> stub(new CameraFeedService::Stub(channel));
  return stub;
}

CameraFeedService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_GetAvailableCameras_(CameraFeedService_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetCameraFeed_(CameraFeedService_method_names[1], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  , rpcmethod_SetCameraFeedSettings_(CameraFeedService_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetRecordingReady_(CameraFeedService_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_StartRecording_(CameraFeedService_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_StopRecording_(CameraFeedService_method_names[5], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetFieldValue_(CameraFeedService_method_names[6], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetFieldValue_(CameraFeedService_method_names[7], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SaveCameraJson_(CameraFeedService_method_names[8], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_VideoControlGetCurrentTime_(CameraFeedService_method_names[9], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_VideoControlGetDuration_(CameraFeedService_method_names[10], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_VideoControlGetIsPlaying_(CameraFeedService_method_names[11], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_VideoControlGetIsPaused_(CameraFeedService_method_names[12], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_VideoControlSeek_(CameraFeedService_method_names[13], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_VideoControlPlay_(CameraFeedService_method_names[14], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_VideoControlPause_(CameraFeedService_method_names[15], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_VideoControlNextFrame_(CameraFeedService_method_names[16], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_VideoControlPrevFrame_(CameraFeedService_method_names[17], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status CameraFeedService::Stub::GetAvailableCameras(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::GetAvailableCamerasResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetAvailableCameras_, context, request, response);
}

void CameraFeedService::Stub::experimental_async::GetAvailableCameras(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetAvailableCamerasResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAvailableCameras_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::GetAvailableCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetAvailableCamerasResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAvailableCameras_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::GetAvailableCameras(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetAvailableCamerasResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAvailableCameras_, context, request, response, reactor);
}

void CameraFeedService::Stub::experimental_async::GetAvailableCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetAvailableCamerasResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAvailableCameras_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::GetAvailableCamerasResponse>* CameraFeedService::Stub::AsyncGetAvailableCamerasRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::GetAvailableCamerasResponse>::Create(channel_.get(), cq, rpcmethod_GetAvailableCameras_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::GetAvailableCamerasResponse>* CameraFeedService::Stub::PrepareAsyncGetAvailableCamerasRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::GetAvailableCamerasResponse>::Create(channel_.get(), cq, rpcmethod_GetAvailableCameras_, context, request, false);
}

::grpc::ClientReader< ::AR51::CvsCameraFeedResponse>* CameraFeedService::Stub::GetCameraFeedRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::CvsCameraFeedResponse>::Create(channel_.get(), rpcmethod_GetCameraFeed_, context, request);
}

void CameraFeedService::Stub::experimental_async::GetCameraFeed(::grpc::ClientContext* context, ::AR51::CvsCameraFeedRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::CvsCameraFeedResponse>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::CvsCameraFeedResponse>::Create(stub_->channel_.get(), stub_->rpcmethod_GetCameraFeed_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::CvsCameraFeedResponse>* CameraFeedService::Stub::AsyncGetCameraFeedRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::CvsCameraFeedResponse>::Create(channel_.get(), cq, rpcmethod_GetCameraFeed_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::CvsCameraFeedResponse>* CameraFeedService::Stub::PrepareAsyncGetCameraFeedRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::CvsCameraFeedResponse>::Create(channel_.get(), cq, rpcmethod_GetCameraFeed_, context, request, false, nullptr);
}

::grpc::Status CameraFeedService::Stub::SetCameraFeedSettings(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetCameraFeedSettings_, context, request, response);
}

void CameraFeedService::Stub::experimental_async::SetCameraFeedSettings(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetCameraFeedSettings_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::SetCameraFeedSettings(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetCameraFeedSettings_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::SetCameraFeedSettings(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetCameraFeedSettings_, context, request, response, reactor);
}

void CameraFeedService::Stub::experimental_async::SetCameraFeedSettings(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetCameraFeedSettings_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraFeedService::Stub::AsyncSetCameraFeedSettingsRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetCameraFeedSettings_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraFeedService::Stub::PrepareAsyncSetCameraFeedSettingsRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetCameraFeedSettings_, context, request, false);
}

::grpc::Status CameraFeedService::Stub::GetRecordingReady(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetRecordingReady_, context, request, response);
}

void CameraFeedService::Stub::experimental_async::GetRecordingReady(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetRecordingReady_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::GetRecordingReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetRecordingReady_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::GetRecordingReady(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetRecordingReady_, context, request, response, reactor);
}

void CameraFeedService::Stub::experimental_async::GetRecordingReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetRecordingReady_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraFeedService::Stub::AsyncGetRecordingReadyRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_GetRecordingReady_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraFeedService::Stub::PrepareAsyncGetRecordingReadyRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_GetRecordingReady_, context, request, false);
}

::grpc::Status CameraFeedService::Stub::StartRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_StartRecording_, context, request, response);
}

void CameraFeedService::Stub::experimental_async::StartRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StartRecording_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StartRecording_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::StartRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StartRecording_, context, request, response, reactor);
}

void CameraFeedService::Stub::experimental_async::StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StartRecording_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraFeedService::Stub::AsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_StartRecording_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraFeedService::Stub::PrepareAsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_StartRecording_, context, request, false);
}

::grpc::Status CameraFeedService::Stub::StopRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_StopRecording_, context, request, response);
}

void CameraFeedService::Stub::experimental_async::StopRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StopRecording_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StopRecording_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::StopRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StopRecording_, context, request, response, reactor);
}

void CameraFeedService::Stub::experimental_async::StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StopRecording_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraFeedService::Stub::AsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_StopRecording_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraFeedService::Stub::PrepareAsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_StopRecording_, context, request, false);
}

::grpc::Status CameraFeedService::Stub::GetFieldValue(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField& request, ::AR51::Float64Message* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetFieldValue_, context, request, response);
}

void CameraFeedService::Stub::experimental_async::GetFieldValue(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetFieldValue_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::GetFieldValue(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetFieldValue_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::GetFieldValue(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetFieldValue_, context, request, response, reactor);
}

void CameraFeedService::Stub::experimental_async::GetFieldValue(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetFieldValue_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* CameraFeedService::Stub::AsyncGetFieldValueRaw(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float64Message>::Create(channel_.get(), cq, rpcmethod_GetFieldValue_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* CameraFeedService::Stub::PrepareAsyncGetFieldValueRaw(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float64Message>::Create(channel_.get(), cq, rpcmethod_GetFieldValue_, context, request, false);
}

::grpc::Status CameraFeedService::Stub::SetFieldValue(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::Float64Message* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetFieldValue_, context, request, response);
}

void CameraFeedService::Stub::experimental_async::SetFieldValue(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetFieldValue_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::SetFieldValue(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetFieldValue_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::SetFieldValue(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetFieldValue_, context, request, response, reactor);
}

void CameraFeedService::Stub::experimental_async::SetFieldValue(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetFieldValue_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* CameraFeedService::Stub::AsyncSetFieldValueRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float64Message>::Create(channel_.get(), cq, rpcmethod_SetFieldValue_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* CameraFeedService::Stub::PrepareAsyncSetFieldValueRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float64Message>::Create(channel_.get(), cq, rpcmethod_SetFieldValue_, context, request, false);
}

::grpc::Status CameraFeedService::Stub::SaveCameraJson(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SaveCameraJson_, context, request, response);
}

void CameraFeedService::Stub::experimental_async::SaveCameraJson(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SaveCameraJson_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::SaveCameraJson(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SaveCameraJson_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::SaveCameraJson(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SaveCameraJson_, context, request, response, reactor);
}

void CameraFeedService::Stub::experimental_async::SaveCameraJson(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SaveCameraJson_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraFeedService::Stub::AsyncSaveCameraJsonRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SaveCameraJson_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraFeedService::Stub::PrepareAsyncSaveCameraJsonRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SaveCameraJson_, context, request, false);
}

::grpc::Status CameraFeedService::Stub::VideoControlGetCurrentTime(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::Float64Message* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_VideoControlGetCurrentTime_, context, request, response);
}

void CameraFeedService::Stub::experimental_async::VideoControlGetCurrentTime(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlGetCurrentTime_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlGetCurrentTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlGetCurrentTime_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlGetCurrentTime(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlGetCurrentTime_, context, request, response, reactor);
}

void CameraFeedService::Stub::experimental_async::VideoControlGetCurrentTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlGetCurrentTime_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* CameraFeedService::Stub::AsyncVideoControlGetCurrentTimeRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float64Message>::Create(channel_.get(), cq, rpcmethod_VideoControlGetCurrentTime_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* CameraFeedService::Stub::PrepareAsyncVideoControlGetCurrentTimeRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float64Message>::Create(channel_.get(), cq, rpcmethod_VideoControlGetCurrentTime_, context, request, false);
}

::grpc::Status CameraFeedService::Stub::VideoControlGetDuration(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::Float64Message* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_VideoControlGetDuration_, context, request, response);
}

void CameraFeedService::Stub::experimental_async::VideoControlGetDuration(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlGetDuration_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlGetDuration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlGetDuration_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlGetDuration(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlGetDuration_, context, request, response, reactor);
}

void CameraFeedService::Stub::experimental_async::VideoControlGetDuration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlGetDuration_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* CameraFeedService::Stub::AsyncVideoControlGetDurationRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float64Message>::Create(channel_.get(), cq, rpcmethod_VideoControlGetDuration_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* CameraFeedService::Stub::PrepareAsyncVideoControlGetDurationRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float64Message>::Create(channel_.get(), cq, rpcmethod_VideoControlGetDuration_, context, request, false);
}

::grpc::Status CameraFeedService::Stub::VideoControlGetIsPlaying(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::BoolMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_VideoControlGetIsPlaying_, context, request, response);
}

void CameraFeedService::Stub::experimental_async::VideoControlGetIsPlaying(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlGetIsPlaying_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlGetIsPlaying(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlGetIsPlaying_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlGetIsPlaying(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlGetIsPlaying_, context, request, response, reactor);
}

void CameraFeedService::Stub::experimental_async::VideoControlGetIsPlaying(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlGetIsPlaying_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraFeedService::Stub::AsyncVideoControlGetIsPlayingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_VideoControlGetIsPlaying_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraFeedService::Stub::PrepareAsyncVideoControlGetIsPlayingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_VideoControlGetIsPlaying_, context, request, false);
}

::grpc::Status CameraFeedService::Stub::VideoControlGetIsPaused(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::BoolMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_VideoControlGetIsPaused_, context, request, response);
}

void CameraFeedService::Stub::experimental_async::VideoControlGetIsPaused(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlGetIsPaused_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlGetIsPaused(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlGetIsPaused_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlGetIsPaused(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlGetIsPaused_, context, request, response, reactor);
}

void CameraFeedService::Stub::experimental_async::VideoControlGetIsPaused(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlGetIsPaused_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraFeedService::Stub::AsyncVideoControlGetIsPausedRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_VideoControlGetIsPaused_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraFeedService::Stub::PrepareAsyncVideoControlGetIsPausedRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_VideoControlGetIsPaused_, context, request, false);
}

::grpc::Status CameraFeedService::Stub::VideoControlSeek(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::BoolMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_VideoControlSeek_, context, request, response);
}

void CameraFeedService::Stub::experimental_async::VideoControlSeek(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlSeek_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlSeek(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlSeek_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlSeek(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlSeek_, context, request, response, reactor);
}

void CameraFeedService::Stub::experimental_async::VideoControlSeek(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlSeek_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraFeedService::Stub::AsyncVideoControlSeekRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_VideoControlSeek_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraFeedService::Stub::PrepareAsyncVideoControlSeekRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_VideoControlSeek_, context, request, false);
}

::grpc::Status CameraFeedService::Stub::VideoControlPlay(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::BoolMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_VideoControlPlay_, context, request, response);
}

void CameraFeedService::Stub::experimental_async::VideoControlPlay(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlPlay_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlPlay(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlPlay_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlPlay(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlPlay_, context, request, response, reactor);
}

void CameraFeedService::Stub::experimental_async::VideoControlPlay(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlPlay_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraFeedService::Stub::AsyncVideoControlPlayRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_VideoControlPlay_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraFeedService::Stub::PrepareAsyncVideoControlPlayRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_VideoControlPlay_, context, request, false);
}

::grpc::Status CameraFeedService::Stub::VideoControlPause(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::BoolMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_VideoControlPause_, context, request, response);
}

void CameraFeedService::Stub::experimental_async::VideoControlPause(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlPause_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlPause(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlPause_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlPause(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlPause_, context, request, response, reactor);
}

void CameraFeedService::Stub::experimental_async::VideoControlPause(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlPause_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraFeedService::Stub::AsyncVideoControlPauseRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_VideoControlPause_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraFeedService::Stub::PrepareAsyncVideoControlPauseRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_VideoControlPause_, context, request, false);
}

::grpc::Status CameraFeedService::Stub::VideoControlNextFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::BoolMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_VideoControlNextFrame_, context, request, response);
}

void CameraFeedService::Stub::experimental_async::VideoControlNextFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlNextFrame_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlNextFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlNextFrame_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlNextFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlNextFrame_, context, request, response, reactor);
}

void CameraFeedService::Stub::experimental_async::VideoControlNextFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlNextFrame_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraFeedService::Stub::AsyncVideoControlNextFrameRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_VideoControlNextFrame_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraFeedService::Stub::PrepareAsyncVideoControlNextFrameRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_VideoControlNextFrame_, context, request, false);
}

::grpc::Status CameraFeedService::Stub::VideoControlPrevFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::BoolMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_VideoControlPrevFrame_, context, request, response);
}

void CameraFeedService::Stub::experimental_async::VideoControlPrevFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlPrevFrame_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlPrevFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_VideoControlPrevFrame_, context, request, response, std::move(f));
}

void CameraFeedService::Stub::experimental_async::VideoControlPrevFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlPrevFrame_, context, request, response, reactor);
}

void CameraFeedService::Stub::experimental_async::VideoControlPrevFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_VideoControlPrevFrame_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraFeedService::Stub::AsyncVideoControlPrevFrameRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_VideoControlPrevFrame_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraFeedService::Stub::PrepareAsyncVideoControlPrevFrameRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_VideoControlPrevFrame_, context, request, false);
}

CameraFeedService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraFeedService::Service, ::AR51::Empty, ::AR51::GetAvailableCamerasResponse>(
          std::mem_fn(&CameraFeedService::Service::GetAvailableCameras), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[1],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< CameraFeedService::Service, ::AR51::CvsCameraFeedRequest, ::AR51::CvsCameraFeedResponse>(
          std::mem_fn(&CameraFeedService::Service::GetCameraFeed), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraFeedService::Service, ::AR51::CvsCameraFeedRequest, ::AR51::Empty>(
          std::mem_fn(&CameraFeedService::Service::SetCameraFeedSettings), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraFeedService::Service, ::AR51::CvsCameraGetRecordingReadyRequest, ::AR51::Empty>(
          std::mem_fn(&CameraFeedService::Service::GetRecordingReady), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraFeedService::Service, ::AR51::CvsCameraIdRequest, ::AR51::Empty>(
          std::mem_fn(&CameraFeedService::Service::StartRecording), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraFeedService::Service, ::AR51::CvsCameraIdRequest, ::AR51::Empty>(
          std::mem_fn(&CameraFeedService::Service::StopRecording), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraFeedService::Service, ::AR51::GetCvsCameraField, ::AR51::Float64Message>(
          std::mem_fn(&CameraFeedService::Service::GetFieldValue), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraFeedService::Service, ::AR51::SetCvsCameraField, ::AR51::Float64Message>(
          std::mem_fn(&CameraFeedService::Service::SetFieldValue), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraFeedService::Service, ::AR51::Empty, ::AR51::Empty>(
          std::mem_fn(&CameraFeedService::Service::SaveCameraJson), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[9],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraFeedService::Service, ::AR51::CvsCameraIdRequest, ::AR51::Float64Message>(
          std::mem_fn(&CameraFeedService::Service::VideoControlGetCurrentTime), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[10],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraFeedService::Service, ::AR51::CvsCameraIdRequest, ::AR51::Float64Message>(
          std::mem_fn(&CameraFeedService::Service::VideoControlGetDuration), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[11],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraFeedService::Service, ::AR51::CvsCameraIdRequest, ::AR51::BoolMessage>(
          std::mem_fn(&CameraFeedService::Service::VideoControlGetIsPlaying), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[12],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraFeedService::Service, ::AR51::CvsCameraIdRequest, ::AR51::BoolMessage>(
          std::mem_fn(&CameraFeedService::Service::VideoControlGetIsPaused), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[13],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraFeedService::Service, ::AR51::SetCvsCameraField, ::AR51::BoolMessage>(
          std::mem_fn(&CameraFeedService::Service::VideoControlSeek), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[14],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraFeedService::Service, ::AR51::SetCvsCameraField, ::AR51::BoolMessage>(
          std::mem_fn(&CameraFeedService::Service::VideoControlPlay), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[15],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraFeedService::Service, ::AR51::SetCvsCameraField, ::AR51::BoolMessage>(
          std::mem_fn(&CameraFeedService::Service::VideoControlPause), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[16],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraFeedService::Service, ::AR51::SetCvsCameraField, ::AR51::BoolMessage>(
          std::mem_fn(&CameraFeedService::Service::VideoControlNextFrame), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraFeedService_method_names[17],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraFeedService::Service, ::AR51::SetCvsCameraField, ::AR51::BoolMessage>(
          std::mem_fn(&CameraFeedService::Service::VideoControlPrevFrame), this)));
}

CameraFeedService::Service::~Service() {
}

::grpc::Status CameraFeedService::Service::GetAvailableCameras(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAvailableCamerasResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraFeedService::Service::GetCameraFeed(::grpc::ServerContext* context, const ::AR51::CvsCameraFeedRequest* request, ::grpc::ServerWriter< ::AR51::CvsCameraFeedResponse>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraFeedService::Service::SetCameraFeedSettings(::grpc::ServerContext* context, const ::AR51::CvsCameraFeedRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraFeedService::Service::GetRecordingReady(::grpc::ServerContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraFeedService::Service::StartRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraFeedService::Service::StopRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraFeedService::Service::GetFieldValue(::grpc::ServerContext* context, const ::AR51::GetCvsCameraField* request, ::AR51::Float64Message* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraFeedService::Service::SetFieldValue(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::Float64Message* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraFeedService::Service::SaveCameraJson(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraFeedService::Service::VideoControlGetCurrentTime(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraFeedService::Service::VideoControlGetDuration(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraFeedService::Service::VideoControlGetIsPlaying(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraFeedService::Service::VideoControlGetIsPaused(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraFeedService::Service::VideoControlSeek(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraFeedService::Service::VideoControlPlay(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraFeedService::Service::VideoControlPause(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraFeedService::Service::VideoControlNextFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraFeedService::Service::VideoControlPrevFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* ObjectDetectionService_method_names[] = {
  "/AR51.ObjectDetectionService/TrackItem",
  "/AR51.ObjectDetectionService/UntrackItem",
  "/AR51.ObjectDetectionService/Register",
};

std::unique_ptr< ObjectDetectionService::Stub> ObjectDetectionService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< ObjectDetectionService::Stub> stub(new ObjectDetectionService::Stub(channel));
  return stub;
}

ObjectDetectionService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_TrackItem_(ObjectDetectionService_method_names[0], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  , rpcmethod_UntrackItem_(ObjectDetectionService_method_names[1], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  , rpcmethod_Register_(ObjectDetectionService_method_names[2], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  {}

::grpc::ClientReader< ::AR51::Empty>* ObjectDetectionService::Stub::TrackItemRaw(::grpc::ClientContext* context, const ::AR51::TrackedObjectInfo& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::Empty>::Create(channel_.get(), rpcmethod_TrackItem_, context, request);
}

void ObjectDetectionService::Stub::experimental_async::TrackItem(::grpc::ClientContext* context, ::AR51::TrackedObjectInfo* request, ::grpc::experimental::ClientReadReactor< ::AR51::Empty>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::Empty>::Create(stub_->channel_.get(), stub_->rpcmethod_TrackItem_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::Empty>* ObjectDetectionService::Stub::AsyncTrackItemRaw(::grpc::ClientContext* context, const ::AR51::TrackedObjectInfo& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_TrackItem_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::Empty>* ObjectDetectionService::Stub::PrepareAsyncTrackItemRaw(::grpc::ClientContext* context, const ::AR51::TrackedObjectInfo& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_TrackItem_, context, request, false, nullptr);
}

::grpc::ClientReader< ::AR51::Empty>* ObjectDetectionService::Stub::UntrackItemRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::Empty>::Create(channel_.get(), rpcmethod_UntrackItem_, context, request);
}

void ObjectDetectionService::Stub::experimental_async::UntrackItem(::grpc::ClientContext* context, ::AR51::StringMessage* request, ::grpc::experimental::ClientReadReactor< ::AR51::Empty>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::Empty>::Create(stub_->channel_.get(), stub_->rpcmethod_UntrackItem_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::Empty>* ObjectDetectionService::Stub::AsyncUntrackItemRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_UntrackItem_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::Empty>* ObjectDetectionService::Stub::PrepareAsyncUntrackItemRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_UntrackItem_, context, request, false, nullptr);
}

::grpc::ClientReader< ::AR51::ObjectDetectionReply>* ObjectDetectionService::Stub::RegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::ObjectDetectionReply>::Create(channel_.get(), rpcmethod_Register_, context, request);
}

void ObjectDetectionService::Stub::experimental_async::Register(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::ObjectDetectionReply>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::ObjectDetectionReply>::Create(stub_->channel_.get(), stub_->rpcmethod_Register_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::ObjectDetectionReply>* ObjectDetectionService::Stub::AsyncRegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::ObjectDetectionReply>::Create(channel_.get(), cq, rpcmethod_Register_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::ObjectDetectionReply>* ObjectDetectionService::Stub::PrepareAsyncRegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::ObjectDetectionReply>::Create(channel_.get(), cq, rpcmethod_Register_, context, request, false, nullptr);
}

ObjectDetectionService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ObjectDetectionService_method_names[0],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< ObjectDetectionService::Service, ::AR51::TrackedObjectInfo, ::AR51::Empty>(
          std::mem_fn(&ObjectDetectionService::Service::TrackItem), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ObjectDetectionService_method_names[1],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< ObjectDetectionService::Service, ::AR51::StringMessage, ::AR51::Empty>(
          std::mem_fn(&ObjectDetectionService::Service::UntrackItem), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ObjectDetectionService_method_names[2],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< ObjectDetectionService::Service, ::AR51::Empty, ::AR51::ObjectDetectionReply>(
          std::mem_fn(&ObjectDetectionService::Service::Register), this)));
}

ObjectDetectionService::Service::~Service() {
}

::grpc::Status ObjectDetectionService::Service::TrackItem(::grpc::ServerContext* context, const ::AR51::TrackedObjectInfo* request, ::grpc::ServerWriter< ::AR51::Empty>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ObjectDetectionService::Service::UntrackItem(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::grpc::ServerWriter< ::AR51::Empty>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ObjectDetectionService::Service::Register(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::ObjectDetectionReply>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace AR51

