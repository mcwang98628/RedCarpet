// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: cvs.proto
#ifndef GRPC_cvs_2eproto__INCLUDED
#define GRPC_cvs_2eproto__INCLUDED

#include "cvs.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class CompletionQueue;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc

namespace AR51 {

// The cvs service definition.
class Cvs final {
 public:
  static constexpr char const* service_full_name() {
    return "AR51.Cvs";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status SayHelloSingle(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::AR51::HelloReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::HelloReply>> AsyncSayHelloSingle(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::HelloReply>>(AsyncSayHelloSingleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::HelloReply>> PrepareAsyncSayHelloSingle(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::HelloReply>>(PrepareAsyncSayHelloSingleRaw(context, request, cq));
    }
    // Sends a greeting
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::HelloReply>> SayHello(::grpc::ClientContext* context, const ::AR51::HelloRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::HelloReply>>(SayHelloRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::HelloReply>> AsyncSayHello(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::HelloReply>>(AsyncSayHelloRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::HelloReply>> PrepareAsyncSayHello(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::HelloReply>>(PrepareAsyncSayHelloRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void SayHelloSingle(::grpc::ClientContext* context, const ::AR51::HelloRequest* request, ::AR51::HelloReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SayHelloSingle(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::HelloReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SayHelloSingle(::grpc::ClientContext* context, const ::AR51::HelloRequest* request, ::AR51::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SayHelloSingle(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Sends a greeting
      virtual void SayHello(::grpc::ClientContext* context, ::AR51::HelloRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::HelloReply>* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::HelloReply>* AsyncSayHelloSingleRaw(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::HelloReply>* PrepareAsyncSayHelloSingleRaw(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::AR51::HelloReply>* SayHelloRaw(::grpc::ClientContext* context, const ::AR51::HelloRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::HelloReply>* AsyncSayHelloRaw(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::HelloReply>* PrepareAsyncSayHelloRaw(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status SayHelloSingle(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::AR51::HelloReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::HelloReply>> AsyncSayHelloSingle(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::HelloReply>>(AsyncSayHelloSingleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::HelloReply>> PrepareAsyncSayHelloSingle(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::HelloReply>>(PrepareAsyncSayHelloSingleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::AR51::HelloReply>> SayHello(::grpc::ClientContext* context, const ::AR51::HelloRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::HelloReply>>(SayHelloRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::HelloReply>> AsyncSayHello(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::HelloReply>>(AsyncSayHelloRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::HelloReply>> PrepareAsyncSayHello(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::HelloReply>>(PrepareAsyncSayHelloRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void SayHelloSingle(::grpc::ClientContext* context, const ::AR51::HelloRequest* request, ::AR51::HelloReply* response, std::function<void(::grpc::Status)>) override;
      void SayHelloSingle(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::HelloReply* response, std::function<void(::grpc::Status)>) override;
      void SayHelloSingle(::grpc::ClientContext* context, const ::AR51::HelloRequest* request, ::AR51::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SayHelloSingle(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SayHello(::grpc::ClientContext* context, ::AR51::HelloRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::HelloReply>* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::AR51::HelloReply>* AsyncSayHelloSingleRaw(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::HelloReply>* PrepareAsyncSayHelloSingleRaw(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::AR51::HelloReply>* SayHelloRaw(::grpc::ClientContext* context, const ::AR51::HelloRequest& request) override;
    ::grpc::ClientAsyncReader< ::AR51::HelloReply>* AsyncSayHelloRaw(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::HelloReply>* PrepareAsyncSayHelloRaw(::grpc::ClientContext* context, const ::AR51::HelloRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SayHelloSingle_;
    const ::grpc::internal::RpcMethod rpcmethod_SayHello_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status SayHelloSingle(::grpc::ServerContext* context, const ::AR51::HelloRequest* request, ::AR51::HelloReply* response);
    // Sends a greeting
    virtual ::grpc::Status SayHello(::grpc::ServerContext* context, const ::AR51::HelloRequest* request, ::grpc::ServerWriter< ::AR51::HelloReply>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_SayHelloSingle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SayHelloSingle() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SayHelloSingle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHelloSingle(::grpc::ServerContext* context, const ::AR51::HelloRequest* request, ::AR51::HelloReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSayHelloSingle(::grpc::ServerContext* context, ::AR51::HelloRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::HelloReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SayHello() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* context, const ::AR51::HelloRequest* request, ::grpc::ServerWriter< ::AR51::HelloReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSayHello(::grpc::ServerContext* context, ::AR51::HelloRequest* request, ::grpc::ServerAsyncWriter< ::AR51::HelloReply>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SayHelloSingle<WithAsyncMethod_SayHello<Service > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SayHelloSingle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SayHelloSingle() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::HelloRequest, ::AR51::HelloReply>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::HelloRequest* request,
                 ::AR51::HelloReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SayHelloSingle(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SayHelloSingle(
        ::grpc::experimental::MessageAllocator< ::AR51::HelloRequest, ::AR51::HelloReply>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::HelloRequest, ::AR51::HelloReply>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SayHelloSingle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHelloSingle(::grpc::ServerContext* context, const ::AR51::HelloRequest* request, ::AR51::HelloReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SayHelloSingle(::grpc::ServerContext* context, const ::AR51::HelloRequest* request, ::AR51::HelloReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SayHello() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::HelloRequest, ::AR51::HelloReply>(
          [this] { return this->SayHello(); }));
    }
    ~ExperimentalWithCallbackMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* context, const ::AR51::HelloRequest* request, ::grpc::ServerWriter< ::AR51::HelloReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::HelloRequest, ::AR51::HelloReply>* SayHello() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::HelloRequest, ::AR51::HelloReply>;}
  };
  typedef ExperimentalWithCallbackMethod_SayHelloSingle<ExperimentalWithCallbackMethod_SayHello<Service > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SayHelloSingle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SayHelloSingle() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SayHelloSingle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHelloSingle(::grpc::ServerContext* context, const ::AR51::HelloRequest* request, ::AR51::HelloReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SayHello() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* context, const ::AR51::HelloRequest* request, ::grpc::ServerWriter< ::AR51::HelloReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SayHelloSingle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SayHelloSingle() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SayHelloSingle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHelloSingle(::grpc::ServerContext* context, const ::AR51::HelloRequest* request, ::AR51::HelloReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSayHelloSingle(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SayHello() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* context, const ::AR51::HelloRequest* request, ::grpc::ServerWriter< ::AR51::HelloReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSayHello(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SayHelloSingle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SayHelloSingle() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SayHelloSingle(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SayHelloSingle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHelloSingle(::grpc::ServerContext* context, const ::AR51::HelloRequest* request, ::AR51::HelloReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SayHelloSingle(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SayHello() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->SayHello(); }));
    }
    ~ExperimentalWithRawCallbackMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* context, const ::AR51::HelloRequest* request, ::grpc::ServerWriter< ::AR51::HelloReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* SayHello() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SayHelloSingle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SayHelloSingle() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::HelloRequest, ::AR51::HelloReply>(std::bind(&WithStreamedUnaryMethod_SayHelloSingle<BaseClass>::StreamedSayHelloSingle, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SayHelloSingle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SayHelloSingle(::grpc::ServerContext* context, const ::AR51::HelloRequest* request, ::AR51::HelloReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSayHelloSingle(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::HelloRequest,::AR51::HelloReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SayHelloSingle<Service > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_SayHello() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::HelloRequest, ::AR51::HelloReply>(std::bind(&WithSplitStreamingMethod_SayHello<BaseClass>::StreamedSayHello, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* context, const ::AR51::HelloRequest* request, ::grpc::ServerWriter< ::AR51::HelloReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSayHello(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::HelloRequest,::AR51::HelloReply>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_SayHello<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_SayHelloSingle<WithSplitStreamingMethod_SayHello<Service > > StreamedService;
};

// ========================================= Skeleton Service =======================================
class SkeletonService final {
 public:
  static constexpr char const* service_full_name() {
    return "AR51.SkeletonService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetSkeleton(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::SkeletonReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SkeletonReply>> AsyncGetSkeleton(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SkeletonReply>>(AsyncGetSkeletonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SkeletonReply>> PrepareAsyncGetSkeleton(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SkeletonReply>>(PrepareAsyncGetSkeletonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::SkeletonReply>> Register(::grpc::ClientContext* context, const ::AR51::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::SkeletonReply>>(RegisterRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::SkeletonReply>> AsyncRegister(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::SkeletonReply>>(AsyncRegisterRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::SkeletonReply>> PrepareAsyncRegister(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::SkeletonReply>>(PrepareAsyncRegisterRaw(context, request, cq));
    }
    virtual ::grpc::Status SendHands(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSendHands(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSendHandsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSendHands(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSendHandsRaw(context, request, cq));
    }
    virtual ::grpc::Status SendControllerInfo(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSendControllerInfo(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSendControllerInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSendControllerInfo(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSendControllerInfoRaw(context, request, cq));
    }
    virtual ::grpc::Status StartRecording(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncStartRecording(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncStartRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncStartRecording(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncStartRecordingRaw(context, request, cq));
    }
    virtual ::grpc::Status StopRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncStopRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncStopRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncStopRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncStopRecordingRaw(context, request, cq));
    }
    virtual ::grpc::Status GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> AsyncGetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(AsyncGetIsRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> PrepareAsyncGetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(PrepareAsyncGetIsRecordingRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void GetSkeleton(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::SkeletonReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSkeleton(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SkeletonReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSkeleton(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::SkeletonReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetSkeleton(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SkeletonReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Register(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::SkeletonReply>* reactor) = 0;
      virtual void SendHands(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendHands(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendHands(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SendHands(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SendControllerInfo(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendControllerInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendControllerInfo(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SendControllerInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StartRecording(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartRecording(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StopRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIsRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetIsRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SkeletonReply>* AsyncGetSkeletonRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SkeletonReply>* PrepareAsyncGetSkeletonRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::AR51::SkeletonReply>* RegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::SkeletonReply>* AsyncRegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::SkeletonReply>* PrepareAsyncRegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSendHandsRaw(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSendHandsRaw(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSendControllerInfoRaw(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSendControllerInfoRaw(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* AsyncGetIsRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* PrepareAsyncGetIsRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetSkeleton(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::SkeletonReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::SkeletonReply>> AsyncGetSkeleton(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::SkeletonReply>>(AsyncGetSkeletonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::SkeletonReply>> PrepareAsyncGetSkeleton(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::SkeletonReply>>(PrepareAsyncGetSkeletonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::AR51::SkeletonReply>> Register(::grpc::ClientContext* context, const ::AR51::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::SkeletonReply>>(RegisterRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::SkeletonReply>> AsyncRegister(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::SkeletonReply>>(AsyncRegisterRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::SkeletonReply>> PrepareAsyncRegister(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::SkeletonReply>>(PrepareAsyncRegisterRaw(context, request, cq));
    }
    ::grpc::Status SendHands(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSendHands(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSendHandsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSendHands(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSendHandsRaw(context, request, cq));
    }
    ::grpc::Status SendControllerInfo(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSendControllerInfo(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSendControllerInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSendControllerInfo(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSendControllerInfoRaw(context, request, cq));
    }
    ::grpc::Status StartRecording(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncStartRecording(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncStartRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncStartRecording(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncStartRecordingRaw(context, request, cq));
    }
    ::grpc::Status StopRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncStopRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncStopRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncStopRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncStopRecordingRaw(context, request, cq));
    }
    ::grpc::Status GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> AsyncGetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(AsyncGetIsRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> PrepareAsyncGetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(PrepareAsyncGetIsRecordingRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetSkeleton(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::SkeletonReply* response, std::function<void(::grpc::Status)>) override;
      void GetSkeleton(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SkeletonReply* response, std::function<void(::grpc::Status)>) override;
      void GetSkeleton(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::SkeletonReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetSkeleton(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SkeletonReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Register(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::SkeletonReply>* reactor) override;
      void SendHands(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SendHands(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SendHands(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SendHands(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SendControllerInfo(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SendControllerInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SendControllerInfo(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SendControllerInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StartRecording(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void StartRecording(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StopRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void StopRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetIsRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetIsRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::AR51::SkeletonReply>* AsyncGetSkeletonRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::SkeletonReply>* PrepareAsyncGetSkeletonRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::AR51::SkeletonReply>* RegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) override;
    ::grpc::ClientAsyncReader< ::AR51::SkeletonReply>* AsyncRegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::SkeletonReply>* PrepareAsyncRegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSendHandsRaw(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSendHandsRaw(::grpc::ClientContext* context, const ::AR51::HandsInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSendControllerInfoRaw(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSendControllerInfoRaw(::grpc::ClientContext* context, const ::AR51::MultiControllerInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AsyncGetIsRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* PrepareAsyncGetIsRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetSkeleton_;
    const ::grpc::internal::RpcMethod rpcmethod_Register_;
    const ::grpc::internal::RpcMethod rpcmethod_SendHands_;
    const ::grpc::internal::RpcMethod rpcmethod_SendControllerInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_StartRecording_;
    const ::grpc::internal::RpcMethod rpcmethod_StopRecording_;
    const ::grpc::internal::RpcMethod rpcmethod_GetIsRecording_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetSkeleton(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SkeletonReply* response);
    virtual ::grpc::Status Register(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::SkeletonReply>* writer);
    virtual ::grpc::Status SendHands(::grpc::ServerContext* context, const ::AR51::HandsInfoRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status SendControllerInfo(::grpc::ServerContext* context, const ::AR51::MultiControllerInfoRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response);
    virtual ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response);
    virtual ::grpc::Status GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSkeleton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetSkeleton() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetSkeleton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSkeleton(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SkeletonReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSkeleton(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::SkeletonReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Register() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::SkeletonReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegister(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncWriter< ::AR51::SkeletonReply>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendHands : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SendHands() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SendHands() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendHands(::grpc::ServerContext* context, const ::AR51::HandsInfoRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendHands(::grpc::ServerContext* context, ::AR51::HandsInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendControllerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SendControllerInfo() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SendControllerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendControllerInfo(::grpc::ServerContext* context, const ::AR51::MultiControllerInfoRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendControllerInfo(::grpc::ServerContext* context, ::AR51::MultiControllerInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StartRecording() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRecording(::grpc::ServerContext* context, ::AR51::StringMessage* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StopRecording() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopRecording(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetIsRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetIsRecording() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetIsRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIsRecording(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BoolMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetSkeleton<WithAsyncMethod_Register<WithAsyncMethod_SendHands<WithAsyncMethod_SendControllerInfo<WithAsyncMethod_StartRecording<WithAsyncMethod_StopRecording<WithAsyncMethod_GetIsRecording<Service > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetSkeleton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetSkeleton() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::SkeletonReply>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::SkeletonReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetSkeleton(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetSkeleton(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::SkeletonReply>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::SkeletonReply>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetSkeleton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSkeleton(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SkeletonReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetSkeleton(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SkeletonReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Register() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::Empty, ::AR51::SkeletonReply>(
          [this] { return this->Register(); }));
    }
    ~ExperimentalWithCallbackMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::SkeletonReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::Empty, ::AR51::SkeletonReply>* Register() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::Empty, ::AR51::SkeletonReply>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendHands : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SendHands() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::HandsInfoRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::HandsInfoRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SendHands(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SendHands(
        ::grpc::experimental::MessageAllocator< ::AR51::HandsInfoRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::HandsInfoRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SendHands() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendHands(::grpc::ServerContext* context, const ::AR51::HandsInfoRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SendHands(::grpc::ServerContext* context, const ::AR51::HandsInfoRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendControllerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SendControllerInfo() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::MultiControllerInfoRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::MultiControllerInfoRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SendControllerInfo(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SendControllerInfo(
        ::grpc::experimental::MessageAllocator< ::AR51::MultiControllerInfoRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::MultiControllerInfoRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SendControllerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendControllerInfo(::grpc::ServerContext* context, const ::AR51::MultiControllerInfoRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SendControllerInfo(::grpc::ServerContext* context, const ::AR51::MultiControllerInfoRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StartRecording() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::StringMessage, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::StringMessage* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StartRecording(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StartRecording(
        ::grpc::experimental::MessageAllocator< ::AR51::StringMessage, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::StringMessage, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StartRecording(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StopRecording() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StopRecording(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StopRecording(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetIsRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetIsRecording() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::BoolMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetIsRecording(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetIsRecording(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::BoolMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetIsRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_GetSkeleton<ExperimentalWithCallbackMethod_Register<ExperimentalWithCallbackMethod_SendHands<ExperimentalWithCallbackMethod_SendControllerInfo<ExperimentalWithCallbackMethod_StartRecording<ExperimentalWithCallbackMethod_StopRecording<ExperimentalWithCallbackMethod_GetIsRecording<Service > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetSkeleton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetSkeleton() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetSkeleton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSkeleton(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SkeletonReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Register() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::SkeletonReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendHands : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SendHands() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SendHands() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendHands(::grpc::ServerContext* context, const ::AR51::HandsInfoRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendControllerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SendControllerInfo() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SendControllerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendControllerInfo(::grpc::ServerContext* context, const ::AR51::MultiControllerInfoRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StartRecording() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StopRecording() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetIsRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetIsRecording() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetIsRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSkeleton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetSkeleton() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetSkeleton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSkeleton(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SkeletonReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSkeleton(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Register() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::SkeletonReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegister(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendHands : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SendHands() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SendHands() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendHands(::grpc::ServerContext* context, const ::AR51::HandsInfoRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendHands(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendControllerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SendControllerInfo() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_SendControllerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendControllerInfo(::grpc::ServerContext* context, const ::AR51::MultiControllerInfoRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendControllerInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StartRecording() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRecording(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StopRecording() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopRecording(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetIsRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetIsRecording() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetIsRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIsRecording(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetSkeleton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetSkeleton() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetSkeleton(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetSkeleton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSkeleton(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SkeletonReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetSkeleton(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Register() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->Register(); }));
    }
    ~ExperimentalWithRawCallbackMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::SkeletonReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* Register() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendHands : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SendHands() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SendHands(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SendHands() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendHands(::grpc::ServerContext* context, const ::AR51::HandsInfoRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SendHands(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendControllerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SendControllerInfo() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SendControllerInfo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SendControllerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendControllerInfo(::grpc::ServerContext* context, const ::AR51::MultiControllerInfoRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SendControllerInfo(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StartRecording() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StartRecording(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StartRecording(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StopRecording() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StopRecording(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopRecording(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetIsRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetIsRecording() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetIsRecording(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetIsRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetIsRecording(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSkeleton : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetSkeleton() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::SkeletonReply>(std::bind(&WithStreamedUnaryMethod_GetSkeleton<BaseClass>::StreamedGetSkeleton, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetSkeleton() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSkeleton(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SkeletonReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSkeleton(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::SkeletonReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendHands : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SendHands() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::HandsInfoRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SendHands<BaseClass>::StreamedSendHands, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SendHands() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendHands(::grpc::ServerContext* context, const ::AR51::HandsInfoRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendHands(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::HandsInfoRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendControllerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SendControllerInfo() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::MultiControllerInfoRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SendControllerInfo<BaseClass>::StreamedSendControllerInfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SendControllerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendControllerInfo(::grpc::ServerContext* context, const ::AR51::MultiControllerInfoRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendControllerInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::MultiControllerInfoRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StartRecording() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::StringMessage, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_StartRecording<BaseClass>::StreamedStartRecording, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartRecording(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::StringMessage,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StopRecording() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_StopRecording<BaseClass>::StreamedStopRecording, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopRecording(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetIsRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetIsRecording() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>(std::bind(&WithStreamedUnaryMethod_GetIsRecording<BaseClass>::StreamedGetIsRecording, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetIsRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetIsRecording(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::BoolMessage>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetSkeleton<WithStreamedUnaryMethod_SendHands<WithStreamedUnaryMethod_SendControllerInfo<WithStreamedUnaryMethod_StartRecording<WithStreamedUnaryMethod_StopRecording<WithStreamedUnaryMethod_GetIsRecording<Service > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_Register() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::Empty, ::AR51::SkeletonReply>(std::bind(&WithSplitStreamingMethod_Register<BaseClass>::StreamedRegister, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::SkeletonReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedRegister(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::Empty,::AR51::SkeletonReply>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_Register<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetSkeleton<WithSplitStreamingMethod_Register<WithStreamedUnaryMethod_SendHands<WithStreamedUnaryMethod_SendControllerInfo<WithStreamedUnaryMethod_StartRecording<WithStreamedUnaryMethod_StopRecording<WithStreamedUnaryMethod_GetIsRecording<Service > > > > > > > StreamedService;
};

// ========================================= Calibration Service =======================================
class Calibration final {
 public:
  static constexpr char const* service_full_name() {
    return "AR51.Calibration";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::CalibrationStatus>> RunCameraCalibration(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::CalibrationStatus>>(RunCameraCalibrationRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationStatus>> AsyncRunCameraCalibration(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationStatus>>(AsyncRunCameraCalibrationRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationStatus>> PrepareAsyncRunCameraCalibration(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationStatus>>(PrepareAsyncRunCameraCalibrationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::CalibrationStatus>> RunCVtoDeviceCalibration(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::CalibrationStatus>>(RunCVtoDeviceCalibrationRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationStatus>> AsyncRunCVtoDeviceCalibration(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationStatus>>(AsyncRunCVtoDeviceCalibrationRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationStatus>> PrepareAsyncRunCVtoDeviceCalibration(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationStatus>>(PrepareAsyncRunCVtoDeviceCalibrationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::AnchorBytes>> DownloadAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::AnchorBytes>>(DownloadAnchorRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::AnchorBytes>> AsyncDownloadAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::AnchorBytes>>(AsyncDownloadAnchorRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::AnchorBytes>> PrepareAsyncDownloadAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::AnchorBytes>>(PrepareAsyncDownloadAnchorRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCaptureBounds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoundInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoundInfo>> AsyncGetCaptureBounds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoundInfo>>(AsyncGetCaptureBoundsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoundInfo>> PrepareAsyncGetCaptureBounds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoundInfo>>(PrepareAsyncGetCaptureBoundsRaw(context, request, cq));
    }
    virtual ::grpc::Status SetCaptureBounds(::grpc::ClientContext* context, const ::AR51::BoundInfo& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetCaptureBounds(::grpc::ClientContext* context, const ::AR51::BoundInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetCaptureBoundsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetCaptureBounds(::grpc::ClientContext* context, const ::AR51::BoundInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetCaptureBoundsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::CalibrationVisualizationMessage>> GetVisualization(::grpc::ClientContext* context, const ::AR51::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::CalibrationVisualizationMessage>>(GetVisualizationRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationVisualizationMessage>> AsyncGetVisualization(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationVisualizationMessage>>(AsyncGetVisualizationRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationVisualizationMessage>> PrepareAsyncGetVisualization(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationVisualizationMessage>>(PrepareAsyncGetVisualizationRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void RunCameraCalibration(::grpc::ClientContext* context, ::AR51::DeviceInfo* request, ::grpc::experimental::ClientReadReactor< ::AR51::CalibrationStatus>* reactor) = 0;
      virtual void RunCVtoDeviceCalibration(::grpc::ClientContext* context, ::AR51::DeviceInfo* request, ::grpc::experimental::ClientReadReactor< ::AR51::CalibrationStatus>* reactor) = 0;
      virtual void DownloadAnchor(::grpc::ClientContext* context, ::AR51::AnchorRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::AnchorBytes>* reactor) = 0;
      virtual void GetCaptureBounds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoundInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCaptureBounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoundInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCaptureBounds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoundInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetCaptureBounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoundInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetCaptureBounds(::grpc::ClientContext* context, const ::AR51::BoundInfo* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCaptureBounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCaptureBounds(::grpc::ClientContext* context, const ::AR51::BoundInfo* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetCaptureBounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetVisualization(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::CalibrationVisualizationMessage>* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientReaderInterface< ::AR51::CalibrationStatus>* RunCameraCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationStatus>* AsyncRunCameraCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationStatus>* PrepareAsyncRunCameraCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::AR51::CalibrationStatus>* RunCVtoDeviceCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationStatus>* AsyncRunCVtoDeviceCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationStatus>* PrepareAsyncRunCVtoDeviceCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::AR51::AnchorBytes>* DownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::AnchorBytes>* AsyncDownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::AnchorBytes>* PrepareAsyncDownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoundInfo>* AsyncGetCaptureBoundsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoundInfo>* PrepareAsyncGetCaptureBoundsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetCaptureBoundsRaw(::grpc::ClientContext* context, const ::AR51::BoundInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetCaptureBoundsRaw(::grpc::ClientContext* context, const ::AR51::BoundInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::AR51::CalibrationVisualizationMessage>* GetVisualizationRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationVisualizationMessage>* AsyncGetVisualizationRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::CalibrationVisualizationMessage>* PrepareAsyncGetVisualizationRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    std::unique_ptr< ::grpc::ClientReader< ::AR51::CalibrationStatus>> RunCameraCalibration(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::CalibrationStatus>>(RunCameraCalibrationRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CalibrationStatus>> AsyncRunCameraCalibration(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CalibrationStatus>>(AsyncRunCameraCalibrationRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CalibrationStatus>> PrepareAsyncRunCameraCalibration(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CalibrationStatus>>(PrepareAsyncRunCameraCalibrationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::AR51::CalibrationStatus>> RunCVtoDeviceCalibration(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::CalibrationStatus>>(RunCVtoDeviceCalibrationRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CalibrationStatus>> AsyncRunCVtoDeviceCalibration(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CalibrationStatus>>(AsyncRunCVtoDeviceCalibrationRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CalibrationStatus>> PrepareAsyncRunCVtoDeviceCalibration(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CalibrationStatus>>(PrepareAsyncRunCVtoDeviceCalibrationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::AR51::AnchorBytes>> DownloadAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::AnchorBytes>>(DownloadAnchorRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::AnchorBytes>> AsyncDownloadAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::AnchorBytes>>(AsyncDownloadAnchorRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::AnchorBytes>> PrepareAsyncDownloadAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::AnchorBytes>>(PrepareAsyncDownloadAnchorRaw(context, request, cq));
    }
    ::grpc::Status GetCaptureBounds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoundInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoundInfo>> AsyncGetCaptureBounds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoundInfo>>(AsyncGetCaptureBoundsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoundInfo>> PrepareAsyncGetCaptureBounds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoundInfo>>(PrepareAsyncGetCaptureBoundsRaw(context, request, cq));
    }
    ::grpc::Status SetCaptureBounds(::grpc::ClientContext* context, const ::AR51::BoundInfo& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetCaptureBounds(::grpc::ClientContext* context, const ::AR51::BoundInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetCaptureBoundsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetCaptureBounds(::grpc::ClientContext* context, const ::AR51::BoundInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetCaptureBoundsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::AR51::CalibrationVisualizationMessage>> GetVisualization(::grpc::ClientContext* context, const ::AR51::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::CalibrationVisualizationMessage>>(GetVisualizationRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CalibrationVisualizationMessage>> AsyncGetVisualization(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CalibrationVisualizationMessage>>(AsyncGetVisualizationRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CalibrationVisualizationMessage>> PrepareAsyncGetVisualization(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CalibrationVisualizationMessage>>(PrepareAsyncGetVisualizationRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void RunCameraCalibration(::grpc::ClientContext* context, ::AR51::DeviceInfo* request, ::grpc::experimental::ClientReadReactor< ::AR51::CalibrationStatus>* reactor) override;
      void RunCVtoDeviceCalibration(::grpc::ClientContext* context, ::AR51::DeviceInfo* request, ::grpc::experimental::ClientReadReactor< ::AR51::CalibrationStatus>* reactor) override;
      void DownloadAnchor(::grpc::ClientContext* context, ::AR51::AnchorRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::AnchorBytes>* reactor) override;
      void GetCaptureBounds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoundInfo* response, std::function<void(::grpc::Status)>) override;
      void GetCaptureBounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoundInfo* response, std::function<void(::grpc::Status)>) override;
      void GetCaptureBounds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoundInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetCaptureBounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoundInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetCaptureBounds(::grpc::ClientContext* context, const ::AR51::BoundInfo* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetCaptureBounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetCaptureBounds(::grpc::ClientContext* context, const ::AR51::BoundInfo* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetCaptureBounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetVisualization(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::CalibrationVisualizationMessage>* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientReader< ::AR51::CalibrationStatus>* RunCameraCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request) override;
    ::grpc::ClientAsyncReader< ::AR51::CalibrationStatus>* AsyncRunCameraCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::CalibrationStatus>* PrepareAsyncRunCameraCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::AR51::CalibrationStatus>* RunCVtoDeviceCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request) override;
    ::grpc::ClientAsyncReader< ::AR51::CalibrationStatus>* AsyncRunCVtoDeviceCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::CalibrationStatus>* PrepareAsyncRunCVtoDeviceCalibrationRaw(::grpc::ClientContext* context, const ::AR51::DeviceInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::AR51::AnchorBytes>* DownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request) override;
    ::grpc::ClientAsyncReader< ::AR51::AnchorBytes>* AsyncDownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::AnchorBytes>* PrepareAsyncDownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoundInfo>* AsyncGetCaptureBoundsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoundInfo>* PrepareAsyncGetCaptureBoundsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetCaptureBoundsRaw(::grpc::ClientContext* context, const ::AR51::BoundInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetCaptureBoundsRaw(::grpc::ClientContext* context, const ::AR51::BoundInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::AR51::CalibrationVisualizationMessage>* GetVisualizationRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) override;
    ::grpc::ClientAsyncReader< ::AR51::CalibrationVisualizationMessage>* AsyncGetVisualizationRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::CalibrationVisualizationMessage>* PrepareAsyncGetVisualizationRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_RunCameraCalibration_;
    const ::grpc::internal::RpcMethod rpcmethod_RunCVtoDeviceCalibration_;
    const ::grpc::internal::RpcMethod rpcmethod_DownloadAnchor_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCaptureBounds_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCaptureBounds_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVisualization_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status RunCameraCalibration(::grpc::ServerContext* context, const ::AR51::DeviceInfo* request, ::grpc::ServerWriter< ::AR51::CalibrationStatus>* writer);
    virtual ::grpc::Status RunCVtoDeviceCalibration(::grpc::ServerContext* context, const ::AR51::DeviceInfo* request, ::grpc::ServerWriter< ::AR51::CalibrationStatus>* writer);
    virtual ::grpc::Status DownloadAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::grpc::ServerWriter< ::AR51::AnchorBytes>* writer);
    virtual ::grpc::Status GetCaptureBounds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoundInfo* response);
    virtual ::grpc::Status SetCaptureBounds(::grpc::ServerContext* context, const ::AR51::BoundInfo* request, ::AR51::Empty* response);
    virtual ::grpc::Status GetVisualization(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::CalibrationVisualizationMessage>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_RunCameraCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RunCameraCalibration() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_RunCameraCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunCameraCalibration(::grpc::ServerContext* context, const ::AR51::DeviceInfo* request, ::grpc::ServerWriter< ::AR51::CalibrationStatus>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunCameraCalibration(::grpc::ServerContext* context, ::AR51::DeviceInfo* request, ::grpc::ServerAsyncWriter< ::AR51::CalibrationStatus>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RunCVtoDeviceCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RunCVtoDeviceCalibration() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_RunCVtoDeviceCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunCVtoDeviceCalibration(::grpc::ServerContext* context, const ::AR51::DeviceInfo* request, ::grpc::ServerWriter< ::AR51::CalibrationStatus>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunCVtoDeviceCalibration(::grpc::ServerContext* context, ::AR51::DeviceInfo* request, ::grpc::ServerAsyncWriter< ::AR51::CalibrationStatus>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DownloadAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DownloadAnchor() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_DownloadAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::grpc::ServerWriter< ::AR51::AnchorBytes>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadAnchor(::grpc::ServerContext* context, ::AR51::AnchorRequest* request, ::grpc::ServerAsyncWriter< ::AR51::AnchorBytes>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCaptureBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetCaptureBounds() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetCaptureBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCaptureBounds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoundInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCaptureBounds(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BoundInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCaptureBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetCaptureBounds() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_SetCaptureBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCaptureBounds(::grpc::ServerContext* context, const ::AR51::BoundInfo* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCaptureBounds(::grpc::ServerContext* context, ::AR51::BoundInfo* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVisualization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetVisualization() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetVisualization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisualization(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::CalibrationVisualizationMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVisualization(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncWriter< ::AR51::CalibrationVisualizationMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_RunCameraCalibration<WithAsyncMethod_RunCVtoDeviceCalibration<WithAsyncMethod_DownloadAnchor<WithAsyncMethod_GetCaptureBounds<WithAsyncMethod_SetCaptureBounds<WithAsyncMethod_GetVisualization<Service > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RunCameraCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_RunCameraCalibration() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::DeviceInfo, ::AR51::CalibrationStatus>(
          [this] { return this->RunCameraCalibration(); }));
    }
    ~ExperimentalWithCallbackMethod_RunCameraCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunCameraCalibration(::grpc::ServerContext* context, const ::AR51::DeviceInfo* request, ::grpc::ServerWriter< ::AR51::CalibrationStatus>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::DeviceInfo, ::AR51::CalibrationStatus>* RunCameraCalibration() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::DeviceInfo, ::AR51::CalibrationStatus>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RunCVtoDeviceCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_RunCVtoDeviceCalibration() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::DeviceInfo, ::AR51::CalibrationStatus>(
          [this] { return this->RunCVtoDeviceCalibration(); }));
    }
    ~ExperimentalWithCallbackMethod_RunCVtoDeviceCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunCVtoDeviceCalibration(::grpc::ServerContext* context, const ::AR51::DeviceInfo* request, ::grpc::ServerWriter< ::AR51::CalibrationStatus>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::DeviceInfo, ::AR51::CalibrationStatus>* RunCVtoDeviceCalibration() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::DeviceInfo, ::AR51::CalibrationStatus>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DownloadAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_DownloadAnchor() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::AnchorRequest, ::AR51::AnchorBytes>(
          [this] { return this->DownloadAnchor(); }));
    }
    ~ExperimentalWithCallbackMethod_DownloadAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::grpc::ServerWriter< ::AR51::AnchorBytes>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::AnchorRequest, ::AR51::AnchorBytes>* DownloadAnchor() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::AnchorRequest, ::AR51::AnchorBytes>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetCaptureBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetCaptureBounds() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoundInfo>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::BoundInfo* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetCaptureBounds(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetCaptureBounds(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::BoundInfo>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoundInfo>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetCaptureBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCaptureBounds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoundInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCaptureBounds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoundInfo* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetCaptureBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetCaptureBounds() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::BoundInfo, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::BoundInfo* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetCaptureBounds(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetCaptureBounds(
        ::grpc::experimental::MessageAllocator< ::AR51::BoundInfo, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::BoundInfo, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetCaptureBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCaptureBounds(::grpc::ServerContext* context, const ::AR51::BoundInfo* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetCaptureBounds(::grpc::ServerContext* context, const ::AR51::BoundInfo* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetVisualization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetVisualization() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::Empty, ::AR51::CalibrationVisualizationMessage>(
          [this] { return this->GetVisualization(); }));
    }
    ~ExperimentalWithCallbackMethod_GetVisualization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisualization(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::CalibrationVisualizationMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::Empty, ::AR51::CalibrationVisualizationMessage>* GetVisualization() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::Empty, ::AR51::CalibrationVisualizationMessage>;}
  };
  typedef ExperimentalWithCallbackMethod_RunCameraCalibration<ExperimentalWithCallbackMethod_RunCVtoDeviceCalibration<ExperimentalWithCallbackMethod_DownloadAnchor<ExperimentalWithCallbackMethod_GetCaptureBounds<ExperimentalWithCallbackMethod_SetCaptureBounds<ExperimentalWithCallbackMethod_GetVisualization<Service > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_RunCameraCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RunCameraCalibration() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_RunCameraCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunCameraCalibration(::grpc::ServerContext* context, const ::AR51::DeviceInfo* request, ::grpc::ServerWriter< ::AR51::CalibrationStatus>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RunCVtoDeviceCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RunCVtoDeviceCalibration() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_RunCVtoDeviceCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunCVtoDeviceCalibration(::grpc::ServerContext* context, const ::AR51::DeviceInfo* request, ::grpc::ServerWriter< ::AR51::CalibrationStatus>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DownloadAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DownloadAnchor() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_DownloadAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::grpc::ServerWriter< ::AR51::AnchorBytes>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCaptureBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetCaptureBounds() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetCaptureBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCaptureBounds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoundInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCaptureBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetCaptureBounds() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_SetCaptureBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCaptureBounds(::grpc::ServerContext* context, const ::AR51::BoundInfo* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVisualization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetVisualization() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetVisualization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisualization(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::CalibrationVisualizationMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_RunCameraCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_RunCameraCalibration() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_RunCameraCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunCameraCalibration(::grpc::ServerContext* context, const ::AR51::DeviceInfo* request, ::grpc::ServerWriter< ::AR51::CalibrationStatus>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunCameraCalibration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RunCVtoDeviceCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_RunCVtoDeviceCalibration() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_RunCVtoDeviceCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunCVtoDeviceCalibration(::grpc::ServerContext* context, const ::AR51::DeviceInfo* request, ::grpc::ServerWriter< ::AR51::CalibrationStatus>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunCVtoDeviceCalibration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DownloadAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DownloadAnchor() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_DownloadAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::grpc::ServerWriter< ::AR51::AnchorBytes>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadAnchor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCaptureBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetCaptureBounds() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetCaptureBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCaptureBounds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoundInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCaptureBounds(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCaptureBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetCaptureBounds() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_SetCaptureBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCaptureBounds(::grpc::ServerContext* context, const ::AR51::BoundInfo* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCaptureBounds(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVisualization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetVisualization() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetVisualization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisualization(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::CalibrationVisualizationMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVisualization(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RunCameraCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_RunCameraCalibration() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->RunCameraCalibration(); }));
    }
    ~ExperimentalWithRawCallbackMethod_RunCameraCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunCameraCalibration(::grpc::ServerContext* context, const ::AR51::DeviceInfo* request, ::grpc::ServerWriter< ::AR51::CalibrationStatus>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* RunCameraCalibration() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RunCVtoDeviceCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_RunCVtoDeviceCalibration() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->RunCVtoDeviceCalibration(); }));
    }
    ~ExperimentalWithRawCallbackMethod_RunCVtoDeviceCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunCVtoDeviceCalibration(::grpc::ServerContext* context, const ::AR51::DeviceInfo* request, ::grpc::ServerWriter< ::AR51::CalibrationStatus>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* RunCVtoDeviceCalibration() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DownloadAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_DownloadAnchor() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->DownloadAnchor(); }));
    }
    ~ExperimentalWithRawCallbackMethod_DownloadAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::grpc::ServerWriter< ::AR51::AnchorBytes>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* DownloadAnchor() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetCaptureBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetCaptureBounds() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetCaptureBounds(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetCaptureBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCaptureBounds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoundInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCaptureBounds(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetCaptureBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetCaptureBounds() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetCaptureBounds(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetCaptureBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCaptureBounds(::grpc::ServerContext* context, const ::AR51::BoundInfo* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetCaptureBounds(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetVisualization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetVisualization() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->GetVisualization(); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetVisualization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisualization(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::CalibrationVisualizationMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* GetVisualization() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCaptureBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetCaptureBounds() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::BoundInfo>(std::bind(&WithStreamedUnaryMethod_GetCaptureBounds<BaseClass>::StreamedGetCaptureBounds, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetCaptureBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCaptureBounds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoundInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCaptureBounds(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::BoundInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCaptureBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetCaptureBounds() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::BoundInfo, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetCaptureBounds<BaseClass>::StreamedSetCaptureBounds, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetCaptureBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCaptureBounds(::grpc::ServerContext* context, const ::AR51::BoundInfo* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCaptureBounds(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::BoundInfo,::AR51::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetCaptureBounds<WithStreamedUnaryMethod_SetCaptureBounds<Service > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_RunCameraCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_RunCameraCalibration() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::DeviceInfo, ::AR51::CalibrationStatus>(std::bind(&WithSplitStreamingMethod_RunCameraCalibration<BaseClass>::StreamedRunCameraCalibration, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_RunCameraCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RunCameraCalibration(::grpc::ServerContext* context, const ::AR51::DeviceInfo* request, ::grpc::ServerWriter< ::AR51::CalibrationStatus>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedRunCameraCalibration(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::DeviceInfo,::AR51::CalibrationStatus>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_RunCVtoDeviceCalibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_RunCVtoDeviceCalibration() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::DeviceInfo, ::AR51::CalibrationStatus>(std::bind(&WithSplitStreamingMethod_RunCVtoDeviceCalibration<BaseClass>::StreamedRunCVtoDeviceCalibration, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_RunCVtoDeviceCalibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RunCVtoDeviceCalibration(::grpc::ServerContext* context, const ::AR51::DeviceInfo* request, ::grpc::ServerWriter< ::AR51::CalibrationStatus>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedRunCVtoDeviceCalibration(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::DeviceInfo,::AR51::CalibrationStatus>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_DownloadAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_DownloadAnchor() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::AnchorRequest, ::AR51::AnchorBytes>(std::bind(&WithSplitStreamingMethod_DownloadAnchor<BaseClass>::StreamedDownloadAnchor, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_DownloadAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DownloadAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::grpc::ServerWriter< ::AR51::AnchorBytes>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedDownloadAnchor(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::AnchorRequest,::AR51::AnchorBytes>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GetVisualization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_GetVisualization() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::Empty, ::AR51::CalibrationVisualizationMessage>(std::bind(&WithSplitStreamingMethod_GetVisualization<BaseClass>::StreamedGetVisualization, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_GetVisualization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVisualization(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::CalibrationVisualizationMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetVisualization(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::Empty,::AR51::CalibrationVisualizationMessage>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_RunCameraCalibration<WithSplitStreamingMethod_RunCVtoDeviceCalibration<WithSplitStreamingMethod_DownloadAnchor<WithSplitStreamingMethod_GetVisualization<Service > > > > SplitStreamedService;
  typedef WithSplitStreamingMethod_RunCameraCalibration<WithSplitStreamingMethod_RunCVtoDeviceCalibration<WithSplitStreamingMethod_DownloadAnchor<WithStreamedUnaryMethod_GetCaptureBounds<WithStreamedUnaryMethod_SetCaptureBounds<WithSplitStreamingMethod_GetVisualization<Service > > > > > > StreamedService;
};

class CameraFeedService final {
 public:
  static constexpr char const* service_full_name() {
    return "AR51.CameraFeedService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetAvailableCameras(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::GetAvailableCamerasResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetAvailableCamerasResponse>> AsyncGetAvailableCameras(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetAvailableCamerasResponse>>(AsyncGetAvailableCamerasRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetAvailableCamerasResponse>> PrepareAsyncGetAvailableCameras(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetAvailableCamerasResponse>>(PrepareAsyncGetAvailableCamerasRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::CvsCameraFeedResponse>> GetCameraFeed(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::CvsCameraFeedResponse>>(GetCameraFeedRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CvsCameraFeedResponse>> AsyncGetCameraFeed(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CvsCameraFeedResponse>>(AsyncGetCameraFeedRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CvsCameraFeedResponse>> PrepareAsyncGetCameraFeed(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CvsCameraFeedResponse>>(PrepareAsyncGetCameraFeedRaw(context, request, cq));
    }
    virtual ::grpc::Status SetCameraFeedSettings(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetCameraFeedSettings(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetCameraFeedSettingsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetCameraFeedSettings(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetCameraFeedSettingsRaw(context, request, cq));
    }
    virtual ::grpc::Status GetRecordingReady(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncGetRecordingReady(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncGetRecordingReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncGetRecordingReady(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncGetRecordingReadyRaw(context, request, cq));
    }
    virtual ::grpc::Status StartRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncStartRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncStartRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncStartRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncStartRecordingRaw(context, request, cq));
    }
    virtual ::grpc::Status StopRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncStopRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncStopRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncStopRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncStopRecordingRaw(context, request, cq));
    }
    virtual ::grpc::Status GetFieldValue(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField& request, ::AR51::Float64Message* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>> AsyncGetFieldValue(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>>(AsyncGetFieldValueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>> PrepareAsyncGetFieldValue(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>>(PrepareAsyncGetFieldValueRaw(context, request, cq));
    }
    virtual ::grpc::Status SetFieldValue(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::Float64Message* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>> AsyncSetFieldValue(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>>(AsyncSetFieldValueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>> PrepareAsyncSetFieldValue(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>>(PrepareAsyncSetFieldValueRaw(context, request, cq));
    }
    virtual ::grpc::Status SaveCameraJson(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSaveCameraJson(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSaveCameraJsonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSaveCameraJson(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSaveCameraJsonRaw(context, request, cq));
    }
    virtual ::grpc::Status VideoControlGetCurrentTime(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::Float64Message* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>> AsyncVideoControlGetCurrentTime(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>>(AsyncVideoControlGetCurrentTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>> PrepareAsyncVideoControlGetCurrentTime(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>>(PrepareAsyncVideoControlGetCurrentTimeRaw(context, request, cq));
    }
    virtual ::grpc::Status VideoControlGetDuration(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::Float64Message* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>> AsyncVideoControlGetDuration(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>>(AsyncVideoControlGetDurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>> PrepareAsyncVideoControlGetDuration(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>>(PrepareAsyncVideoControlGetDurationRaw(context, request, cq));
    }
    virtual ::grpc::Status VideoControlGetIsPlaying(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::BoolMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> AsyncVideoControlGetIsPlaying(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(AsyncVideoControlGetIsPlayingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> PrepareAsyncVideoControlGetIsPlaying(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(PrepareAsyncVideoControlGetIsPlayingRaw(context, request, cq));
    }
    virtual ::grpc::Status VideoControlGetIsPaused(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::BoolMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> AsyncVideoControlGetIsPaused(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(AsyncVideoControlGetIsPausedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> PrepareAsyncVideoControlGetIsPaused(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(PrepareAsyncVideoControlGetIsPausedRaw(context, request, cq));
    }
    virtual ::grpc::Status VideoControlSeek(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::BoolMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> AsyncVideoControlSeek(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(AsyncVideoControlSeekRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> PrepareAsyncVideoControlSeek(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(PrepareAsyncVideoControlSeekRaw(context, request, cq));
    }
    virtual ::grpc::Status VideoControlPlay(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::BoolMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> AsyncVideoControlPlay(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(AsyncVideoControlPlayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> PrepareAsyncVideoControlPlay(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(PrepareAsyncVideoControlPlayRaw(context, request, cq));
    }
    virtual ::grpc::Status VideoControlPause(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::BoolMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> AsyncVideoControlPause(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(AsyncVideoControlPauseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> PrepareAsyncVideoControlPause(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(PrepareAsyncVideoControlPauseRaw(context, request, cq));
    }
    virtual ::grpc::Status VideoControlNextFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::BoolMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> AsyncVideoControlNextFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(AsyncVideoControlNextFrameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> PrepareAsyncVideoControlNextFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(PrepareAsyncVideoControlNextFrameRaw(context, request, cq));
    }
    virtual ::grpc::Status VideoControlPrevFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::BoolMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> AsyncVideoControlPrevFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(AsyncVideoControlPrevFrameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> PrepareAsyncVideoControlPrevFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(PrepareAsyncVideoControlPrevFrameRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void GetAvailableCameras(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetAvailableCamerasResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAvailableCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetAvailableCamerasResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAvailableCameras(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetAvailableCamerasResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAvailableCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetAvailableCamerasResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetCameraFeed(::grpc::ClientContext* context, ::AR51::CvsCameraFeedRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::CvsCameraFeedResponse>* reactor) = 0;
      virtual void SetCameraFeedSettings(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCameraFeedSettings(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCameraFeedSettings(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetCameraFeedSettings(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetRecordingReady(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRecordingReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRecordingReady(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetRecordingReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StartRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StopRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetFieldValue(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFieldValue(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFieldValue(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetFieldValue(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetFieldValue(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetFieldValue(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetFieldValue(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetFieldValue(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SaveCameraJson(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SaveCameraJson(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SaveCameraJson(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SaveCameraJson(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlGetCurrentTime(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlGetCurrentTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlGetCurrentTime(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlGetCurrentTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlGetDuration(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlGetDuration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlGetDuration(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlGetDuration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlGetIsPlaying(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlGetIsPlaying(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlGetIsPlaying(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlGetIsPlaying(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlGetIsPaused(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlGetIsPaused(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlGetIsPaused(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlGetIsPaused(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlSeek(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlSeek(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlSeek(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlSeek(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlPlay(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlPlay(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlPlay(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlPlay(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlPause(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlPause(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlPause(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlPause(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlNextFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlNextFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlNextFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlNextFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlPrevFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlPrevFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoControlPrevFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void VideoControlPrevFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetAvailableCamerasResponse>* AsyncGetAvailableCamerasRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetAvailableCamerasResponse>* PrepareAsyncGetAvailableCamerasRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::AR51::CvsCameraFeedResponse>* GetCameraFeedRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::CvsCameraFeedResponse>* AsyncGetCameraFeedRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::CvsCameraFeedResponse>* PrepareAsyncGetCameraFeedRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetCameraFeedSettingsRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetCameraFeedSettingsRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncGetRecordingReadyRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncGetRecordingReadyRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>* AsyncGetFieldValueRaw(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>* PrepareAsyncGetFieldValueRaw(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>* AsyncSetFieldValueRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>* PrepareAsyncSetFieldValueRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSaveCameraJsonRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSaveCameraJsonRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>* AsyncVideoControlGetCurrentTimeRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>* PrepareAsyncVideoControlGetCurrentTimeRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>* AsyncVideoControlGetDurationRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>* PrepareAsyncVideoControlGetDurationRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* AsyncVideoControlGetIsPlayingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* PrepareAsyncVideoControlGetIsPlayingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* AsyncVideoControlGetIsPausedRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* PrepareAsyncVideoControlGetIsPausedRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* AsyncVideoControlSeekRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* PrepareAsyncVideoControlSeekRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* AsyncVideoControlPlayRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* PrepareAsyncVideoControlPlayRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* AsyncVideoControlPauseRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* PrepareAsyncVideoControlPauseRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* AsyncVideoControlNextFrameRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* PrepareAsyncVideoControlNextFrameRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* AsyncVideoControlPrevFrameRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* PrepareAsyncVideoControlPrevFrameRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetAvailableCameras(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::GetAvailableCamerasResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetAvailableCamerasResponse>> AsyncGetAvailableCameras(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetAvailableCamerasResponse>>(AsyncGetAvailableCamerasRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetAvailableCamerasResponse>> PrepareAsyncGetAvailableCameras(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetAvailableCamerasResponse>>(PrepareAsyncGetAvailableCamerasRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::AR51::CvsCameraFeedResponse>> GetCameraFeed(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::CvsCameraFeedResponse>>(GetCameraFeedRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CvsCameraFeedResponse>> AsyncGetCameraFeed(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CvsCameraFeedResponse>>(AsyncGetCameraFeedRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CvsCameraFeedResponse>> PrepareAsyncGetCameraFeed(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CvsCameraFeedResponse>>(PrepareAsyncGetCameraFeedRaw(context, request, cq));
    }
    ::grpc::Status SetCameraFeedSettings(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetCameraFeedSettings(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetCameraFeedSettingsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetCameraFeedSettings(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetCameraFeedSettingsRaw(context, request, cq));
    }
    ::grpc::Status GetRecordingReady(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncGetRecordingReady(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncGetRecordingReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncGetRecordingReady(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncGetRecordingReadyRaw(context, request, cq));
    }
    ::grpc::Status StartRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncStartRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncStartRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncStartRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncStartRecordingRaw(context, request, cq));
    }
    ::grpc::Status StopRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncStopRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncStopRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncStopRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncStopRecordingRaw(context, request, cq));
    }
    ::grpc::Status GetFieldValue(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField& request, ::AR51::Float64Message* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>> AsyncGetFieldValue(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>>(AsyncGetFieldValueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>> PrepareAsyncGetFieldValue(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>>(PrepareAsyncGetFieldValueRaw(context, request, cq));
    }
    ::grpc::Status SetFieldValue(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::Float64Message* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>> AsyncSetFieldValue(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>>(AsyncSetFieldValueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>> PrepareAsyncSetFieldValue(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>>(PrepareAsyncSetFieldValueRaw(context, request, cq));
    }
    ::grpc::Status SaveCameraJson(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSaveCameraJson(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSaveCameraJsonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSaveCameraJson(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSaveCameraJsonRaw(context, request, cq));
    }
    ::grpc::Status VideoControlGetCurrentTime(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::Float64Message* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>> AsyncVideoControlGetCurrentTime(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>>(AsyncVideoControlGetCurrentTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>> PrepareAsyncVideoControlGetCurrentTime(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>>(PrepareAsyncVideoControlGetCurrentTimeRaw(context, request, cq));
    }
    ::grpc::Status VideoControlGetDuration(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::Float64Message* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>> AsyncVideoControlGetDuration(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>>(AsyncVideoControlGetDurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>> PrepareAsyncVideoControlGetDuration(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>>(PrepareAsyncVideoControlGetDurationRaw(context, request, cq));
    }
    ::grpc::Status VideoControlGetIsPlaying(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::BoolMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> AsyncVideoControlGetIsPlaying(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(AsyncVideoControlGetIsPlayingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> PrepareAsyncVideoControlGetIsPlaying(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(PrepareAsyncVideoControlGetIsPlayingRaw(context, request, cq));
    }
    ::grpc::Status VideoControlGetIsPaused(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::AR51::BoolMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> AsyncVideoControlGetIsPaused(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(AsyncVideoControlGetIsPausedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> PrepareAsyncVideoControlGetIsPaused(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(PrepareAsyncVideoControlGetIsPausedRaw(context, request, cq));
    }
    ::grpc::Status VideoControlSeek(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::BoolMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> AsyncVideoControlSeek(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(AsyncVideoControlSeekRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> PrepareAsyncVideoControlSeek(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(PrepareAsyncVideoControlSeekRaw(context, request, cq));
    }
    ::grpc::Status VideoControlPlay(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::BoolMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> AsyncVideoControlPlay(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(AsyncVideoControlPlayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> PrepareAsyncVideoControlPlay(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(PrepareAsyncVideoControlPlayRaw(context, request, cq));
    }
    ::grpc::Status VideoControlPause(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::BoolMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> AsyncVideoControlPause(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(AsyncVideoControlPauseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> PrepareAsyncVideoControlPause(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(PrepareAsyncVideoControlPauseRaw(context, request, cq));
    }
    ::grpc::Status VideoControlNextFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::BoolMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> AsyncVideoControlNextFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(AsyncVideoControlNextFrameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> PrepareAsyncVideoControlNextFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(PrepareAsyncVideoControlNextFrameRaw(context, request, cq));
    }
    ::grpc::Status VideoControlPrevFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::AR51::BoolMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> AsyncVideoControlPrevFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(AsyncVideoControlPrevFrameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> PrepareAsyncVideoControlPrevFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(PrepareAsyncVideoControlPrevFrameRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetAvailableCameras(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetAvailableCamerasResponse* response, std::function<void(::grpc::Status)>) override;
      void GetAvailableCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetAvailableCamerasResponse* response, std::function<void(::grpc::Status)>) override;
      void GetAvailableCameras(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetAvailableCamerasResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAvailableCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetAvailableCamerasResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetCameraFeed(::grpc::ClientContext* context, ::AR51::CvsCameraFeedRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::CvsCameraFeedResponse>* reactor) override;
      void SetCameraFeedSettings(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetCameraFeedSettings(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetCameraFeedSettings(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetCameraFeedSettings(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetRecordingReady(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void GetRecordingReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void GetRecordingReady(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetRecordingReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StartRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void StartRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StopRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void StopRecording(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetFieldValue(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) override;
      void GetFieldValue(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) override;
      void GetFieldValue(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetFieldValue(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetFieldValue(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) override;
      void SetFieldValue(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) override;
      void SetFieldValue(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetFieldValue(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SaveCameraJson(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SaveCameraJson(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SaveCameraJson(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SaveCameraJson(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlGetCurrentTime(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) override;
      void VideoControlGetCurrentTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) override;
      void VideoControlGetCurrentTime(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlGetCurrentTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlGetDuration(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) override;
      void VideoControlGetDuration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) override;
      void VideoControlGetDuration(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlGetDuration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlGetIsPlaying(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void VideoControlGetIsPlaying(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void VideoControlGetIsPlaying(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlGetIsPlaying(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlGetIsPaused(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void VideoControlGetIsPaused(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void VideoControlGetIsPaused(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlGetIsPaused(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlSeek(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void VideoControlSeek(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void VideoControlSeek(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlSeek(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlPlay(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void VideoControlPlay(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void VideoControlPlay(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlPlay(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlPause(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void VideoControlPause(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void VideoControlPause(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlPause(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlNextFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void VideoControlNextFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void VideoControlNextFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlNextFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlPrevFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void VideoControlPrevFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void VideoControlPrevFrame(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void VideoControlPrevFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::AR51::GetAvailableCamerasResponse>* AsyncGetAvailableCamerasRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::GetAvailableCamerasResponse>* PrepareAsyncGetAvailableCamerasRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::AR51::CvsCameraFeedResponse>* GetCameraFeedRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request) override;
    ::grpc::ClientAsyncReader< ::AR51::CvsCameraFeedResponse>* AsyncGetCameraFeedRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::CvsCameraFeedResponse>* PrepareAsyncGetCameraFeedRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetCameraFeedSettingsRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetCameraFeedSettingsRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraFeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncGetRecordingReadyRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncGetRecordingReadyRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* AsyncGetFieldValueRaw(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* PrepareAsyncGetFieldValueRaw(::grpc::ClientContext* context, const ::AR51::GetCvsCameraField& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* AsyncSetFieldValueRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* PrepareAsyncSetFieldValueRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSaveCameraJsonRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSaveCameraJsonRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* AsyncVideoControlGetCurrentTimeRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* PrepareAsyncVideoControlGetCurrentTimeRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* AsyncVideoControlGetDurationRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* PrepareAsyncVideoControlGetDurationRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AsyncVideoControlGetIsPlayingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* PrepareAsyncVideoControlGetIsPlayingRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AsyncVideoControlGetIsPausedRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* PrepareAsyncVideoControlGetIsPausedRaw(::grpc::ClientContext* context, const ::AR51::CvsCameraIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AsyncVideoControlSeekRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* PrepareAsyncVideoControlSeekRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AsyncVideoControlPlayRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* PrepareAsyncVideoControlPlayRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AsyncVideoControlPauseRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* PrepareAsyncVideoControlPauseRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AsyncVideoControlNextFrameRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* PrepareAsyncVideoControlNextFrameRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AsyncVideoControlPrevFrameRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* PrepareAsyncVideoControlPrevFrameRaw(::grpc::ClientContext* context, const ::AR51::SetCvsCameraField& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetAvailableCameras_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCameraFeed_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCameraFeedSettings_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRecordingReady_;
    const ::grpc::internal::RpcMethod rpcmethod_StartRecording_;
    const ::grpc::internal::RpcMethod rpcmethod_StopRecording_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFieldValue_;
    const ::grpc::internal::RpcMethod rpcmethod_SetFieldValue_;
    const ::grpc::internal::RpcMethod rpcmethod_SaveCameraJson_;
    const ::grpc::internal::RpcMethod rpcmethod_VideoControlGetCurrentTime_;
    const ::grpc::internal::RpcMethod rpcmethod_VideoControlGetDuration_;
    const ::grpc::internal::RpcMethod rpcmethod_VideoControlGetIsPlaying_;
    const ::grpc::internal::RpcMethod rpcmethod_VideoControlGetIsPaused_;
    const ::grpc::internal::RpcMethod rpcmethod_VideoControlSeek_;
    const ::grpc::internal::RpcMethod rpcmethod_VideoControlPlay_;
    const ::grpc::internal::RpcMethod rpcmethod_VideoControlPause_;
    const ::grpc::internal::RpcMethod rpcmethod_VideoControlNextFrame_;
    const ::grpc::internal::RpcMethod rpcmethod_VideoControlPrevFrame_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetAvailableCameras(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAvailableCamerasResponse* response);
    virtual ::grpc::Status GetCameraFeed(::grpc::ServerContext* context, const ::AR51::CvsCameraFeedRequest* request, ::grpc::ServerWriter< ::AR51::CvsCameraFeedResponse>* writer);
    virtual ::grpc::Status SetCameraFeedSettings(::grpc::ServerContext* context, const ::AR51::CvsCameraFeedRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status GetRecordingReady(::grpc::ServerContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status GetFieldValue(::grpc::ServerContext* context, const ::AR51::GetCvsCameraField* request, ::AR51::Float64Message* response);
    virtual ::grpc::Status SetFieldValue(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::Float64Message* response);
    virtual ::grpc::Status SaveCameraJson(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response);
    virtual ::grpc::Status VideoControlGetCurrentTime(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response);
    virtual ::grpc::Status VideoControlGetDuration(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response);
    virtual ::grpc::Status VideoControlGetIsPlaying(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response);
    virtual ::grpc::Status VideoControlGetIsPaused(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response);
    virtual ::grpc::Status VideoControlSeek(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response);
    virtual ::grpc::Status VideoControlPlay(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response);
    virtual ::grpc::Status VideoControlPause(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response);
    virtual ::grpc::Status VideoControlNextFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response);
    virtual ::grpc::Status VideoControlPrevFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAvailableCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetAvailableCameras() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetAvailableCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAvailableCameras(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAvailableCamerasResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAvailableCameras(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::GetAvailableCamerasResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCameraFeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetCameraFeed() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetCameraFeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCameraFeed(::grpc::ServerContext* context, const ::AR51::CvsCameraFeedRequest* request, ::grpc::ServerWriter< ::AR51::CvsCameraFeedResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCameraFeed(::grpc::ServerContext* context, ::AR51::CvsCameraFeedRequest* request, ::grpc::ServerAsyncWriter< ::AR51::CvsCameraFeedResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCameraFeedSettings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetCameraFeedSettings() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SetCameraFeedSettings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCameraFeedSettings(::grpc::ServerContext* context, const ::AR51::CvsCameraFeedRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCameraFeedSettings(::grpc::ServerContext* context, ::AR51::CvsCameraFeedRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRecordingReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetRecordingReady() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetRecordingReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecordingReady(::grpc::ServerContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRecordingReady(::grpc::ServerContext* context, ::AR51::CvsCameraGetRecordingReadyRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StartRecording() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRecording(::grpc::ServerContext* context, ::AR51::CvsCameraIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StopRecording() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopRecording(::grpc::ServerContext* context, ::AR51::CvsCameraIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFieldValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetFieldValue() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetFieldValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFieldValue(::grpc::ServerContext* context, const ::AR51::GetCvsCameraField* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFieldValue(::grpc::ServerContext* context, ::AR51::GetCvsCameraField* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Float64Message>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetFieldValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetFieldValue() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_SetFieldValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFieldValue(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetFieldValue(::grpc::ServerContext* context, ::AR51::SetCvsCameraField* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Float64Message>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SaveCameraJson : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SaveCameraJson() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_SaveCameraJson() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveCameraJson(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSaveCameraJson(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VideoControlGetCurrentTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VideoControlGetCurrentTime() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_VideoControlGetCurrentTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetCurrentTime(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlGetCurrentTime(::grpc::ServerContext* context, ::AR51::CvsCameraIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Float64Message>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VideoControlGetDuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VideoControlGetDuration() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_VideoControlGetDuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetDuration(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlGetDuration(::grpc::ServerContext* context, ::AR51::CvsCameraIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Float64Message>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VideoControlGetIsPlaying : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VideoControlGetIsPlaying() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_VideoControlGetIsPlaying() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetIsPlaying(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlGetIsPlaying(::grpc::ServerContext* context, ::AR51::CvsCameraIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BoolMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VideoControlGetIsPaused : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VideoControlGetIsPaused() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_VideoControlGetIsPaused() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetIsPaused(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlGetIsPaused(::grpc::ServerContext* context, ::AR51::CvsCameraIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BoolMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VideoControlSeek : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VideoControlSeek() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_VideoControlSeek() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlSeek(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlSeek(::grpc::ServerContext* context, ::AR51::SetCvsCameraField* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BoolMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VideoControlPlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VideoControlPlay() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_VideoControlPlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlPlay(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlPlay(::grpc::ServerContext* context, ::AR51::SetCvsCameraField* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BoolMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VideoControlPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VideoControlPause() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_VideoControlPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlPause(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlPause(::grpc::ServerContext* context, ::AR51::SetCvsCameraField* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BoolMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VideoControlNextFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VideoControlNextFrame() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_VideoControlNextFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlNextFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlNextFrame(::grpc::ServerContext* context, ::AR51::SetCvsCameraField* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BoolMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VideoControlPrevFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VideoControlPrevFrame() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_VideoControlPrevFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlPrevFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlPrevFrame(::grpc::ServerContext* context, ::AR51::SetCvsCameraField* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BoolMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetAvailableCameras<WithAsyncMethod_GetCameraFeed<WithAsyncMethod_SetCameraFeedSettings<WithAsyncMethod_GetRecordingReady<WithAsyncMethod_StartRecording<WithAsyncMethod_StopRecording<WithAsyncMethod_GetFieldValue<WithAsyncMethod_SetFieldValue<WithAsyncMethod_SaveCameraJson<WithAsyncMethod_VideoControlGetCurrentTime<WithAsyncMethod_VideoControlGetDuration<WithAsyncMethod_VideoControlGetIsPlaying<WithAsyncMethod_VideoControlGetIsPaused<WithAsyncMethod_VideoControlSeek<WithAsyncMethod_VideoControlPlay<WithAsyncMethod_VideoControlPause<WithAsyncMethod_VideoControlNextFrame<WithAsyncMethod_VideoControlPrevFrame<Service > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAvailableCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetAvailableCameras() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::GetAvailableCamerasResponse>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::GetAvailableCamerasResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetAvailableCameras(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetAvailableCameras(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::GetAvailableCamerasResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::GetAvailableCamerasResponse>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAvailableCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAvailableCameras(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAvailableCamerasResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAvailableCameras(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAvailableCamerasResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetCameraFeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetCameraFeed() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::CvsCameraFeedRequest, ::AR51::CvsCameraFeedResponse>(
          [this] { return this->GetCameraFeed(); }));
    }
    ~ExperimentalWithCallbackMethod_GetCameraFeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCameraFeed(::grpc::ServerContext* context, const ::AR51::CvsCameraFeedRequest* request, ::grpc::ServerWriter< ::AR51::CvsCameraFeedResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::CvsCameraFeedRequest, ::AR51::CvsCameraFeedResponse>* GetCameraFeed() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::CvsCameraFeedRequest, ::AR51::CvsCameraFeedResponse>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetCameraFeedSettings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetCameraFeedSettings() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CvsCameraFeedRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::CvsCameraFeedRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetCameraFeedSettings(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetCameraFeedSettings(
        ::grpc::experimental::MessageAllocator< ::AR51::CvsCameraFeedRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CvsCameraFeedRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetCameraFeedSettings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCameraFeedSettings(::grpc::ServerContext* context, const ::AR51::CvsCameraFeedRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetCameraFeedSettings(::grpc::ServerContext* context, const ::AR51::CvsCameraFeedRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRecordingReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetRecordingReady() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CvsCameraGetRecordingReadyRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::CvsCameraGetRecordingReadyRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetRecordingReady(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetRecordingReady(
        ::grpc::experimental::MessageAllocator< ::AR51::CvsCameraGetRecordingReadyRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CvsCameraGetRecordingReadyRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRecordingReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecordingReady(::grpc::ServerContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetRecordingReady(::grpc::ServerContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StartRecording() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::CvsCameraIdRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StartRecording(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StartRecording(
        ::grpc::experimental::MessageAllocator< ::AR51::CvsCameraIdRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StartRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StopRecording() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::CvsCameraIdRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StopRecording(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StopRecording(
        ::grpc::experimental::MessageAllocator< ::AR51::CvsCameraIdRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetFieldValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetFieldValue() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GetCvsCameraField, ::AR51::Float64Message>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::GetCvsCameraField* request,
                 ::AR51::Float64Message* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetFieldValue(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetFieldValue(
        ::grpc::experimental::MessageAllocator< ::AR51::GetCvsCameraField, ::AR51::Float64Message>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GetCvsCameraField, ::AR51::Float64Message>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetFieldValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFieldValue(::grpc::ServerContext* context, const ::AR51::GetCvsCameraField* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetFieldValue(::grpc::ServerContext* context, const ::AR51::GetCvsCameraField* request, ::AR51::Float64Message* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetFieldValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetFieldValue() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::Float64Message>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::SetCvsCameraField* request,
                 ::AR51::Float64Message* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetFieldValue(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetFieldValue(
        ::grpc::experimental::MessageAllocator< ::AR51::SetCvsCameraField, ::AR51::Float64Message>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::Float64Message>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetFieldValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFieldValue(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetFieldValue(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::Float64Message* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SaveCameraJson : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SaveCameraJson() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SaveCameraJson(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SaveCameraJson(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(8))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SaveCameraJson() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveCameraJson(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SaveCameraJson(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VideoControlGetCurrentTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VideoControlGetCurrentTime() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::Float64Message>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::CvsCameraIdRequest* request,
                 ::AR51::Float64Message* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VideoControlGetCurrentTime(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_VideoControlGetCurrentTime(
        ::grpc::experimental::MessageAllocator< ::AR51::CvsCameraIdRequest, ::AR51::Float64Message>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::Float64Message>*>(
          ::grpc::Service::experimental().GetHandler(9))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_VideoControlGetCurrentTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetCurrentTime(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlGetCurrentTime(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VideoControlGetDuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VideoControlGetDuration() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::Float64Message>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::CvsCameraIdRequest* request,
                 ::AR51::Float64Message* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VideoControlGetDuration(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_VideoControlGetDuration(
        ::grpc::experimental::MessageAllocator< ::AR51::CvsCameraIdRequest, ::AR51::Float64Message>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::Float64Message>*>(
          ::grpc::Service::experimental().GetHandler(10))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_VideoControlGetDuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetDuration(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlGetDuration(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VideoControlGetIsPlaying : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VideoControlGetIsPlaying() {
      ::grpc::Service::experimental().MarkMethodCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::BoolMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::CvsCameraIdRequest* request,
                 ::AR51::BoolMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VideoControlGetIsPlaying(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_VideoControlGetIsPlaying(
        ::grpc::experimental::MessageAllocator< ::AR51::CvsCameraIdRequest, ::AR51::BoolMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::BoolMessage>*>(
          ::grpc::Service::experimental().GetHandler(11))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_VideoControlGetIsPlaying() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetIsPlaying(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlGetIsPlaying(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VideoControlGetIsPaused : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VideoControlGetIsPaused() {
      ::grpc::Service::experimental().MarkMethodCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::BoolMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::CvsCameraIdRequest* request,
                 ::AR51::BoolMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VideoControlGetIsPaused(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_VideoControlGetIsPaused(
        ::grpc::experimental::MessageAllocator< ::AR51::CvsCameraIdRequest, ::AR51::BoolMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::BoolMessage>*>(
          ::grpc::Service::experimental().GetHandler(12))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_VideoControlGetIsPaused() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetIsPaused(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlGetIsPaused(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VideoControlSeek : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VideoControlSeek() {
      ::grpc::Service::experimental().MarkMethodCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::SetCvsCameraField* request,
                 ::AR51::BoolMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VideoControlSeek(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_VideoControlSeek(
        ::grpc::experimental::MessageAllocator< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>*>(
          ::grpc::Service::experimental().GetHandler(13))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_VideoControlSeek() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlSeek(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlSeek(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VideoControlPlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VideoControlPlay() {
      ::grpc::Service::experimental().MarkMethodCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::SetCvsCameraField* request,
                 ::AR51::BoolMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VideoControlPlay(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_VideoControlPlay(
        ::grpc::experimental::MessageAllocator< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>*>(
          ::grpc::Service::experimental().GetHandler(14))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_VideoControlPlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlPlay(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlPlay(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VideoControlPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VideoControlPause() {
      ::grpc::Service::experimental().MarkMethodCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::SetCvsCameraField* request,
                 ::AR51::BoolMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VideoControlPause(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_VideoControlPause(
        ::grpc::experimental::MessageAllocator< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>*>(
          ::grpc::Service::experimental().GetHandler(15))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_VideoControlPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlPause(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlPause(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VideoControlNextFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VideoControlNextFrame() {
      ::grpc::Service::experimental().MarkMethodCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::SetCvsCameraField* request,
                 ::AR51::BoolMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VideoControlNextFrame(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_VideoControlNextFrame(
        ::grpc::experimental::MessageAllocator< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>*>(
          ::grpc::Service::experimental().GetHandler(16))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_VideoControlNextFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlNextFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlNextFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VideoControlPrevFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VideoControlPrevFrame() {
      ::grpc::Service::experimental().MarkMethodCallback(17,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::SetCvsCameraField* request,
                 ::AR51::BoolMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VideoControlPrevFrame(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_VideoControlPrevFrame(
        ::grpc::experimental::MessageAllocator< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>*>(
          ::grpc::Service::experimental().GetHandler(17))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_VideoControlPrevFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlPrevFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlPrevFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_GetAvailableCameras<ExperimentalWithCallbackMethod_GetCameraFeed<ExperimentalWithCallbackMethod_SetCameraFeedSettings<ExperimentalWithCallbackMethod_GetRecordingReady<ExperimentalWithCallbackMethod_StartRecording<ExperimentalWithCallbackMethod_StopRecording<ExperimentalWithCallbackMethod_GetFieldValue<ExperimentalWithCallbackMethod_SetFieldValue<ExperimentalWithCallbackMethod_SaveCameraJson<ExperimentalWithCallbackMethod_VideoControlGetCurrentTime<ExperimentalWithCallbackMethod_VideoControlGetDuration<ExperimentalWithCallbackMethod_VideoControlGetIsPlaying<ExperimentalWithCallbackMethod_VideoControlGetIsPaused<ExperimentalWithCallbackMethod_VideoControlSeek<ExperimentalWithCallbackMethod_VideoControlPlay<ExperimentalWithCallbackMethod_VideoControlPause<ExperimentalWithCallbackMethod_VideoControlNextFrame<ExperimentalWithCallbackMethod_VideoControlPrevFrame<Service > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetAvailableCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetAvailableCameras() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetAvailableCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAvailableCameras(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAvailableCamerasResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCameraFeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetCameraFeed() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetCameraFeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCameraFeed(::grpc::ServerContext* context, const ::AR51::CvsCameraFeedRequest* request, ::grpc::ServerWriter< ::AR51::CvsCameraFeedResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCameraFeedSettings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetCameraFeedSettings() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SetCameraFeedSettings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCameraFeedSettings(::grpc::ServerContext* context, const ::AR51::CvsCameraFeedRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRecordingReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetRecordingReady() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetRecordingReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecordingReady(::grpc::ServerContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StartRecording() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StopRecording() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFieldValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetFieldValue() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetFieldValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFieldValue(::grpc::ServerContext* context, const ::AR51::GetCvsCameraField* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetFieldValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetFieldValue() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_SetFieldValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFieldValue(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SaveCameraJson : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SaveCameraJson() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_SaveCameraJson() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveCameraJson(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VideoControlGetCurrentTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VideoControlGetCurrentTime() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_VideoControlGetCurrentTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetCurrentTime(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VideoControlGetDuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VideoControlGetDuration() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_VideoControlGetDuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetDuration(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VideoControlGetIsPlaying : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VideoControlGetIsPlaying() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_VideoControlGetIsPlaying() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetIsPlaying(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VideoControlGetIsPaused : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VideoControlGetIsPaused() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_VideoControlGetIsPaused() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetIsPaused(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VideoControlSeek : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VideoControlSeek() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_VideoControlSeek() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlSeek(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VideoControlPlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VideoControlPlay() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_VideoControlPlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlPlay(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VideoControlPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VideoControlPause() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_VideoControlPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlPause(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VideoControlNextFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VideoControlNextFrame() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_VideoControlNextFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlNextFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VideoControlPrevFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VideoControlPrevFrame() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_VideoControlPrevFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlPrevFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAvailableCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetAvailableCameras() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetAvailableCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAvailableCameras(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAvailableCamerasResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAvailableCameras(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCameraFeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetCameraFeed() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetCameraFeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCameraFeed(::grpc::ServerContext* context, const ::AR51::CvsCameraFeedRequest* request, ::grpc::ServerWriter< ::AR51::CvsCameraFeedResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCameraFeed(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCameraFeedSettings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetCameraFeedSettings() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SetCameraFeedSettings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCameraFeedSettings(::grpc::ServerContext* context, const ::AR51::CvsCameraFeedRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCameraFeedSettings(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRecordingReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetRecordingReady() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetRecordingReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecordingReady(::grpc::ServerContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRecordingReady(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StartRecording() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRecording(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StopRecording() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopRecording(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFieldValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetFieldValue() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetFieldValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFieldValue(::grpc::ServerContext* context, const ::AR51::GetCvsCameraField* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFieldValue(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetFieldValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetFieldValue() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_SetFieldValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFieldValue(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetFieldValue(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SaveCameraJson : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SaveCameraJson() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_SaveCameraJson() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveCameraJson(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSaveCameraJson(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VideoControlGetCurrentTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VideoControlGetCurrentTime() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_VideoControlGetCurrentTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetCurrentTime(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlGetCurrentTime(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VideoControlGetDuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VideoControlGetDuration() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_VideoControlGetDuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetDuration(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlGetDuration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VideoControlGetIsPlaying : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VideoControlGetIsPlaying() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_VideoControlGetIsPlaying() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetIsPlaying(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlGetIsPlaying(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VideoControlGetIsPaused : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VideoControlGetIsPaused() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_VideoControlGetIsPaused() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetIsPaused(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlGetIsPaused(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VideoControlSeek : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VideoControlSeek() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_VideoControlSeek() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlSeek(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlSeek(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VideoControlPlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VideoControlPlay() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_VideoControlPlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlPlay(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlPlay(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VideoControlPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VideoControlPause() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_VideoControlPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlPause(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlPause(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VideoControlNextFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VideoControlNextFrame() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_VideoControlNextFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlNextFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlNextFrame(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VideoControlPrevFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VideoControlPrevFrame() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_VideoControlPrevFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlPrevFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoControlPrevFrame(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAvailableCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAvailableCameras() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetAvailableCameras(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAvailableCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAvailableCameras(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAvailableCamerasResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAvailableCameras(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetCameraFeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetCameraFeed() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->GetCameraFeed(); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetCameraFeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCameraFeed(::grpc::ServerContext* context, const ::AR51::CvsCameraFeedRequest* request, ::grpc::ServerWriter< ::AR51::CvsCameraFeedResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* GetCameraFeed() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetCameraFeedSettings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetCameraFeedSettings() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetCameraFeedSettings(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetCameraFeedSettings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCameraFeedSettings(::grpc::ServerContext* context, const ::AR51::CvsCameraFeedRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetCameraFeedSettings(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRecordingReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRecordingReady() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetRecordingReady(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRecordingReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecordingReady(::grpc::ServerContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetRecordingReady(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StartRecording() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StartRecording(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StartRecording(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StopRecording() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StopRecording(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopRecording(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetFieldValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetFieldValue() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetFieldValue(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetFieldValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFieldValue(::grpc::ServerContext* context, const ::AR51::GetCvsCameraField* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetFieldValue(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetFieldValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetFieldValue() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetFieldValue(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetFieldValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFieldValue(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetFieldValue(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SaveCameraJson : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SaveCameraJson() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SaveCameraJson(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SaveCameraJson() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveCameraJson(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SaveCameraJson(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VideoControlGetCurrentTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VideoControlGetCurrentTime() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VideoControlGetCurrentTime(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VideoControlGetCurrentTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetCurrentTime(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlGetCurrentTime(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VideoControlGetDuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VideoControlGetDuration() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VideoControlGetDuration(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VideoControlGetDuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetDuration(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlGetDuration(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VideoControlGetIsPlaying : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VideoControlGetIsPlaying() {
      ::grpc::Service::experimental().MarkMethodRawCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VideoControlGetIsPlaying(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VideoControlGetIsPlaying() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetIsPlaying(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlGetIsPlaying(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VideoControlGetIsPaused : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VideoControlGetIsPaused() {
      ::grpc::Service::experimental().MarkMethodRawCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VideoControlGetIsPaused(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VideoControlGetIsPaused() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlGetIsPaused(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlGetIsPaused(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VideoControlSeek : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VideoControlSeek() {
      ::grpc::Service::experimental().MarkMethodRawCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VideoControlSeek(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VideoControlSeek() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlSeek(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlSeek(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VideoControlPlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VideoControlPlay() {
      ::grpc::Service::experimental().MarkMethodRawCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VideoControlPlay(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VideoControlPlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlPlay(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlPlay(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VideoControlPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VideoControlPause() {
      ::grpc::Service::experimental().MarkMethodRawCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VideoControlPause(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VideoControlPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlPause(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlPause(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VideoControlNextFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VideoControlNextFrame() {
      ::grpc::Service::experimental().MarkMethodRawCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VideoControlNextFrame(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VideoControlNextFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlNextFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlNextFrame(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VideoControlPrevFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VideoControlPrevFrame() {
      ::grpc::Service::experimental().MarkMethodRawCallback(17,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VideoControlPrevFrame(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VideoControlPrevFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoControlPrevFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VideoControlPrevFrame(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAvailableCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetAvailableCameras() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::GetAvailableCamerasResponse>(std::bind(&WithStreamedUnaryMethod_GetAvailableCameras<BaseClass>::StreamedGetAvailableCameras, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetAvailableCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAvailableCameras(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAvailableCamerasResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAvailableCameras(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::GetAvailableCamerasResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCameraFeedSettings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetCameraFeedSettings() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::CvsCameraFeedRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetCameraFeedSettings<BaseClass>::StreamedSetCameraFeedSettings, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetCameraFeedSettings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCameraFeedSettings(::grpc::ServerContext* context, const ::AR51::CvsCameraFeedRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCameraFeedSettings(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::CvsCameraFeedRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRecordingReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetRecordingReady() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::CvsCameraGetRecordingReadyRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_GetRecordingReady<BaseClass>::StreamedGetRecordingReady, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetRecordingReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRecordingReady(::grpc::ServerContext* context, const ::AR51::CvsCameraGetRecordingReadyRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRecordingReady(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::CvsCameraGetRecordingReadyRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StartRecording() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_StartRecording<BaseClass>::StreamedStartRecording, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartRecording(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::CvsCameraIdRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StopRecording() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_StopRecording<BaseClass>::StreamedStopRecording, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopRecording(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::CvsCameraIdRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFieldValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetFieldValue() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::GetCvsCameraField, ::AR51::Float64Message>(std::bind(&WithStreamedUnaryMethod_GetFieldValue<BaseClass>::StreamedGetFieldValue, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetFieldValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFieldValue(::grpc::ServerContext* context, const ::AR51::GetCvsCameraField* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFieldValue(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::GetCvsCameraField,::AR51::Float64Message>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetFieldValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetFieldValue() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::Float64Message>(std::bind(&WithStreamedUnaryMethod_SetFieldValue<BaseClass>::StreamedSetFieldValue, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetFieldValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetFieldValue(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetFieldValue(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::SetCvsCameraField,::AR51::Float64Message>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SaveCameraJson : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SaveCameraJson() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SaveCameraJson<BaseClass>::StreamedSaveCameraJson, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SaveCameraJson() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SaveCameraJson(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSaveCameraJson(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VideoControlGetCurrentTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VideoControlGetCurrentTime() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::Float64Message>(std::bind(&WithStreamedUnaryMethod_VideoControlGetCurrentTime<BaseClass>::StreamedVideoControlGetCurrentTime, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VideoControlGetCurrentTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VideoControlGetCurrentTime(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVideoControlGetCurrentTime(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::CvsCameraIdRequest,::AR51::Float64Message>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VideoControlGetDuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VideoControlGetDuration() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::Float64Message>(std::bind(&WithStreamedUnaryMethod_VideoControlGetDuration<BaseClass>::StreamedVideoControlGetDuration, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VideoControlGetDuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VideoControlGetDuration(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVideoControlGetDuration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::CvsCameraIdRequest,::AR51::Float64Message>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VideoControlGetIsPlaying : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VideoControlGetIsPlaying() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::BoolMessage>(std::bind(&WithStreamedUnaryMethod_VideoControlGetIsPlaying<BaseClass>::StreamedVideoControlGetIsPlaying, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VideoControlGetIsPlaying() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VideoControlGetIsPlaying(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVideoControlGetIsPlaying(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::CvsCameraIdRequest,::AR51::BoolMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VideoControlGetIsPaused : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VideoControlGetIsPaused() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::CvsCameraIdRequest, ::AR51::BoolMessage>(std::bind(&WithStreamedUnaryMethod_VideoControlGetIsPaused<BaseClass>::StreamedVideoControlGetIsPaused, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VideoControlGetIsPaused() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VideoControlGetIsPaused(::grpc::ServerContext* context, const ::AR51::CvsCameraIdRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVideoControlGetIsPaused(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::CvsCameraIdRequest,::AR51::BoolMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VideoControlSeek : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VideoControlSeek() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>(std::bind(&WithStreamedUnaryMethod_VideoControlSeek<BaseClass>::StreamedVideoControlSeek, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VideoControlSeek() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VideoControlSeek(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVideoControlSeek(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::SetCvsCameraField,::AR51::BoolMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VideoControlPlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VideoControlPlay() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>(std::bind(&WithStreamedUnaryMethod_VideoControlPlay<BaseClass>::StreamedVideoControlPlay, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VideoControlPlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VideoControlPlay(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVideoControlPlay(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::SetCvsCameraField,::AR51::BoolMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VideoControlPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VideoControlPause() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>(std::bind(&WithStreamedUnaryMethod_VideoControlPause<BaseClass>::StreamedVideoControlPause, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VideoControlPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VideoControlPause(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVideoControlPause(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::SetCvsCameraField,::AR51::BoolMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VideoControlNextFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VideoControlNextFrame() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>(std::bind(&WithStreamedUnaryMethod_VideoControlNextFrame<BaseClass>::StreamedVideoControlNextFrame, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VideoControlNextFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VideoControlNextFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVideoControlNextFrame(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::SetCvsCameraField,::AR51::BoolMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VideoControlPrevFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VideoControlPrevFrame() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::SetCvsCameraField, ::AR51::BoolMessage>(std::bind(&WithStreamedUnaryMethod_VideoControlPrevFrame<BaseClass>::StreamedVideoControlPrevFrame, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VideoControlPrevFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VideoControlPrevFrame(::grpc::ServerContext* context, const ::AR51::SetCvsCameraField* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVideoControlPrevFrame(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::SetCvsCameraField,::AR51::BoolMessage>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetAvailableCameras<WithStreamedUnaryMethod_SetCameraFeedSettings<WithStreamedUnaryMethod_GetRecordingReady<WithStreamedUnaryMethod_StartRecording<WithStreamedUnaryMethod_StopRecording<WithStreamedUnaryMethod_GetFieldValue<WithStreamedUnaryMethod_SetFieldValue<WithStreamedUnaryMethod_SaveCameraJson<WithStreamedUnaryMethod_VideoControlGetCurrentTime<WithStreamedUnaryMethod_VideoControlGetDuration<WithStreamedUnaryMethod_VideoControlGetIsPlaying<WithStreamedUnaryMethod_VideoControlGetIsPaused<WithStreamedUnaryMethod_VideoControlSeek<WithStreamedUnaryMethod_VideoControlPlay<WithStreamedUnaryMethod_VideoControlPause<WithStreamedUnaryMethod_VideoControlNextFrame<WithStreamedUnaryMethod_VideoControlPrevFrame<Service > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_GetCameraFeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_GetCameraFeed() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::CvsCameraFeedRequest, ::AR51::CvsCameraFeedResponse>(std::bind(&WithSplitStreamingMethod_GetCameraFeed<BaseClass>::StreamedGetCameraFeed, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_GetCameraFeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCameraFeed(::grpc::ServerContext* context, const ::AR51::CvsCameraFeedRequest* request, ::grpc::ServerWriter< ::AR51::CvsCameraFeedResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetCameraFeed(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::CvsCameraFeedRequest,::AR51::CvsCameraFeedResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_GetCameraFeed<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetAvailableCameras<WithSplitStreamingMethod_GetCameraFeed<WithStreamedUnaryMethod_SetCameraFeedSettings<WithStreamedUnaryMethod_GetRecordingReady<WithStreamedUnaryMethod_StartRecording<WithStreamedUnaryMethod_StopRecording<WithStreamedUnaryMethod_GetFieldValue<WithStreamedUnaryMethod_SetFieldValue<WithStreamedUnaryMethod_SaveCameraJson<WithStreamedUnaryMethod_VideoControlGetCurrentTime<WithStreamedUnaryMethod_VideoControlGetDuration<WithStreamedUnaryMethod_VideoControlGetIsPlaying<WithStreamedUnaryMethod_VideoControlGetIsPaused<WithStreamedUnaryMethod_VideoControlSeek<WithStreamedUnaryMethod_VideoControlPlay<WithStreamedUnaryMethod_VideoControlPause<WithStreamedUnaryMethod_VideoControlNextFrame<WithStreamedUnaryMethod_VideoControlPrevFrame<Service > > > > > > > > > > > > > > > > > > StreamedService;
};

class ObjectDetectionService final {
 public:
  static constexpr char const* service_full_name() {
    return "AR51.ObjectDetectionService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::Empty>> TrackItem(::grpc::ClientContext* context, const ::AR51::TrackedObjectInfo& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::Empty>>(TrackItemRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::Empty>> AsyncTrackItem(::grpc::ClientContext* context, const ::AR51::TrackedObjectInfo& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::Empty>>(AsyncTrackItemRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::Empty>> PrepareAsyncTrackItem(::grpc::ClientContext* context, const ::AR51::TrackedObjectInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::Empty>>(PrepareAsyncTrackItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::Empty>> UntrackItem(::grpc::ClientContext* context, const ::AR51::StringMessage& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::Empty>>(UntrackItemRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::Empty>> AsyncUntrackItem(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::Empty>>(AsyncUntrackItemRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::Empty>> PrepareAsyncUntrackItem(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::Empty>>(PrepareAsyncUntrackItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::ObjectDetectionReply>> Register(::grpc::ClientContext* context, const ::AR51::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::ObjectDetectionReply>>(RegisterRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::ObjectDetectionReply>> AsyncRegister(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::ObjectDetectionReply>>(AsyncRegisterRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::ObjectDetectionReply>> PrepareAsyncRegister(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::ObjectDetectionReply>>(PrepareAsyncRegisterRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void TrackItem(::grpc::ClientContext* context, ::AR51::TrackedObjectInfo* request, ::grpc::experimental::ClientReadReactor< ::AR51::Empty>* reactor) = 0;
      virtual void UntrackItem(::grpc::ClientContext* context, ::AR51::StringMessage* request, ::grpc::experimental::ClientReadReactor< ::AR51::Empty>* reactor) = 0;
      virtual void Register(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::ObjectDetectionReply>* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientReaderInterface< ::AR51::Empty>* TrackItemRaw(::grpc::ClientContext* context, const ::AR51::TrackedObjectInfo& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::Empty>* AsyncTrackItemRaw(::grpc::ClientContext* context, const ::AR51::TrackedObjectInfo& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::Empty>* PrepareAsyncTrackItemRaw(::grpc::ClientContext* context, const ::AR51::TrackedObjectInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::AR51::Empty>* UntrackItemRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::Empty>* AsyncUntrackItemRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::Empty>* PrepareAsyncUntrackItemRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::AR51::ObjectDetectionReply>* RegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::ObjectDetectionReply>* AsyncRegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::ObjectDetectionReply>* PrepareAsyncRegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    std::unique_ptr< ::grpc::ClientReader< ::AR51::Empty>> TrackItem(::grpc::ClientContext* context, const ::AR51::TrackedObjectInfo& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::Empty>>(TrackItemRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::Empty>> AsyncTrackItem(::grpc::ClientContext* context, const ::AR51::TrackedObjectInfo& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::Empty>>(AsyncTrackItemRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::Empty>> PrepareAsyncTrackItem(::grpc::ClientContext* context, const ::AR51::TrackedObjectInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::Empty>>(PrepareAsyncTrackItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::AR51::Empty>> UntrackItem(::grpc::ClientContext* context, const ::AR51::StringMessage& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::Empty>>(UntrackItemRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::Empty>> AsyncUntrackItem(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::Empty>>(AsyncUntrackItemRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::Empty>> PrepareAsyncUntrackItem(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::Empty>>(PrepareAsyncUntrackItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::AR51::ObjectDetectionReply>> Register(::grpc::ClientContext* context, const ::AR51::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::ObjectDetectionReply>>(RegisterRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::ObjectDetectionReply>> AsyncRegister(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::ObjectDetectionReply>>(AsyncRegisterRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::ObjectDetectionReply>> PrepareAsyncRegister(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::ObjectDetectionReply>>(PrepareAsyncRegisterRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void TrackItem(::grpc::ClientContext* context, ::AR51::TrackedObjectInfo* request, ::grpc::experimental::ClientReadReactor< ::AR51::Empty>* reactor) override;
      void UntrackItem(::grpc::ClientContext* context, ::AR51::StringMessage* request, ::grpc::experimental::ClientReadReactor< ::AR51::Empty>* reactor) override;
      void Register(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::ObjectDetectionReply>* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientReader< ::AR51::Empty>* TrackItemRaw(::grpc::ClientContext* context, const ::AR51::TrackedObjectInfo& request) override;
    ::grpc::ClientAsyncReader< ::AR51::Empty>* AsyncTrackItemRaw(::grpc::ClientContext* context, const ::AR51::TrackedObjectInfo& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::Empty>* PrepareAsyncTrackItemRaw(::grpc::ClientContext* context, const ::AR51::TrackedObjectInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::AR51::Empty>* UntrackItemRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request) override;
    ::grpc::ClientAsyncReader< ::AR51::Empty>* AsyncUntrackItemRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::Empty>* PrepareAsyncUntrackItemRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::AR51::ObjectDetectionReply>* RegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) override;
    ::grpc::ClientAsyncReader< ::AR51::ObjectDetectionReply>* AsyncRegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::ObjectDetectionReply>* PrepareAsyncRegisterRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_TrackItem_;
    const ::grpc::internal::RpcMethod rpcmethod_UntrackItem_;
    const ::grpc::internal::RpcMethod rpcmethod_Register_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status TrackItem(::grpc::ServerContext* context, const ::AR51::TrackedObjectInfo* request, ::grpc::ServerWriter< ::AR51::Empty>* writer);
    virtual ::grpc::Status UntrackItem(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::grpc::ServerWriter< ::AR51::Empty>* writer);
    virtual ::grpc::Status Register(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::ObjectDetectionReply>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_TrackItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_TrackItem() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_TrackItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TrackItem(::grpc::ServerContext* context, const ::AR51::TrackedObjectInfo* request, ::grpc::ServerWriter< ::AR51::Empty>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTrackItem(::grpc::ServerContext* context, ::AR51::TrackedObjectInfo* request, ::grpc::ServerAsyncWriter< ::AR51::Empty>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UntrackItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UntrackItem() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_UntrackItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UntrackItem(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::grpc::ServerWriter< ::AR51::Empty>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUntrackItem(::grpc::ServerContext* context, ::AR51::StringMessage* request, ::grpc::ServerAsyncWriter< ::AR51::Empty>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Register() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::ObjectDetectionReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegister(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncWriter< ::AR51::ObjectDetectionReply>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_TrackItem<WithAsyncMethod_UntrackItem<WithAsyncMethod_Register<Service > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TrackItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_TrackItem() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::TrackedObjectInfo, ::AR51::Empty>(
          [this] { return this->TrackItem(); }));
    }
    ~ExperimentalWithCallbackMethod_TrackItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TrackItem(::grpc::ServerContext* context, const ::AR51::TrackedObjectInfo* request, ::grpc::ServerWriter< ::AR51::Empty>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::TrackedObjectInfo, ::AR51::Empty>* TrackItem() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::TrackedObjectInfo, ::AR51::Empty>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UntrackItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UntrackItem() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::StringMessage, ::AR51::Empty>(
          [this] { return this->UntrackItem(); }));
    }
    ~ExperimentalWithCallbackMethod_UntrackItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UntrackItem(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::grpc::ServerWriter< ::AR51::Empty>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::StringMessage, ::AR51::Empty>* UntrackItem() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::StringMessage, ::AR51::Empty>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Register() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::Empty, ::AR51::ObjectDetectionReply>(
          [this] { return this->Register(); }));
    }
    ~ExperimentalWithCallbackMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::ObjectDetectionReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::Empty, ::AR51::ObjectDetectionReply>* Register() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::Empty, ::AR51::ObjectDetectionReply>;}
  };
  typedef ExperimentalWithCallbackMethod_TrackItem<ExperimentalWithCallbackMethod_UntrackItem<ExperimentalWithCallbackMethod_Register<Service > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_TrackItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_TrackItem() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_TrackItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TrackItem(::grpc::ServerContext* context, const ::AR51::TrackedObjectInfo* request, ::grpc::ServerWriter< ::AR51::Empty>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UntrackItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UntrackItem() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_UntrackItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UntrackItem(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::grpc::ServerWriter< ::AR51::Empty>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Register() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::ObjectDetectionReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_TrackItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_TrackItem() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_TrackItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TrackItem(::grpc::ServerContext* context, const ::AR51::TrackedObjectInfo* request, ::grpc::ServerWriter< ::AR51::Empty>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTrackItem(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UntrackItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UntrackItem() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_UntrackItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UntrackItem(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::grpc::ServerWriter< ::AR51::Empty>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUntrackItem(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Register() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::ObjectDetectionReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegister(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TrackItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_TrackItem() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->TrackItem(); }));
    }
    ~ExperimentalWithRawCallbackMethod_TrackItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TrackItem(::grpc::ServerContext* context, const ::AR51::TrackedObjectInfo* request, ::grpc::ServerWriter< ::AR51::Empty>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* TrackItem() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UntrackItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UntrackItem() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->UntrackItem(); }));
    }
    ~ExperimentalWithRawCallbackMethod_UntrackItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UntrackItem(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::grpc::ServerWriter< ::AR51::Empty>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* UntrackItem() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Register() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->Register(); }));
    }
    ~ExperimentalWithRawCallbackMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::ObjectDetectionReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* Register() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  typedef Service StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_TrackItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_TrackItem() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::TrackedObjectInfo, ::AR51::Empty>(std::bind(&WithSplitStreamingMethod_TrackItem<BaseClass>::StreamedTrackItem, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_TrackItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TrackItem(::grpc::ServerContext* context, const ::AR51::TrackedObjectInfo* request, ::grpc::ServerWriter< ::AR51::Empty>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedTrackItem(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::TrackedObjectInfo,::AR51::Empty>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_UntrackItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_UntrackItem() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::StringMessage, ::AR51::Empty>(std::bind(&WithSplitStreamingMethod_UntrackItem<BaseClass>::StreamedUntrackItem, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_UntrackItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UntrackItem(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::grpc::ServerWriter< ::AR51::Empty>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedUntrackItem(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::StringMessage,::AR51::Empty>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_Register() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::Empty, ::AR51::ObjectDetectionReply>(std::bind(&WithSplitStreamingMethod_Register<BaseClass>::StreamedRegister, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::ObjectDetectionReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedRegister(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::Empty,::AR51::ObjectDetectionReply>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_TrackItem<WithSplitStreamingMethod_UntrackItem<WithSplitStreamingMethod_Register<Service > > > SplitStreamedService;
  typedef WithSplitStreamingMethod_TrackItem<WithSplitStreamingMethod_UntrackItem<WithSplitStreamingMethod_Register<Service > > > StreamedService;
};

}  // namespace AR51


#endif  // GRPC_cvs_2eproto__INCLUDED
