// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dgsEnums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dgsEnums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dgsEnums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dgsEnums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dgsEnums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dgsEnums_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace AR51 {

enum GameState : int {
  Ready = 0,
  Lobby = 1,
  Started = 2,
  Stopped = 3,
  Setup = 4,
  GameState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GameState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GameState_IsValid(int value);
constexpr GameState GameState_MIN = Ready;
constexpr GameState GameState_MAX = Setup;
constexpr int GameState_ARRAYSIZE = GameState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameState_descriptor();
template<typename T>
inline const std::string& GameState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GameState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GameState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GameState_descriptor(), enum_t_value);
}
inline bool GameState_Parse(
    const std::string& name, GameState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GameState>(
    GameState_descriptor(), name, value);
}
enum LensFacing : int {
  Front = 0,
  Back = 1,
  External = 3,
  LensFacing_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LensFacing_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LensFacing_IsValid(int value);
constexpr LensFacing LensFacing_MIN = Front;
constexpr LensFacing LensFacing_MAX = External;
constexpr int LensFacing_ARRAYSIZE = LensFacing_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LensFacing_descriptor();
template<typename T>
inline const std::string& LensFacing_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LensFacing>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LensFacing_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LensFacing_descriptor(), enum_t_value);
}
inline bool LensFacing_Parse(
    const std::string& name, LensFacing* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LensFacing>(
    LensFacing_descriptor(), name, value);
}
enum InputType : int {
  NoInput = 0,
  Clicked = 1,
  InputType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  InputType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool InputType_IsValid(int value);
constexpr InputType InputType_MIN = NoInput;
constexpr InputType InputType_MAX = Clicked;
constexpr int InputType_ARRAYSIZE = InputType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InputType_descriptor();
template<typename T>
inline const std::string& InputType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InputType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InputType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InputType_descriptor(), enum_t_value);
}
inline bool InputType_Parse(
    const std::string& name, InputType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InputType>(
    InputType_descriptor(), name, value);
}
enum TransformTypes : int {
  NoTransform = 0,
  position = 1,
  localPosition = 2,
  rotation = 4,
  localRotation = 8,
  localScale = 16,
  lossyScale = 32,
  eulerAngles = 64,
  localEulerAngles = 128,
  worldToLocalMatrix = 256,
  localToWorldMatrix = 512,
  TransformTypes_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TransformTypes_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TransformTypes_IsValid(int value);
constexpr TransformTypes TransformTypes_MIN = NoTransform;
constexpr TransformTypes TransformTypes_MAX = localToWorldMatrix;
constexpr int TransformTypes_ARRAYSIZE = TransformTypes_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransformTypes_descriptor();
template<typename T>
inline const std::string& TransformTypes_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransformTypes>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransformTypes_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransformTypes_descriptor(), enum_t_value);
}
inline bool TransformTypes_Parse(
    const std::string& name, TransformTypes* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransformTypes>(
    TransformTypes_descriptor(), name, value);
}
enum PrimitiveType : int {
  Sphere = 0,
  Capsule = 1,
  Cylinder = 2,
  Cube = 3,
  Plane = 4,
  Quad = 5,
  PrimitiveType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PrimitiveType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PrimitiveType_IsValid(int value);
constexpr PrimitiveType PrimitiveType_MIN = Sphere;
constexpr PrimitiveType PrimitiveType_MAX = Quad;
constexpr int PrimitiveType_ARRAYSIZE = PrimitiveType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrimitiveType_descriptor();
template<typename T>
inline const std::string& PrimitiveType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrimitiveType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrimitiveType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PrimitiveType_descriptor(), enum_t_value);
}
inline bool PrimitiveType_Parse(
    const std::string& name, PrimitiveType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrimitiveType>(
    PrimitiveType_descriptor(), name, value);
}
enum TypeCode : int {
  NoCode = 0,
  Object = 1,
  DBNull = 2,
  Boolean = 3,
  Char = 4,
  SByte = 5,
  Byte = 6,
  Int16 = 7,
  UInt16 = 8,
  Int32 = 9,
  UInt32 = 10,
  Int64 = 11,
  UInt64 = 12,
  Single = 13,
  Double = 14,
  Decimal = 15,
  DateTime = 16,
  String = 18,
  TypeCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TypeCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TypeCode_IsValid(int value);
constexpr TypeCode TypeCode_MIN = NoCode;
constexpr TypeCode TypeCode_MAX = String;
constexpr int TypeCode_ARRAYSIZE = TypeCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TypeCode_descriptor();
template<typename T>
inline const std::string& TypeCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TypeCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TypeCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TypeCode_descriptor(), enum_t_value);
}
inline bool TypeCode_Parse(
    const std::string& name, TypeCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TypeCode>(
    TypeCode_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace AR51

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::AR51::GameState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AR51::GameState>() {
  return ::AR51::GameState_descriptor();
}
template <> struct is_proto_enum< ::AR51::LensFacing> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AR51::LensFacing>() {
  return ::AR51::LensFacing_descriptor();
}
template <> struct is_proto_enum< ::AR51::InputType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AR51::InputType>() {
  return ::AR51::InputType_descriptor();
}
template <> struct is_proto_enum< ::AR51::TransformTypes> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AR51::TransformTypes>() {
  return ::AR51::TransformTypes_descriptor();
}
template <> struct is_proto_enum< ::AR51::PrimitiveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AR51::PrimitiveType>() {
  return ::AR51::PrimitiveType_descriptor();
}
template <> struct is_proto_enum< ::AR51::TypeCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AR51::TypeCode>() {
  return ::AR51::TypeCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dgsEnums_2eproto
