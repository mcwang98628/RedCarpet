// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: dgs.proto
#ifndef GRPC_dgs_2eproto__INCLUDED
#define GRPC_dgs_2eproto__INCLUDED

#include "dgs.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class CompletionQueue;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc

namespace AR51 {

// ========================================= Game Service =======================================
class GameService final {
 public:
  static constexpr char const* service_full_name() {
    return "AR51.GameService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status EnterLobby(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncEnterLobby(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncEnterLobbyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncEnterLobby(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncEnterLobbyRaw(context, request, cq));
    }
    virtual ::grpc::Status Start(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncStart(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncStartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncStart(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncStartRaw(context, request, cq));
    }
    // start can only happen after entering lobby
    virtual ::grpc::Status Stop(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncStop(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncStop(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::GameStateReply>> ListenToEvents(::grpc::ClientContext* context, const ::AR51::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::GameStateReply>>(ListenToEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::GameStateReply>> AsyncListenToEvents(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::GameStateReply>>(AsyncListenToEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::GameStateReply>> PrepareAsyncListenToEvents(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::GameStateReply>>(PrepareAsyncListenToEventsRaw(context, request, cq));
    }
    virtual ::grpc::Status GetState(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::GameStateReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GameStateReply>> AsyncGetState(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GameStateReply>>(AsyncGetStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GameStateReply>> PrepareAsyncGetState(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GameStateReply>>(PrepareAsyncGetStateRaw(context, request, cq));
    }
    virtual ::grpc::Status Setup(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::SetupReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SetupReply>> AsyncSetup(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SetupReply>>(AsyncSetupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SetupReply>> PrepareAsyncSetup(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SetupReply>>(PrepareAsyncSetupRaw(context, request, cq));
    }
    virtual ::grpc::Status CancelSetup(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncCancelSetup(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncCancelSetupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncCancelSetup(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncCancelSetupRaw(context, request, cq));
    }
    virtual ::grpc::Status SetPlaceable(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest& request, ::AR51::SetPlaceableReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SetPlaceableReply>> AsyncSetPlaceable(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SetPlaceableReply>>(AsyncSetPlaceableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SetPlaceableReply>> PrepareAsyncSetPlaceable(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SetPlaceableReply>>(PrepareAsyncSetPlaceableRaw(context, request, cq));
    }
    virtual ::grpc::Status SetPlayerName(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetPlayerName(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetPlayerNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetPlayerName(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetPlayerNameRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPlayerName(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::StringMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::StringMessage>> AsyncGetPlayerName(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::StringMessage>>(AsyncGetPlayerNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::StringMessage>> PrepareAsyncGetPlayerName(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::StringMessage>>(PrepareAsyncGetPlayerNameRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void EnterLobby(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EnterLobby(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EnterLobby(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void EnterLobby(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Start(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Start(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Start(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Start(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // start can only happen after entering lobby
      virtual void Stop(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Stop(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListenToEvents(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::GameStateReply>* reactor) = 0;
      virtual void GetState(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GameStateReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GameStateReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetState(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GameStateReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GameStateReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Setup(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::SetupReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Setup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SetupReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Setup(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::SetupReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Setup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SetupReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CancelSetup(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CancelSetup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CancelSetup(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CancelSetup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetPlaceable(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest* request, ::AR51::SetPlaceableReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPlaceable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SetPlaceableReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPlaceable(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest* request, ::AR51::SetPlaceableReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetPlaceable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SetPlaceableReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetPlayerName(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPlayerName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPlayerName(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetPlayerName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetPlayerName(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::StringMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPlayerName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::StringMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPlayerName(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::StringMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetPlayerName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::StringMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncEnterLobbyRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncEnterLobbyRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncStartRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncStartRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncStopRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncStopRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::AR51::GameStateReply>* ListenToEventsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::GameStateReply>* AsyncListenToEventsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::GameStateReply>* PrepareAsyncListenToEventsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GameStateReply>* AsyncGetStateRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GameStateReply>* PrepareAsyncGetStateRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SetupReply>* AsyncSetupRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SetupReply>* PrepareAsyncSetupRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncCancelSetupRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncCancelSetupRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SetPlaceableReply>* AsyncSetPlaceableRaw(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::SetPlaceableReply>* PrepareAsyncSetPlaceableRaw(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetPlayerNameRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetPlayerNameRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::StringMessage>* AsyncGetPlayerNameRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::StringMessage>* PrepareAsyncGetPlayerNameRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status EnterLobby(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncEnterLobby(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncEnterLobbyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncEnterLobby(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncEnterLobbyRaw(context, request, cq));
    }
    ::grpc::Status Start(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncStart(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncStartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncStart(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncStartRaw(context, request, cq));
    }
    ::grpc::Status Stop(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncStop(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncStop(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::AR51::GameStateReply>> ListenToEvents(::grpc::ClientContext* context, const ::AR51::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::GameStateReply>>(ListenToEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::GameStateReply>> AsyncListenToEvents(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::GameStateReply>>(AsyncListenToEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::GameStateReply>> PrepareAsyncListenToEvents(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::GameStateReply>>(PrepareAsyncListenToEventsRaw(context, request, cq));
    }
    ::grpc::Status GetState(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::GameStateReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GameStateReply>> AsyncGetState(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GameStateReply>>(AsyncGetStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GameStateReply>> PrepareAsyncGetState(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GameStateReply>>(PrepareAsyncGetStateRaw(context, request, cq));
    }
    ::grpc::Status Setup(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::SetupReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::SetupReply>> AsyncSetup(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::SetupReply>>(AsyncSetupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::SetupReply>> PrepareAsyncSetup(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::SetupReply>>(PrepareAsyncSetupRaw(context, request, cq));
    }
    ::grpc::Status CancelSetup(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncCancelSetup(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncCancelSetupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncCancelSetup(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncCancelSetupRaw(context, request, cq));
    }
    ::grpc::Status SetPlaceable(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest& request, ::AR51::SetPlaceableReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::SetPlaceableReply>> AsyncSetPlaceable(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::SetPlaceableReply>>(AsyncSetPlaceableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::SetPlaceableReply>> PrepareAsyncSetPlaceable(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::SetPlaceableReply>>(PrepareAsyncSetPlaceableRaw(context, request, cq));
    }
    ::grpc::Status SetPlayerName(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetPlayerName(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetPlayerNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetPlayerName(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetPlayerNameRaw(context, request, cq));
    }
    ::grpc::Status GetPlayerName(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::StringMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::StringMessage>> AsyncGetPlayerName(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::StringMessage>>(AsyncGetPlayerNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::StringMessage>> PrepareAsyncGetPlayerName(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::StringMessage>>(PrepareAsyncGetPlayerNameRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void EnterLobby(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void EnterLobby(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void EnterLobby(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void EnterLobby(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Start(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Start(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Start(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Start(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Stop(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Stop(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListenToEvents(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::GameStateReply>* reactor) override;
      void GetState(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GameStateReply* response, std::function<void(::grpc::Status)>) override;
      void GetState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GameStateReply* response, std::function<void(::grpc::Status)>) override;
      void GetState(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GameStateReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GameStateReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Setup(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::SetupReply* response, std::function<void(::grpc::Status)>) override;
      void Setup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SetupReply* response, std::function<void(::grpc::Status)>) override;
      void Setup(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::SetupReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Setup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SetupReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CancelSetup(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void CancelSetup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void CancelSetup(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CancelSetup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetPlaceable(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest* request, ::AR51::SetPlaceableReply* response, std::function<void(::grpc::Status)>) override;
      void SetPlaceable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SetPlaceableReply* response, std::function<void(::grpc::Status)>) override;
      void SetPlaceable(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest* request, ::AR51::SetPlaceableReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetPlaceable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SetPlaceableReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetPlayerName(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetPlayerName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetPlayerName(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetPlayerName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetPlayerName(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::StringMessage* response, std::function<void(::grpc::Status)>) override;
      void GetPlayerName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::StringMessage* response, std::function<void(::grpc::Status)>) override;
      void GetPlayerName(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::StringMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetPlayerName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::StringMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncEnterLobbyRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncEnterLobbyRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncStartRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncStartRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncStopRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncStopRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::AR51::GameStateReply>* ListenToEventsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) override;
    ::grpc::ClientAsyncReader< ::AR51::GameStateReply>* AsyncListenToEventsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::GameStateReply>* PrepareAsyncListenToEventsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::GameStateReply>* AsyncGetStateRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::GameStateReply>* PrepareAsyncGetStateRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::SetupReply>* AsyncSetupRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::SetupReply>* PrepareAsyncSetupRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncCancelSetupRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncCancelSetupRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::SetPlaceableReply>* AsyncSetPlaceableRaw(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::SetPlaceableReply>* PrepareAsyncSetPlaceableRaw(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetPlayerNameRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetPlayerNameRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::StringMessage>* AsyncGetPlayerNameRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::StringMessage>* PrepareAsyncGetPlayerNameRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_EnterLobby_;
    const ::grpc::internal::RpcMethod rpcmethod_Start_;
    const ::grpc::internal::RpcMethod rpcmethod_Stop_;
    const ::grpc::internal::RpcMethod rpcmethod_ListenToEvents_;
    const ::grpc::internal::RpcMethod rpcmethod_GetState_;
    const ::grpc::internal::RpcMethod rpcmethod_Setup_;
    const ::grpc::internal::RpcMethod rpcmethod_CancelSetup_;
    const ::grpc::internal::RpcMethod rpcmethod_SetPlaceable_;
    const ::grpc::internal::RpcMethod rpcmethod_SetPlayerName_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPlayerName_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status EnterLobby(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response);
    virtual ::grpc::Status Start(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response);
    // start can only happen after entering lobby
    virtual ::grpc::Status Stop(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response);
    virtual ::grpc::Status ListenToEvents(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::GameStateReply>* writer);
    virtual ::grpc::Status GetState(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GameStateReply* response);
    virtual ::grpc::Status Setup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SetupReply* response);
    virtual ::grpc::Status CancelSetup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response);
    virtual ::grpc::Status SetPlaceable(::grpc::ServerContext* context, const ::AR51::SetPlaceableRequest* request, ::AR51::SetPlaceableReply* response);
    virtual ::grpc::Status SetPlayerName(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response);
    virtual ::grpc::Status GetPlayerName(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::StringMessage* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_EnterLobby : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_EnterLobby() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_EnterLobby() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnterLobby(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnterLobby(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Start() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Start(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStart(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Stop() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStop(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListenToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListenToEvents() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ListenToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListenToEvents(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::GameStateReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListenToEvents(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncWriter< ::AR51::GameStateReply>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetState() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetState(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GameStateReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetState(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::GameStateReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Setup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Setup() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_Setup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Setup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SetupReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetup(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::SetupReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CancelSetup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CancelSetup() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_CancelSetup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelSetup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelSetup(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPlaceable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetPlaceable() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_SetPlaceable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlaceable(::grpc::ServerContext* context, const ::AR51::SetPlaceableRequest* request, ::AR51::SetPlaceableReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPlaceable(::grpc::ServerContext* context, ::AR51::SetPlaceableRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::SetPlaceableReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPlayerName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetPlayerName() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_SetPlayerName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayerName(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPlayerName(::grpc::ServerContext* context, ::AR51::StringMessage* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPlayerName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetPlayerName() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetPlayerName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerName(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::StringMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayerName(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::StringMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_EnterLobby<WithAsyncMethod_Start<WithAsyncMethod_Stop<WithAsyncMethod_ListenToEvents<WithAsyncMethod_GetState<WithAsyncMethod_Setup<WithAsyncMethod_CancelSetup<WithAsyncMethod_SetPlaceable<WithAsyncMethod_SetPlayerName<WithAsyncMethod_GetPlayerName<Service > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EnterLobby : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_EnterLobby() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->EnterLobby(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_EnterLobby(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EnterLobby() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnterLobby(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void EnterLobby(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Start() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Start(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Start(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Start(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Start(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Stop() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Stop(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Stop(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Stop(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListenToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListenToEvents() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::Empty, ::AR51::GameStateReply>(
          [this] { return this->ListenToEvents(); }));
    }
    ~ExperimentalWithCallbackMethod_ListenToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListenToEvents(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::GameStateReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::Empty, ::AR51::GameStateReply>* ListenToEvents() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::Empty, ::AR51::GameStateReply>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetState() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::GameStateReply>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::GameStateReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetState(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetState(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::GameStateReply>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::GameStateReply>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetState(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GameStateReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetState(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GameStateReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Setup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Setup() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::SetupReply>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::SetupReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Setup(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Setup(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::SetupReply>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::SetupReply>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Setup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Setup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SetupReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Setup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SetupReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CancelSetup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CancelSetup() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CancelSetup(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CancelSetup(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CancelSetup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelSetup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CancelSetup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetPlaceable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetPlaceable() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetPlaceableRequest, ::AR51::SetPlaceableReply>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::SetPlaceableRequest* request,
                 ::AR51::SetPlaceableReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetPlaceable(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetPlaceable(
        ::grpc::experimental::MessageAllocator< ::AR51::SetPlaceableRequest, ::AR51::SetPlaceableReply>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetPlaceableRequest, ::AR51::SetPlaceableReply>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetPlaceable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlaceable(::grpc::ServerContext* context, const ::AR51::SetPlaceableRequest* request, ::AR51::SetPlaceableReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetPlaceable(::grpc::ServerContext* context, const ::AR51::SetPlaceableRequest* request, ::AR51::SetPlaceableReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetPlayerName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetPlayerName() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::StringMessage, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::StringMessage* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetPlayerName(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetPlayerName(
        ::grpc::experimental::MessageAllocator< ::AR51::StringMessage, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::StringMessage, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(8))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetPlayerName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayerName(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetPlayerName(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetPlayerName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetPlayerName() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::StringMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::StringMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetPlayerName(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetPlayerName(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::StringMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::StringMessage>*>(
          ::grpc::Service::experimental().GetHandler(9))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetPlayerName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerName(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::StringMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetPlayerName(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::StringMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_EnterLobby<ExperimentalWithCallbackMethod_Start<ExperimentalWithCallbackMethod_Stop<ExperimentalWithCallbackMethod_ListenToEvents<ExperimentalWithCallbackMethod_GetState<ExperimentalWithCallbackMethod_Setup<ExperimentalWithCallbackMethod_CancelSetup<ExperimentalWithCallbackMethod_SetPlaceable<ExperimentalWithCallbackMethod_SetPlayerName<ExperimentalWithCallbackMethod_GetPlayerName<Service > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_EnterLobby : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_EnterLobby() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_EnterLobby() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnterLobby(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Start() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Start(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Stop() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListenToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListenToEvents() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ListenToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListenToEvents(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::GameStateReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetState() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetState(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GameStateReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Setup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Setup() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_Setup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Setup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SetupReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CancelSetup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CancelSetup() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_CancelSetup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelSetup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetPlaceable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetPlaceable() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_SetPlaceable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlaceable(::grpc::ServerContext* context, const ::AR51::SetPlaceableRequest* request, ::AR51::SetPlaceableReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetPlayerName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetPlayerName() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_SetPlayerName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayerName(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPlayerName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetPlayerName() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetPlayerName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerName(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::StringMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_EnterLobby : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_EnterLobby() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_EnterLobby() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnterLobby(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnterLobby(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Start() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Start(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStart(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Stop() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStop(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListenToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListenToEvents() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ListenToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListenToEvents(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::GameStateReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListenToEvents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetState() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetState(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GameStateReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Setup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Setup() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_Setup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Setup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SetupReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CancelSetup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CancelSetup() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_CancelSetup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelSetup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelSetup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPlaceable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetPlaceable() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_SetPlaceable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlaceable(::grpc::ServerContext* context, const ::AR51::SetPlaceableRequest* request, ::AR51::SetPlaceableReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPlaceable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPlayerName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetPlayerName() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_SetPlayerName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayerName(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPlayerName(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPlayerName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetPlayerName() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetPlayerName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerName(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::StringMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayerName(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EnterLobby : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_EnterLobby() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->EnterLobby(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_EnterLobby() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnterLobby(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void EnterLobby(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Start() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Start(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Start(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Start(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Stop() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Stop(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Stop(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListenToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListenToEvents() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->ListenToEvents(); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListenToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListenToEvents(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::GameStateReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* ListenToEvents() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetState() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetState(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetState(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GameStateReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetState(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Setup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Setup() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Setup(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Setup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Setup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SetupReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Setup(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CancelSetup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CancelSetup() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CancelSetup(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CancelSetup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelSetup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CancelSetup(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetPlaceable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetPlaceable() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetPlaceable(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetPlaceable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlaceable(::grpc::ServerContext* context, const ::AR51::SetPlaceableRequest* request, ::AR51::SetPlaceableReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetPlaceable(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetPlayerName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetPlayerName() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetPlayerName(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetPlayerName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayerName(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetPlayerName(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetPlayerName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetPlayerName() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetPlayerName(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetPlayerName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerName(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::StringMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetPlayerName(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EnterLobby : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_EnterLobby() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_EnterLobby<BaseClass>::StreamedEnterLobby, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_EnterLobby() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EnterLobby(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEnterLobby(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Start() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_Start<BaseClass>::StreamedStart, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Start(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStart(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Stop() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_Stop<BaseClass>::StreamedStop, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Stop(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStop(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetState() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::GameStateReply>(std::bind(&WithStreamedUnaryMethod_GetState<BaseClass>::StreamedGetState, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetState(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GameStateReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::GameStateReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Setup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Setup() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::SetupReply>(std::bind(&WithStreamedUnaryMethod_Setup<BaseClass>::StreamedSetup, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Setup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Setup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SetupReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::SetupReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CancelSetup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CancelSetup() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_CancelSetup<BaseClass>::StreamedCancelSetup, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CancelSetup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CancelSetup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCancelSetup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPlaceable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetPlaceable() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::SetPlaceableRequest, ::AR51::SetPlaceableReply>(std::bind(&WithStreamedUnaryMethod_SetPlaceable<BaseClass>::StreamedSetPlaceable, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetPlaceable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPlaceable(::grpc::ServerContext* context, const ::AR51::SetPlaceableRequest* request, ::AR51::SetPlaceableReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPlaceable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::SetPlaceableRequest,::AR51::SetPlaceableReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPlayerName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetPlayerName() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::StringMessage, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetPlayerName<BaseClass>::StreamedSetPlayerName, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetPlayerName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPlayerName(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPlayerName(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::StringMessage,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPlayerName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetPlayerName() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::StringMessage>(std::bind(&WithStreamedUnaryMethod_GetPlayerName<BaseClass>::StreamedGetPlayerName, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetPlayerName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPlayerName(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::StringMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPlayerName(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::StringMessage>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_EnterLobby<WithStreamedUnaryMethod_Start<WithStreamedUnaryMethod_Stop<WithStreamedUnaryMethod_GetState<WithStreamedUnaryMethod_Setup<WithStreamedUnaryMethod_CancelSetup<WithStreamedUnaryMethod_SetPlaceable<WithStreamedUnaryMethod_SetPlayerName<WithStreamedUnaryMethod_GetPlayerName<Service > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_ListenToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_ListenToEvents() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::Empty, ::AR51::GameStateReply>(std::bind(&WithSplitStreamingMethod_ListenToEvents<BaseClass>::StreamedListenToEvents, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_ListenToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListenToEvents(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::GameStateReply>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedListenToEvents(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::Empty,::AR51::GameStateReply>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_ListenToEvents<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_EnterLobby<WithStreamedUnaryMethod_Start<WithStreamedUnaryMethod_Stop<WithSplitStreamingMethod_ListenToEvents<WithStreamedUnaryMethod_GetState<WithStreamedUnaryMethod_Setup<WithStreamedUnaryMethod_CancelSetup<WithStreamedUnaryMethod_SetPlaceable<WithStreamedUnaryMethod_SetPlayerName<WithStreamedUnaryMethod_GetPlayerName<Service > > > > > > > > > > StreamedService;
};

// ========================================= Camera Service =======================================
class CameraService final {
 public:
  static constexpr char const* service_full_name() {
    return "AR51.CameraService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::CameraFeedResponse>> StartStreaming(::grpc::ClientContext* context, const ::AR51::CameraFeedRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::CameraFeedResponse>>(StartStreamingRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CameraFeedResponse>> AsyncStartStreaming(::grpc::ClientContext* context, const ::AR51::CameraFeedRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CameraFeedResponse>>(AsyncStartStreamingRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CameraFeedResponse>> PrepareAsyncStartStreaming(::grpc::ClientContext* context, const ::AR51::CameraFeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::CameraFeedResponse>>(PrepareAsyncStartStreamingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::BytesMessage>> StartRecorderStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::BytesMessage>>(StartRecorderStreamingRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::BytesMessage>> AsyncStartRecorderStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::BytesMessage>>(AsyncStartRecorderStreamingRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::BytesMessage>> PrepareAsyncStartRecorderStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::BytesMessage>>(PrepareAsyncStartRecorderStreamingRaw(context, request, cq));
    }
    virtual ::grpc::Status GetIsStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> AsyncGetIsStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(AsyncGetIsStreamingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> PrepareAsyncGetIsStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(PrepareAsyncGetIsStreamingRaw(context, request, cq));
    }
    virtual ::grpc::Status GetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> AsyncGetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(AsyncGetHologramsEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> PrepareAsyncGetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(PrepareAsyncGetHologramsEnabledRaw(context, request, cq));
    }
    virtual ::grpc::Status SetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetHologramsEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetHologramsEnabledRaw(context, request, cq));
    }
    // Preview size
    virtual ::grpc::Status GetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Int32Message* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>> AsyncGetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>>(AsyncGetPreviewWidthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>> PrepareAsyncGetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>>(PrepareAsyncGetPreviewWidthRaw(context, request, cq));
    }
    virtual ::grpc::Status SetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetPreviewWidthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetPreviewWidthRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Int32Message* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>> AsyncGetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>>(AsyncGetPreviewHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>> PrepareAsyncGetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>>(PrepareAsyncGetPreviewHeightRaw(context, request, cq));
    }
    virtual ::grpc::Status SetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetPreviewHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetPreviewHeightRaw(context, request, cq));
    }
    // Exposure
    virtual ::grpc::Status GetExposureLock(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> AsyncGetExposureLock(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(AsyncGetExposureLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> PrepareAsyncGetExposureLock(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(PrepareAsyncGetExposureLockRaw(context, request, cq));
    }
    virtual ::grpc::Status SetExposureLock(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetExposureLock(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetExposureLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetExposureLock(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetExposureLockRaw(context, request, cq));
    }
    virtual ::grpc::Status GetExposureBiasMin(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Float32Message* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>> AsyncGetExposureBiasMin(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>>(AsyncGetExposureBiasMinRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>> PrepareAsyncGetExposureBiasMin(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>>(PrepareAsyncGetExposureBiasMinRaw(context, request, cq));
    }
    virtual ::grpc::Status GetExposureBiasMax(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Float32Message* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>> AsyncGetExposureBiasMax(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>>(AsyncGetExposureBiasMaxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>> PrepareAsyncGetExposureBiasMax(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>>(PrepareAsyncGetExposureBiasMaxRaw(context, request, cq));
    }
    virtual ::grpc::Status GetExposureBias(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Float32Message* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>> AsyncGetExposureBias(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>>(AsyncGetExposureBiasRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>> PrepareAsyncGetExposureBias(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>>(PrepareAsyncGetExposureBiasRaw(context, request, cq));
    }
    virtual ::grpc::Status SetExposureBias(::grpc::ClientContext* context, const ::AR51::Float32Message& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetExposureBias(::grpc::ClientContext* context, const ::AR51::Float32Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetExposureBiasRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetExposureBias(::grpc::ClientContext* context, const ::AR51::Float32Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetExposureBiasRaw(context, request, cq));
    }
    // Focus
    virtual ::grpc::Status GetAutoFocus(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> AsyncGetAutoFocus(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(AsyncGetAutoFocusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> PrepareAsyncGetAutoFocus(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(PrepareAsyncGetAutoFocusRaw(context, request, cq));
    }
    virtual ::grpc::Status SetAutoFocus(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetAutoFocus(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetAutoFocusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetAutoFocus(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetAutoFocusRaw(context, request, cq));
    }
    // Video Recorder
    virtual ::grpc::Status GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> AsyncGetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(AsyncGetIsRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> PrepareAsyncGetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(PrepareAsyncGetIsRecordingRaw(context, request, cq));
    }
    virtual ::grpc::Status GetIsRecordingReady(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> AsyncGetIsRecordingReady(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(AsyncGetIsRecordingReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> PrepareAsyncGetIsRecordingReady(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(PrepareAsyncGetIsRecordingReadyRaw(context, request, cq));
    }
    virtual ::grpc::Status GetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> AsyncGetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(AsyncGetAutoExposureEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> PrepareAsyncGetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(PrepareAsyncGetAutoExposureEnabledRaw(context, request, cq));
    }
    virtual ::grpc::Status SetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetAutoExposureEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetAutoExposureEnabledRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Int64Message* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int64Message>> AsyncGetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int64Message>>(AsyncGetSensorExposureTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int64Message>> PrepareAsyncGetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int64Message>>(PrepareAsyncGetSensorExposureTimeRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Int64Message& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Int64Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetSensorExposureTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Int64Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetSensorExposureTimeRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Int32Message* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>> AsyncGetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>>(AsyncGetSensorSensitivityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>> PrepareAsyncGetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>>(PrepareAsyncGetSensorSensitivityRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetSensorSensitivityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetSensorSensitivityRaw(context, request, cq));
    }
    // recording methods
    virtual ::grpc::Status GetVideoRecordingSetting(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::GetVideoRecordingSettingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetVideoRecordingSettingResponse>> AsyncGetVideoRecordingSetting(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetVideoRecordingSettingResponse>>(AsyncGetVideoRecordingSettingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetVideoRecordingSettingResponse>> PrepareAsyncGetVideoRecordingSetting(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetVideoRecordingSettingResponse>>(PrepareAsyncGetVideoRecordingSettingRaw(context, request, cq));
    }
    virtual ::grpc::Status StartRecording(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest& request, ::AR51::StartRecordingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::StartRecordingResponse>> AsyncStartRecording(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::StartRecordingResponse>>(AsyncStartRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::StartRecordingResponse>> PrepareAsyncStartRecording(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::StartRecordingResponse>>(PrepareAsyncStartRecordingRaw(context, request, cq));
    }
    virtual ::grpc::Status StartMediaRecoder(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncStartMediaRecoder(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncStartMediaRecoderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncStartMediaRecoder(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncStartMediaRecoderRaw(context, request, cq));
    }
    virtual ::grpc::Status StopRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncStopRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncStopRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncStopRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncStopRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::BytesMessage>> DownloadVideo(::grpc::ClientContext* context, const ::AR51::DownloadVideoRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::BytesMessage>>(DownloadVideoRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::BytesMessage>> AsyncDownloadVideo(::grpc::ClientContext* context, const ::AR51::DownloadVideoRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::BytesMessage>>(AsyncDownloadVideoRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::BytesMessage>> PrepareAsyncDownloadVideo(::grpc::ClientContext* context, const ::AR51::DownloadVideoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::BytesMessage>>(PrepareAsyncDownloadVideoRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteVideo(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncDeleteVideo(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncDeleteVideoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncDeleteVideo(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncDeleteVideoRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteAllVideos(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncDeleteAllVideos(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncDeleteAllVideosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncDeleteAllVideos(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncDeleteAllVideosRaw(context, request, cq));
    }
    virtual ::grpc::Status GetAllVideoFiles(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::GetAllVideoFilesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetAllVideoFilesResponse>> AsyncGetAllVideoFiles(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetAllVideoFilesResponse>>(AsyncGetAllVideoFilesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetAllVideoFilesResponse>> PrepareAsyncGetAllVideoFiles(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetAllVideoFilesResponse>>(PrepareAsyncGetAllVideoFilesRaw(context, request, cq));
    }
    // Camera Characteristics
    virtual ::grpc::Status GetCameraCharacteristics(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest& request, ::AR51::BytesMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BytesMessage>> AsyncGetCameraCharacteristics(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BytesMessage>>(AsyncGetCameraCharacteristicsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BytesMessage>> PrepareAsyncGetCameraCharacteristics(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BytesMessage>>(PrepareAsyncGetCameraCharacteristicsRaw(context, request, cq));
    }
    virtual ::grpc::Status GetRecorderField(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest& request, ::AR51::BytesMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BytesMessage>> AsyncGetRecorderField(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BytesMessage>>(AsyncGetRecorderFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BytesMessage>> PrepareAsyncGetRecorderField(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BytesMessage>>(PrepareAsyncGetRecorderFieldRaw(context, request, cq));
    }
    virtual ::grpc::Status SetRecorderField(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetRecorderField(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetRecorderFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetRecorderField(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetRecorderFieldRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void StartStreaming(::grpc::ClientContext* context, ::AR51::CameraFeedRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::CameraFeedResponse>* reactor) = 0;
      virtual void StartRecorderStreaming(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::BytesMessage>* reactor) = 0;
      virtual void GetIsStreaming(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIsStreaming(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIsStreaming(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetIsStreaming(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetHologramsEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetHologramsEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetHologramsEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetHologramsEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Preview size
      virtual void GetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPreviewWidth(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetPreviewWidth(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPreviewWidth(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetPreviewWidth(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPreviewHeight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetPreviewHeight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPreviewHeight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetPreviewHeight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Exposure
      virtual void GetExposureLock(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetExposureLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetExposureLock(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetExposureLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetExposureLock(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetExposureLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetExposureLock(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetExposureLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetExposureBiasMin(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetExposureBiasMin(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetExposureBiasMin(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetExposureBiasMin(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetExposureBiasMax(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetExposureBiasMax(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetExposureBiasMax(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetExposureBiasMax(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetExposureBias(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetExposureBias(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetExposureBias(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetExposureBias(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetExposureBias(::grpc::ClientContext* context, const ::AR51::Float32Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetExposureBias(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetExposureBias(::grpc::ClientContext* context, const ::AR51::Float32Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetExposureBias(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Focus
      virtual void GetAutoFocus(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAutoFocus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAutoFocus(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAutoFocus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetAutoFocus(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAutoFocus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAutoFocus(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetAutoFocus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Video Recorder
      virtual void GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIsRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetIsRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetIsRecordingReady(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIsRecordingReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIsRecordingReady(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetIsRecordingReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAutoExposureEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAutoExposureEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAutoExposureEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetAutoExposureEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int64Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSensorExposureTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int64Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetSensorExposureTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Int64Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSensorExposureTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Int64Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetSensorExposureTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSensorSensitivity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetSensorSensitivity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSensorSensitivity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetSensorSensitivity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // recording methods
      virtual void GetVideoRecordingSetting(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetVideoRecordingSettingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVideoRecordingSetting(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetVideoRecordingSettingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVideoRecordingSetting(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetVideoRecordingSettingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetVideoRecordingSetting(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetVideoRecordingSettingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StartRecording(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest* request, ::AR51::StartRecordingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::StartRecordingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartRecording(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest* request, ::AR51::StartRecordingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::StartRecordingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StartMediaRecoder(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartMediaRecoder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartMediaRecoder(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StartMediaRecoder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StopRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DownloadVideo(::grpc::ClientContext* context, ::AR51::DownloadVideoRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::BytesMessage>* reactor) = 0;
      virtual void DeleteVideo(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteVideo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteVideo(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteVideo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteAllVideos(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteAllVideos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteAllVideos(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteAllVideos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAllVideoFiles(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetAllVideoFilesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAllVideoFiles(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetAllVideoFilesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAllVideoFiles(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetAllVideoFilesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAllVideoFiles(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetAllVideoFilesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Camera Characteristics
      virtual void GetCameraCharacteristics(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest* request, ::AR51::BytesMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCameraCharacteristics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BytesMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCameraCharacteristics(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest* request, ::AR51::BytesMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetCameraCharacteristics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BytesMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetRecorderField(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest* request, ::AR51::BytesMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRecorderField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BytesMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRecorderField(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest* request, ::AR51::BytesMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetRecorderField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BytesMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetRecorderField(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRecorderField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRecorderField(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetRecorderField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientReaderInterface< ::AR51::CameraFeedResponse>* StartStreamingRaw(::grpc::ClientContext* context, const ::AR51::CameraFeedRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::CameraFeedResponse>* AsyncStartStreamingRaw(::grpc::ClientContext* context, const ::AR51::CameraFeedRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::CameraFeedResponse>* PrepareAsyncStartStreamingRaw(::grpc::ClientContext* context, const ::AR51::CameraFeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::AR51::BytesMessage>* StartRecorderStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::BytesMessage>* AsyncStartRecorderStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::BytesMessage>* PrepareAsyncStartRecorderStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* AsyncGetIsStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* PrepareAsyncGetIsStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* AsyncGetHologramsEnabledRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* PrepareAsyncGetHologramsEnabledRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetHologramsEnabledRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetHologramsEnabledRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>* AsyncGetPreviewWidthRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>* PrepareAsyncGetPreviewWidthRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetPreviewWidthRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetPreviewWidthRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>* AsyncGetPreviewHeightRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>* PrepareAsyncGetPreviewHeightRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetPreviewHeightRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetPreviewHeightRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* AsyncGetExposureLockRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* PrepareAsyncGetExposureLockRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetExposureLockRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetExposureLockRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>* AsyncGetExposureBiasMinRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>* PrepareAsyncGetExposureBiasMinRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>* AsyncGetExposureBiasMaxRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>* PrepareAsyncGetExposureBiasMaxRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>* AsyncGetExposureBiasRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float32Message>* PrepareAsyncGetExposureBiasRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetExposureBiasRaw(::grpc::ClientContext* context, const ::AR51::Float32Message& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetExposureBiasRaw(::grpc::ClientContext* context, const ::AR51::Float32Message& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* AsyncGetAutoFocusRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* PrepareAsyncGetAutoFocusRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetAutoFocusRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetAutoFocusRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* AsyncGetIsRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* PrepareAsyncGetIsRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* AsyncGetIsRecordingReadyRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* PrepareAsyncGetIsRecordingReadyRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* AsyncGetAutoExposureEnabledRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* PrepareAsyncGetAutoExposureEnabledRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetAutoExposureEnabledRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetAutoExposureEnabledRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int64Message>* AsyncGetSensorExposureTimeRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int64Message>* PrepareAsyncGetSensorExposureTimeRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetSensorExposureTimeRaw(::grpc::ClientContext* context, const ::AR51::Int64Message& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetSensorExposureTimeRaw(::grpc::ClientContext* context, const ::AR51::Int64Message& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>* AsyncGetSensorSensitivityRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Int32Message>* PrepareAsyncGetSensorSensitivityRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetSensorSensitivityRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetSensorSensitivityRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetVideoRecordingSettingResponse>* AsyncGetVideoRecordingSettingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetVideoRecordingSettingResponse>* PrepareAsyncGetVideoRecordingSettingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::StartRecordingResponse>* AsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::StartRecordingResponse>* PrepareAsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncStartMediaRecoderRaw(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncStartMediaRecoderRaw(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::AR51::BytesMessage>* DownloadVideoRaw(::grpc::ClientContext* context, const ::AR51::DownloadVideoRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::BytesMessage>* AsyncDownloadVideoRaw(::grpc::ClientContext* context, const ::AR51::DownloadVideoRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::BytesMessage>* PrepareAsyncDownloadVideoRaw(::grpc::ClientContext* context, const ::AR51::DownloadVideoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncDeleteVideoRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncDeleteVideoRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncDeleteAllVideosRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncDeleteAllVideosRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetAllVideoFilesResponse>* AsyncGetAllVideoFilesRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetAllVideoFilesResponse>* PrepareAsyncGetAllVideoFilesRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BytesMessage>* AsyncGetCameraCharacteristicsRaw(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BytesMessage>* PrepareAsyncGetCameraCharacteristicsRaw(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BytesMessage>* AsyncGetRecorderFieldRaw(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BytesMessage>* PrepareAsyncGetRecorderFieldRaw(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetRecorderFieldRaw(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetRecorderFieldRaw(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    std::unique_ptr< ::grpc::ClientReader< ::AR51::CameraFeedResponse>> StartStreaming(::grpc::ClientContext* context, const ::AR51::CameraFeedRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::CameraFeedResponse>>(StartStreamingRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CameraFeedResponse>> AsyncStartStreaming(::grpc::ClientContext* context, const ::AR51::CameraFeedRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CameraFeedResponse>>(AsyncStartStreamingRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CameraFeedResponse>> PrepareAsyncStartStreaming(::grpc::ClientContext* context, const ::AR51::CameraFeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::CameraFeedResponse>>(PrepareAsyncStartStreamingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::AR51::BytesMessage>> StartRecorderStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::BytesMessage>>(StartRecorderStreamingRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::BytesMessage>> AsyncStartRecorderStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::BytesMessage>>(AsyncStartRecorderStreamingRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::BytesMessage>> PrepareAsyncStartRecorderStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::BytesMessage>>(PrepareAsyncStartRecorderStreamingRaw(context, request, cq));
    }
    ::grpc::Status GetIsStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> AsyncGetIsStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(AsyncGetIsStreamingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> PrepareAsyncGetIsStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(PrepareAsyncGetIsStreamingRaw(context, request, cq));
    }
    ::grpc::Status GetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> AsyncGetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(AsyncGetHologramsEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> PrepareAsyncGetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(PrepareAsyncGetHologramsEnabledRaw(context, request, cq));
    }
    ::grpc::Status SetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetHologramsEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetHologramsEnabledRaw(context, request, cq));
    }
    ::grpc::Status GetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Int32Message* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>> AsyncGetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>>(AsyncGetPreviewWidthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>> PrepareAsyncGetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>>(PrepareAsyncGetPreviewWidthRaw(context, request, cq));
    }
    ::grpc::Status SetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetPreviewWidthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetPreviewWidthRaw(context, request, cq));
    }
    ::grpc::Status GetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Int32Message* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>> AsyncGetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>>(AsyncGetPreviewHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>> PrepareAsyncGetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>>(PrepareAsyncGetPreviewHeightRaw(context, request, cq));
    }
    ::grpc::Status SetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetPreviewHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetPreviewHeightRaw(context, request, cq));
    }
    ::grpc::Status GetExposureLock(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> AsyncGetExposureLock(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(AsyncGetExposureLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> PrepareAsyncGetExposureLock(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(PrepareAsyncGetExposureLockRaw(context, request, cq));
    }
    ::grpc::Status SetExposureLock(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetExposureLock(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetExposureLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetExposureLock(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetExposureLockRaw(context, request, cq));
    }
    ::grpc::Status GetExposureBiasMin(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Float32Message* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>> AsyncGetExposureBiasMin(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>>(AsyncGetExposureBiasMinRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>> PrepareAsyncGetExposureBiasMin(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>>(PrepareAsyncGetExposureBiasMinRaw(context, request, cq));
    }
    ::grpc::Status GetExposureBiasMax(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Float32Message* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>> AsyncGetExposureBiasMax(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>>(AsyncGetExposureBiasMaxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>> PrepareAsyncGetExposureBiasMax(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>>(PrepareAsyncGetExposureBiasMaxRaw(context, request, cq));
    }
    ::grpc::Status GetExposureBias(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Float32Message* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>> AsyncGetExposureBias(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>>(AsyncGetExposureBiasRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>> PrepareAsyncGetExposureBias(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>>(PrepareAsyncGetExposureBiasRaw(context, request, cq));
    }
    ::grpc::Status SetExposureBias(::grpc::ClientContext* context, const ::AR51::Float32Message& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetExposureBias(::grpc::ClientContext* context, const ::AR51::Float32Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetExposureBiasRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetExposureBias(::grpc::ClientContext* context, const ::AR51::Float32Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetExposureBiasRaw(context, request, cq));
    }
    ::grpc::Status GetAutoFocus(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> AsyncGetAutoFocus(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(AsyncGetAutoFocusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> PrepareAsyncGetAutoFocus(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(PrepareAsyncGetAutoFocusRaw(context, request, cq));
    }
    ::grpc::Status SetAutoFocus(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetAutoFocus(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetAutoFocusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetAutoFocus(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetAutoFocusRaw(context, request, cq));
    }
    ::grpc::Status GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> AsyncGetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(AsyncGetIsRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> PrepareAsyncGetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(PrepareAsyncGetIsRecordingRaw(context, request, cq));
    }
    ::grpc::Status GetIsRecordingReady(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> AsyncGetIsRecordingReady(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(AsyncGetIsRecordingReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> PrepareAsyncGetIsRecordingReady(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(PrepareAsyncGetIsRecordingReadyRaw(context, request, cq));
    }
    ::grpc::Status GetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> AsyncGetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(AsyncGetAutoExposureEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> PrepareAsyncGetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(PrepareAsyncGetAutoExposureEnabledRaw(context, request, cq));
    }
    ::grpc::Status SetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetAutoExposureEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetAutoExposureEnabledRaw(context, request, cq));
    }
    ::grpc::Status GetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Int64Message* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Int64Message>> AsyncGetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Int64Message>>(AsyncGetSensorExposureTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Int64Message>> PrepareAsyncGetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Int64Message>>(PrepareAsyncGetSensorExposureTimeRaw(context, request, cq));
    }
    ::grpc::Status SetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Int64Message& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Int64Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetSensorExposureTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Int64Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetSensorExposureTimeRaw(context, request, cq));
    }
    ::grpc::Status GetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Int32Message* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>> AsyncGetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>>(AsyncGetSensorSensitivityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>> PrepareAsyncGetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>>(PrepareAsyncGetSensorSensitivityRaw(context, request, cq));
    }
    ::grpc::Status SetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetSensorSensitivityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetSensorSensitivityRaw(context, request, cq));
    }
    ::grpc::Status GetVideoRecordingSetting(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::GetVideoRecordingSettingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetVideoRecordingSettingResponse>> AsyncGetVideoRecordingSetting(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetVideoRecordingSettingResponse>>(AsyncGetVideoRecordingSettingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetVideoRecordingSettingResponse>> PrepareAsyncGetVideoRecordingSetting(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetVideoRecordingSettingResponse>>(PrepareAsyncGetVideoRecordingSettingRaw(context, request, cq));
    }
    ::grpc::Status StartRecording(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest& request, ::AR51::StartRecordingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::StartRecordingResponse>> AsyncStartRecording(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::StartRecordingResponse>>(AsyncStartRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::StartRecordingResponse>> PrepareAsyncStartRecording(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::StartRecordingResponse>>(PrepareAsyncStartRecordingRaw(context, request, cq));
    }
    ::grpc::Status StartMediaRecoder(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncStartMediaRecoder(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncStartMediaRecoderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncStartMediaRecoder(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncStartMediaRecoderRaw(context, request, cq));
    }
    ::grpc::Status StopRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncStopRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncStopRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncStopRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncStopRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::AR51::BytesMessage>> DownloadVideo(::grpc::ClientContext* context, const ::AR51::DownloadVideoRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::BytesMessage>>(DownloadVideoRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::BytesMessage>> AsyncDownloadVideo(::grpc::ClientContext* context, const ::AR51::DownloadVideoRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::BytesMessage>>(AsyncDownloadVideoRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::BytesMessage>> PrepareAsyncDownloadVideo(::grpc::ClientContext* context, const ::AR51::DownloadVideoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::BytesMessage>>(PrepareAsyncDownloadVideoRaw(context, request, cq));
    }
    ::grpc::Status DeleteVideo(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncDeleteVideo(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncDeleteVideoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncDeleteVideo(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncDeleteVideoRaw(context, request, cq));
    }
    ::grpc::Status DeleteAllVideos(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncDeleteAllVideos(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncDeleteAllVideosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncDeleteAllVideos(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncDeleteAllVideosRaw(context, request, cq));
    }
    ::grpc::Status GetAllVideoFiles(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::GetAllVideoFilesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetAllVideoFilesResponse>> AsyncGetAllVideoFiles(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetAllVideoFilesResponse>>(AsyncGetAllVideoFilesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetAllVideoFilesResponse>> PrepareAsyncGetAllVideoFiles(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetAllVideoFilesResponse>>(PrepareAsyncGetAllVideoFilesRaw(context, request, cq));
    }
    ::grpc::Status GetCameraCharacteristics(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest& request, ::AR51::BytesMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BytesMessage>> AsyncGetCameraCharacteristics(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BytesMessage>>(AsyncGetCameraCharacteristicsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BytesMessage>> PrepareAsyncGetCameraCharacteristics(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BytesMessage>>(PrepareAsyncGetCameraCharacteristicsRaw(context, request, cq));
    }
    ::grpc::Status GetRecorderField(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest& request, ::AR51::BytesMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BytesMessage>> AsyncGetRecorderField(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BytesMessage>>(AsyncGetRecorderFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BytesMessage>> PrepareAsyncGetRecorderField(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BytesMessage>>(PrepareAsyncGetRecorderFieldRaw(context, request, cq));
    }
    ::grpc::Status SetRecorderField(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetRecorderField(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetRecorderFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetRecorderField(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetRecorderFieldRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void StartStreaming(::grpc::ClientContext* context, ::AR51::CameraFeedRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::CameraFeedResponse>* reactor) override;
      void StartRecorderStreaming(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::BytesMessage>* reactor) override;
      void GetIsStreaming(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetIsStreaming(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetIsStreaming(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetIsStreaming(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetHologramsEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetHologramsEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetHologramsEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetHologramsEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)>) override;
      void GetPreviewWidth(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)>) override;
      void GetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetPreviewWidth(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetPreviewWidth(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetPreviewWidth(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)>) override;
      void GetPreviewHeight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)>) override;
      void GetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetPreviewHeight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetPreviewHeight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetPreviewHeight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetExposureLock(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetExposureLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetExposureLock(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetExposureLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetExposureLock(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetExposureLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetExposureLock(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetExposureLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetExposureBiasMin(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)>) override;
      void GetExposureBiasMin(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)>) override;
      void GetExposureBiasMin(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetExposureBiasMin(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetExposureBiasMax(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)>) override;
      void GetExposureBiasMax(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)>) override;
      void GetExposureBiasMax(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetExposureBiasMax(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetExposureBias(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)>) override;
      void GetExposureBias(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)>) override;
      void GetExposureBias(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetExposureBias(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetExposureBias(::grpc::ClientContext* context, const ::AR51::Float32Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetExposureBias(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetExposureBias(::grpc::ClientContext* context, const ::AR51::Float32Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetExposureBias(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAutoFocus(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetAutoFocus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetAutoFocus(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAutoFocus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetAutoFocus(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetAutoFocus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetAutoFocus(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetAutoFocus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetIsRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetIsRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetIsRecordingReady(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetIsRecordingReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetIsRecordingReady(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetIsRecordingReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetAutoExposureEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAutoExposureEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetAutoExposureEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetAutoExposureEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int64Message* response, std::function<void(::grpc::Status)>) override;
      void GetSensorExposureTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int64Message* response, std::function<void(::grpc::Status)>) override;
      void GetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetSensorExposureTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Int64Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetSensorExposureTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Int64Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetSensorExposureTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)>) override;
      void GetSensorSensitivity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)>) override;
      void GetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetSensorSensitivity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetSensorSensitivity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetSensorSensitivity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetVideoRecordingSetting(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetVideoRecordingSettingResponse* response, std::function<void(::grpc::Status)>) override;
      void GetVideoRecordingSetting(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetVideoRecordingSettingResponse* response, std::function<void(::grpc::Status)>) override;
      void GetVideoRecordingSetting(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetVideoRecordingSettingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetVideoRecordingSetting(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetVideoRecordingSettingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StartRecording(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest* request, ::AR51::StartRecordingResponse* response, std::function<void(::grpc::Status)>) override;
      void StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::StartRecordingResponse* response, std::function<void(::grpc::Status)>) override;
      void StartRecording(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest* request, ::AR51::StartRecordingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::StartRecordingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StartMediaRecoder(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void StartMediaRecoder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void StartMediaRecoder(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StartMediaRecoder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StopRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void StopRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DownloadVideo(::grpc::ClientContext* context, ::AR51::DownloadVideoRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::BytesMessage>* reactor) override;
      void DeleteVideo(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void DeleteVideo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void DeleteVideo(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteVideo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteAllVideos(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void DeleteAllVideos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void DeleteAllVideos(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteAllVideos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAllVideoFiles(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetAllVideoFilesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetAllVideoFiles(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetAllVideoFilesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetAllVideoFiles(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetAllVideoFilesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAllVideoFiles(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetAllVideoFilesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetCameraCharacteristics(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest* request, ::AR51::BytesMessage* response, std::function<void(::grpc::Status)>) override;
      void GetCameraCharacteristics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BytesMessage* response, std::function<void(::grpc::Status)>) override;
      void GetCameraCharacteristics(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest* request, ::AR51::BytesMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetCameraCharacteristics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BytesMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetRecorderField(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest* request, ::AR51::BytesMessage* response, std::function<void(::grpc::Status)>) override;
      void GetRecorderField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BytesMessage* response, std::function<void(::grpc::Status)>) override;
      void GetRecorderField(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest* request, ::AR51::BytesMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetRecorderField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BytesMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetRecorderField(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetRecorderField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetRecorderField(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetRecorderField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientReader< ::AR51::CameraFeedResponse>* StartStreamingRaw(::grpc::ClientContext* context, const ::AR51::CameraFeedRequest& request) override;
    ::grpc::ClientAsyncReader< ::AR51::CameraFeedResponse>* AsyncStartStreamingRaw(::grpc::ClientContext* context, const ::AR51::CameraFeedRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::CameraFeedResponse>* PrepareAsyncStartStreamingRaw(::grpc::ClientContext* context, const ::AR51::CameraFeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::AR51::BytesMessage>* StartRecorderStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) override;
    ::grpc::ClientAsyncReader< ::AR51::BytesMessage>* AsyncStartRecorderStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::BytesMessage>* PrepareAsyncStartRecorderStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AsyncGetIsStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* PrepareAsyncGetIsStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AsyncGetHologramsEnabledRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* PrepareAsyncGetHologramsEnabledRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetHologramsEnabledRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetHologramsEnabledRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>* AsyncGetPreviewWidthRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>* PrepareAsyncGetPreviewWidthRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetPreviewWidthRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetPreviewWidthRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>* AsyncGetPreviewHeightRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>* PrepareAsyncGetPreviewHeightRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetPreviewHeightRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetPreviewHeightRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AsyncGetExposureLockRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* PrepareAsyncGetExposureLockRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetExposureLockRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetExposureLockRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>* AsyncGetExposureBiasMinRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>* PrepareAsyncGetExposureBiasMinRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>* AsyncGetExposureBiasMaxRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>* PrepareAsyncGetExposureBiasMaxRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>* AsyncGetExposureBiasRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>* PrepareAsyncGetExposureBiasRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetExposureBiasRaw(::grpc::ClientContext* context, const ::AR51::Float32Message& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetExposureBiasRaw(::grpc::ClientContext* context, const ::AR51::Float32Message& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AsyncGetAutoFocusRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* PrepareAsyncGetAutoFocusRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetAutoFocusRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetAutoFocusRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AsyncGetIsRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* PrepareAsyncGetIsRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AsyncGetIsRecordingReadyRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* PrepareAsyncGetIsRecordingReadyRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AsyncGetAutoExposureEnabledRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* PrepareAsyncGetAutoExposureEnabledRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetAutoExposureEnabledRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetAutoExposureEnabledRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Int64Message>* AsyncGetSensorExposureTimeRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Int64Message>* PrepareAsyncGetSensorExposureTimeRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetSensorExposureTimeRaw(::grpc::ClientContext* context, const ::AR51::Int64Message& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetSensorExposureTimeRaw(::grpc::ClientContext* context, const ::AR51::Int64Message& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>* AsyncGetSensorSensitivityRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>* PrepareAsyncGetSensorSensitivityRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetSensorSensitivityRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetSensorSensitivityRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::GetVideoRecordingSettingResponse>* AsyncGetVideoRecordingSettingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::GetVideoRecordingSettingResponse>* PrepareAsyncGetVideoRecordingSettingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::StartRecordingResponse>* AsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::StartRecordingResponse>* PrepareAsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncStartMediaRecoderRaw(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncStartMediaRecoderRaw(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::AR51::BytesMessage>* DownloadVideoRaw(::grpc::ClientContext* context, const ::AR51::DownloadVideoRequest& request) override;
    ::grpc::ClientAsyncReader< ::AR51::BytesMessage>* AsyncDownloadVideoRaw(::grpc::ClientContext* context, const ::AR51::DownloadVideoRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::BytesMessage>* PrepareAsyncDownloadVideoRaw(::grpc::ClientContext* context, const ::AR51::DownloadVideoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncDeleteVideoRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncDeleteVideoRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncDeleteAllVideosRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncDeleteAllVideosRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::GetAllVideoFilesResponse>* AsyncGetAllVideoFilesRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::GetAllVideoFilesResponse>* PrepareAsyncGetAllVideoFilesRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BytesMessage>* AsyncGetCameraCharacteristicsRaw(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BytesMessage>* PrepareAsyncGetCameraCharacteristicsRaw(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BytesMessage>* AsyncGetRecorderFieldRaw(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BytesMessage>* PrepareAsyncGetRecorderFieldRaw(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetRecorderFieldRaw(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetRecorderFieldRaw(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_StartStreaming_;
    const ::grpc::internal::RpcMethod rpcmethod_StartRecorderStreaming_;
    const ::grpc::internal::RpcMethod rpcmethod_GetIsStreaming_;
    const ::grpc::internal::RpcMethod rpcmethod_GetHologramsEnabled_;
    const ::grpc::internal::RpcMethod rpcmethod_SetHologramsEnabled_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPreviewWidth_;
    const ::grpc::internal::RpcMethod rpcmethod_SetPreviewWidth_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPreviewHeight_;
    const ::grpc::internal::RpcMethod rpcmethod_SetPreviewHeight_;
    const ::grpc::internal::RpcMethod rpcmethod_GetExposureLock_;
    const ::grpc::internal::RpcMethod rpcmethod_SetExposureLock_;
    const ::grpc::internal::RpcMethod rpcmethod_GetExposureBiasMin_;
    const ::grpc::internal::RpcMethod rpcmethod_GetExposureBiasMax_;
    const ::grpc::internal::RpcMethod rpcmethod_GetExposureBias_;
    const ::grpc::internal::RpcMethod rpcmethod_SetExposureBias_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAutoFocus_;
    const ::grpc::internal::RpcMethod rpcmethod_SetAutoFocus_;
    const ::grpc::internal::RpcMethod rpcmethod_GetIsRecording_;
    const ::grpc::internal::RpcMethod rpcmethod_GetIsRecordingReady_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAutoExposureEnabled_;
    const ::grpc::internal::RpcMethod rpcmethod_SetAutoExposureEnabled_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSensorExposureTime_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSensorExposureTime_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSensorSensitivity_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSensorSensitivity_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVideoRecordingSetting_;
    const ::grpc::internal::RpcMethod rpcmethod_StartRecording_;
    const ::grpc::internal::RpcMethod rpcmethod_StartMediaRecoder_;
    const ::grpc::internal::RpcMethod rpcmethod_StopRecording_;
    const ::grpc::internal::RpcMethod rpcmethod_DownloadVideo_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteVideo_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteAllVideos_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAllVideoFiles_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCameraCharacteristics_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRecorderField_;
    const ::grpc::internal::RpcMethod rpcmethod_SetRecorderField_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status StartStreaming(::grpc::ServerContext* context, const ::AR51::CameraFeedRequest* request, ::grpc::ServerWriter< ::AR51::CameraFeedResponse>* writer);
    virtual ::grpc::Status StartRecorderStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::BytesMessage>* writer);
    virtual ::grpc::Status GetIsStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response);
    virtual ::grpc::Status GetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response);
    virtual ::grpc::Status SetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response);
    // Preview size
    virtual ::grpc::Status GetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response);
    virtual ::grpc::Status SetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response);
    virtual ::grpc::Status GetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response);
    virtual ::grpc::Status SetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response);
    // Exposure
    virtual ::grpc::Status GetExposureLock(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response);
    virtual ::grpc::Status SetExposureLock(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response);
    virtual ::grpc::Status GetExposureBiasMin(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response);
    virtual ::grpc::Status GetExposureBiasMax(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response);
    virtual ::grpc::Status GetExposureBias(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response);
    virtual ::grpc::Status SetExposureBias(::grpc::ServerContext* context, const ::AR51::Float32Message* request, ::AR51::Empty* response);
    // Focus
    virtual ::grpc::Status GetAutoFocus(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response);
    virtual ::grpc::Status SetAutoFocus(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response);
    // Video Recorder
    virtual ::grpc::Status GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response);
    virtual ::grpc::Status GetIsRecordingReady(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response);
    virtual ::grpc::Status GetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response);
    virtual ::grpc::Status SetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response);
    virtual ::grpc::Status GetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int64Message* response);
    virtual ::grpc::Status SetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Int64Message* request, ::AR51::Empty* response);
    virtual ::grpc::Status GetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response);
    virtual ::grpc::Status SetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response);
    // recording methods
    virtual ::grpc::Status GetVideoRecordingSetting(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetVideoRecordingSettingResponse* response);
    virtual ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::StartRecordingRequest* request, ::AR51::StartRecordingResponse* response);
    virtual ::grpc::Status StartMediaRecoder(::grpc::ServerContext* context, const ::AR51::StartMediaRecoderRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response);
    virtual ::grpc::Status DownloadVideo(::grpc::ServerContext* context, const ::AR51::DownloadVideoRequest* request, ::grpc::ServerWriter< ::AR51::BytesMessage>* writer);
    virtual ::grpc::Status DeleteVideo(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response);
    virtual ::grpc::Status DeleteAllVideos(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response);
    virtual ::grpc::Status GetAllVideoFiles(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAllVideoFilesResponse* response);
    // Camera Characteristics
    virtual ::grpc::Status GetCameraCharacteristics(::grpc::ServerContext* context, const ::AR51::GetCameraCharacteristicsRequest* request, ::AR51::BytesMessage* response);
    virtual ::grpc::Status GetRecorderField(::grpc::ServerContext* context, const ::AR51::GetRecorderFieldRequest* request, ::AR51::BytesMessage* response);
    virtual ::grpc::Status SetRecorderField(::grpc::ServerContext* context, const ::AR51::SetRecorderFieldRequest* request, ::AR51::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_StartStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StartStreaming() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_StartStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartStreaming(::grpc::ServerContext* context, const ::AR51::CameraFeedRequest* request, ::grpc::ServerWriter< ::AR51::CameraFeedResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartStreaming(::grpc::ServerContext* context, ::AR51::CameraFeedRequest* request, ::grpc::ServerAsyncWriter< ::AR51::CameraFeedResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartRecorderStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StartRecorderStreaming() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_StartRecorderStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecorderStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::BytesMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRecorderStreaming(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncWriter< ::AR51::BytesMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetIsStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetIsStreaming() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetIsStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIsStreaming(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BoolMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetHologramsEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetHologramsEnabled() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetHologramsEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetHologramsEnabled(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BoolMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetHologramsEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetHologramsEnabled() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_SetHologramsEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetHologramsEnabled(::grpc::ServerContext* context, ::AR51::BoolMessage* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPreviewWidth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetPreviewWidth() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetPreviewWidth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPreviewWidth(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Int32Message>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPreviewWidth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetPreviewWidth() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_SetPreviewWidth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPreviewWidth(::grpc::ServerContext* context, ::AR51::Int32Message* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPreviewHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetPreviewHeight() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetPreviewHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPreviewHeight(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Int32Message>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPreviewHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetPreviewHeight() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_SetPreviewHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPreviewHeight(::grpc::ServerContext* context, ::AR51::Int32Message* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetExposureLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetExposureLock() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetExposureLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureLock(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExposureLock(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BoolMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetExposureLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetExposureLock() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_SetExposureLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExposureLock(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetExposureLock(::grpc::ServerContext* context, ::AR51::BoolMessage* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetExposureBiasMin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetExposureBiasMin() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetExposureBiasMin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureBiasMin(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExposureBiasMin(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Float32Message>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetExposureBiasMax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetExposureBiasMax() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_GetExposureBiasMax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureBiasMax(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExposureBiasMax(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Float32Message>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetExposureBias : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetExposureBias() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_GetExposureBias() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureBias(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExposureBias(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Float32Message>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetExposureBias : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetExposureBias() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_SetExposureBias() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExposureBias(::grpc::ServerContext* context, const ::AR51::Float32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetExposureBias(::grpc::ServerContext* context, ::AR51::Float32Message* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAutoFocus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetAutoFocus() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_GetAutoFocus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoFocus(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAutoFocus(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BoolMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetAutoFocus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetAutoFocus() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_SetAutoFocus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoFocus(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAutoFocus(::grpc::ServerContext* context, ::AR51::BoolMessage* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetIsRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetIsRecording() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_GetIsRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIsRecording(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BoolMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetIsRecordingReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetIsRecordingReady() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_GetIsRecordingReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsRecordingReady(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIsRecordingReady(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BoolMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAutoExposureEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetAutoExposureEnabled() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_GetAutoExposureEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAutoExposureEnabled(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BoolMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetAutoExposureEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetAutoExposureEnabled() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_SetAutoExposureEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAutoExposureEnabled(::grpc::ServerContext* context, ::AR51::BoolMessage* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSensorExposureTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetSensorExposureTime() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_GetSensorExposureTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSensorExposureTime(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Int64Message>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSensorExposureTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetSensorExposureTime() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_SetSensorExposureTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Int64Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSensorExposureTime(::grpc::ServerContext* context, ::AR51::Int64Message* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSensorSensitivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetSensorSensitivity() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_GetSensorSensitivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSensorSensitivity(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Int32Message>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSensorSensitivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetSensorSensitivity() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_SetSensorSensitivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSensorSensitivity(::grpc::ServerContext* context, ::AR51::Int32Message* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVideoRecordingSetting : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetVideoRecordingSetting() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_GetVideoRecordingSetting() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVideoRecordingSetting(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetVideoRecordingSettingResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVideoRecordingSetting(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::GetVideoRecordingSettingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StartRecording() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::StartRecordingRequest* request, ::AR51::StartRecordingResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRecording(::grpc::ServerContext* context, ::AR51::StartRecordingRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::StartRecordingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartMediaRecoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StartMediaRecoder() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_StartMediaRecoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartMediaRecoder(::grpc::ServerContext* context, const ::AR51::StartMediaRecoderRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartMediaRecoder(::grpc::ServerContext* context, ::AR51::StartMediaRecoderRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StopRecording() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopRecording(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DownloadVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DownloadVideo() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_DownloadVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadVideo(::grpc::ServerContext* context, const ::AR51::DownloadVideoRequest* request, ::grpc::ServerWriter< ::AR51::BytesMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadVideo(::grpc::ServerContext* context, ::AR51::DownloadVideoRequest* request, ::grpc::ServerAsyncWriter< ::AR51::BytesMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(29, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DeleteVideo() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_DeleteVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteVideo(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteVideo(::grpc::ServerContext* context, ::AR51::StringMessage* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteAllVideos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DeleteAllVideos() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_DeleteAllVideos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAllVideos(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAllVideos(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAllVideoFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetAllVideoFiles() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_GetAllVideoFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllVideoFiles(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAllVideoFilesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllVideoFiles(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::GetAllVideoFilesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCameraCharacteristics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetCameraCharacteristics() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_GetCameraCharacteristics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCameraCharacteristics(::grpc::ServerContext* context, const ::AR51::GetCameraCharacteristicsRequest* request, ::AR51::BytesMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCameraCharacteristics(::grpc::ServerContext* context, ::AR51::GetCameraCharacteristicsRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BytesMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRecorderField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetRecorderField() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_GetRecorderField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecorderField(::grpc::ServerContext* context, const ::AR51::GetRecorderFieldRequest* request, ::AR51::BytesMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRecorderField(::grpc::ServerContext* context, ::AR51::GetRecorderFieldRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BytesMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRecorderField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetRecorderField() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_SetRecorderField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRecorderField(::grpc::ServerContext* context, const ::AR51::SetRecorderFieldRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRecorderField(::grpc::ServerContext* context, ::AR51::SetRecorderFieldRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_StartStreaming<WithAsyncMethod_StartRecorderStreaming<WithAsyncMethod_GetIsStreaming<WithAsyncMethod_GetHologramsEnabled<WithAsyncMethod_SetHologramsEnabled<WithAsyncMethod_GetPreviewWidth<WithAsyncMethod_SetPreviewWidth<WithAsyncMethod_GetPreviewHeight<WithAsyncMethod_SetPreviewHeight<WithAsyncMethod_GetExposureLock<WithAsyncMethod_SetExposureLock<WithAsyncMethod_GetExposureBiasMin<WithAsyncMethod_GetExposureBiasMax<WithAsyncMethod_GetExposureBias<WithAsyncMethod_SetExposureBias<WithAsyncMethod_GetAutoFocus<WithAsyncMethod_SetAutoFocus<WithAsyncMethod_GetIsRecording<WithAsyncMethod_GetIsRecordingReady<WithAsyncMethod_GetAutoExposureEnabled<WithAsyncMethod_SetAutoExposureEnabled<WithAsyncMethod_GetSensorExposureTime<WithAsyncMethod_SetSensorExposureTime<WithAsyncMethod_GetSensorSensitivity<WithAsyncMethod_SetSensorSensitivity<WithAsyncMethod_GetVideoRecordingSetting<WithAsyncMethod_StartRecording<WithAsyncMethod_StartMediaRecoder<WithAsyncMethod_StopRecording<WithAsyncMethod_DownloadVideo<WithAsyncMethod_DeleteVideo<WithAsyncMethod_DeleteAllVideos<WithAsyncMethod_GetAllVideoFiles<WithAsyncMethod_GetCameraCharacteristics<WithAsyncMethod_GetRecorderField<WithAsyncMethod_SetRecorderField<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StartStreaming() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::CameraFeedRequest, ::AR51::CameraFeedResponse>(
          [this] { return this->StartStreaming(); }));
    }
    ~ExperimentalWithCallbackMethod_StartStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartStreaming(::grpc::ServerContext* context, const ::AR51::CameraFeedRequest* request, ::grpc::ServerWriter< ::AR51::CameraFeedResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::CameraFeedRequest, ::AR51::CameraFeedResponse>* StartStreaming() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::CameraFeedRequest, ::AR51::CameraFeedResponse>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartRecorderStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StartRecorderStreaming() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::Empty, ::AR51::BytesMessage>(
          [this] { return this->StartRecorderStreaming(); }));
    }
    ~ExperimentalWithCallbackMethod_StartRecorderStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecorderStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::BytesMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::Empty, ::AR51::BytesMessage>* StartRecorderStreaming() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::Empty, ::AR51::BytesMessage>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetIsStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetIsStreaming() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::BoolMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetIsStreaming(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetIsStreaming(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::BoolMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetIsStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetIsStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetHologramsEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetHologramsEnabled() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::BoolMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetHologramsEnabled(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetHologramsEnabled(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::BoolMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetHologramsEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetHologramsEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetHologramsEnabled() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::BoolMessage, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::BoolMessage* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetHologramsEnabled(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetHologramsEnabled(
        ::grpc::experimental::MessageAllocator< ::AR51::BoolMessage, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::BoolMessage, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetHologramsEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetPreviewWidth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetPreviewWidth() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Int32Message>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Int32Message* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetPreviewWidth(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetPreviewWidth(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Int32Message>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Int32Message>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetPreviewWidth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetPreviewWidth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetPreviewWidth() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Int32Message, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Int32Message* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetPreviewWidth(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetPreviewWidth(
        ::grpc::experimental::MessageAllocator< ::AR51::Int32Message, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Int32Message, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetPreviewWidth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetPreviewHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetPreviewHeight() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Int32Message>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Int32Message* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetPreviewHeight(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetPreviewHeight(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Int32Message>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Int32Message>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetPreviewHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetPreviewHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetPreviewHeight() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Int32Message, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Int32Message* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetPreviewHeight(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetPreviewHeight(
        ::grpc::experimental::MessageAllocator< ::AR51::Int32Message, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Int32Message, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(8))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetPreviewHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetExposureLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetExposureLock() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::BoolMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetExposureLock(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetExposureLock(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::BoolMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>*>(
          ::grpc::Service::experimental().GetHandler(9))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetExposureLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureLock(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetExposureLock(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetExposureLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetExposureLock() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::BoolMessage, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::BoolMessage* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetExposureLock(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetExposureLock(
        ::grpc::experimental::MessageAllocator< ::AR51::BoolMessage, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::BoolMessage, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(10))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetExposureLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExposureLock(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetExposureLock(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetExposureBiasMin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetExposureBiasMin() {
      ::grpc::Service::experimental().MarkMethodCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Float32Message>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Float32Message* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetExposureBiasMin(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetExposureBiasMin(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Float32Message>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Float32Message>*>(
          ::grpc::Service::experimental().GetHandler(11))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetExposureBiasMin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureBiasMin(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetExposureBiasMin(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetExposureBiasMax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetExposureBiasMax() {
      ::grpc::Service::experimental().MarkMethodCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Float32Message>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Float32Message* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetExposureBiasMax(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetExposureBiasMax(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Float32Message>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Float32Message>*>(
          ::grpc::Service::experimental().GetHandler(12))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetExposureBiasMax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureBiasMax(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetExposureBiasMax(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetExposureBias : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetExposureBias() {
      ::grpc::Service::experimental().MarkMethodCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Float32Message>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Float32Message* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetExposureBias(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetExposureBias(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Float32Message>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Float32Message>*>(
          ::grpc::Service::experimental().GetHandler(13))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetExposureBias() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureBias(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetExposureBias(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetExposureBias : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetExposureBias() {
      ::grpc::Service::experimental().MarkMethodCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Float32Message, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Float32Message* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetExposureBias(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetExposureBias(
        ::grpc::experimental::MessageAllocator< ::AR51::Float32Message, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Float32Message, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(14))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetExposureBias() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExposureBias(::grpc::ServerContext* context, const ::AR51::Float32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetExposureBias(::grpc::ServerContext* context, const ::AR51::Float32Message* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAutoFocus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetAutoFocus() {
      ::grpc::Service::experimental().MarkMethodCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::BoolMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetAutoFocus(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetAutoFocus(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::BoolMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>*>(
          ::grpc::Service::experimental().GetHandler(15))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAutoFocus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoFocus(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAutoFocus(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetAutoFocus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetAutoFocus() {
      ::grpc::Service::experimental().MarkMethodCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::BoolMessage, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::BoolMessage* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetAutoFocus(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetAutoFocus(
        ::grpc::experimental::MessageAllocator< ::AR51::BoolMessage, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::BoolMessage, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(16))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetAutoFocus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoFocus(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetAutoFocus(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetIsRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetIsRecording() {
      ::grpc::Service::experimental().MarkMethodCallback(17,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::BoolMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetIsRecording(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetIsRecording(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::BoolMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>*>(
          ::grpc::Service::experimental().GetHandler(17))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetIsRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetIsRecordingReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetIsRecordingReady() {
      ::grpc::Service::experimental().MarkMethodCallback(18,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::BoolMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetIsRecordingReady(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetIsRecordingReady(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::BoolMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>*>(
          ::grpc::Service::experimental().GetHandler(18))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetIsRecordingReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsRecordingReady(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetIsRecordingReady(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAutoExposureEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetAutoExposureEnabled() {
      ::grpc::Service::experimental().MarkMethodCallback(19,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::BoolMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetAutoExposureEnabled(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetAutoExposureEnabled(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::BoolMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>*>(
          ::grpc::Service::experimental().GetHandler(19))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAutoExposureEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetAutoExposureEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetAutoExposureEnabled() {
      ::grpc::Service::experimental().MarkMethodCallback(20,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::BoolMessage, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::BoolMessage* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetAutoExposureEnabled(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetAutoExposureEnabled(
        ::grpc::experimental::MessageAllocator< ::AR51::BoolMessage, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::BoolMessage, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(20))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetAutoExposureEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetSensorExposureTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetSensorExposureTime() {
      ::grpc::Service::experimental().MarkMethodCallback(21,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Int64Message>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Int64Message* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetSensorExposureTime(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetSensorExposureTime(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Int64Message>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Int64Message>*>(
          ::grpc::Service::experimental().GetHandler(21))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetSensorExposureTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int64Message* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetSensorExposureTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetSensorExposureTime() {
      ::grpc::Service::experimental().MarkMethodCallback(22,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Int64Message, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Int64Message* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetSensorExposureTime(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetSensorExposureTime(
        ::grpc::experimental::MessageAllocator< ::AR51::Int64Message, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Int64Message, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(22))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetSensorExposureTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Int64Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Int64Message* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetSensorSensitivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetSensorSensitivity() {
      ::grpc::Service::experimental().MarkMethodCallback(23,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Int32Message>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Int32Message* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetSensorSensitivity(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetSensorSensitivity(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Int32Message>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Int32Message>*>(
          ::grpc::Service::experimental().GetHandler(23))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetSensorSensitivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetSensorSensitivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetSensorSensitivity() {
      ::grpc::Service::experimental().MarkMethodCallback(24,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Int32Message, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Int32Message* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetSensorSensitivity(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetSensorSensitivity(
        ::grpc::experimental::MessageAllocator< ::AR51::Int32Message, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Int32Message, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(24))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetSensorSensitivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetVideoRecordingSetting : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetVideoRecordingSetting() {
      ::grpc::Service::experimental().MarkMethodCallback(25,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::GetVideoRecordingSettingResponse>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::GetVideoRecordingSettingResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetVideoRecordingSetting(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetVideoRecordingSetting(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::GetVideoRecordingSettingResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::GetVideoRecordingSettingResponse>*>(
          ::grpc::Service::experimental().GetHandler(25))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetVideoRecordingSetting() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVideoRecordingSetting(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetVideoRecordingSettingResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetVideoRecordingSetting(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetVideoRecordingSettingResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StartRecording() {
      ::grpc::Service::experimental().MarkMethodCallback(26,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::StartRecordingRequest, ::AR51::StartRecordingResponse>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::StartRecordingRequest* request,
                 ::AR51::StartRecordingResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StartRecording(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StartRecording(
        ::grpc::experimental::MessageAllocator< ::AR51::StartRecordingRequest, ::AR51::StartRecordingResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::StartRecordingRequest, ::AR51::StartRecordingResponse>*>(
          ::grpc::Service::experimental().GetHandler(26))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::StartRecordingRequest* request, ::AR51::StartRecordingResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StartRecording(::grpc::ServerContext* context, const ::AR51::StartRecordingRequest* request, ::AR51::StartRecordingResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartMediaRecoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StartMediaRecoder() {
      ::grpc::Service::experimental().MarkMethodCallback(27,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::StartMediaRecoderRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::StartMediaRecoderRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StartMediaRecoder(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StartMediaRecoder(
        ::grpc::experimental::MessageAllocator< ::AR51::StartMediaRecoderRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::StartMediaRecoderRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(27))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StartMediaRecoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartMediaRecoder(::grpc::ServerContext* context, const ::AR51::StartMediaRecoderRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StartMediaRecoder(::grpc::ServerContext* context, const ::AR51::StartMediaRecoderRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StopRecording() {
      ::grpc::Service::experimental().MarkMethodCallback(28,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StopRecording(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StopRecording(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(28))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DownloadVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_DownloadVideo() {
      ::grpc::Service::experimental().MarkMethodCallback(29,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::DownloadVideoRequest, ::AR51::BytesMessage>(
          [this] { return this->DownloadVideo(); }));
    }
    ~ExperimentalWithCallbackMethod_DownloadVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadVideo(::grpc::ServerContext* context, const ::AR51::DownloadVideoRequest* request, ::grpc::ServerWriter< ::AR51::BytesMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::DownloadVideoRequest, ::AR51::BytesMessage>* DownloadVideo() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::DownloadVideoRequest, ::AR51::BytesMessage>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_DeleteVideo() {
      ::grpc::Service::experimental().MarkMethodCallback(30,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::StringMessage, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::StringMessage* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->DeleteVideo(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_DeleteVideo(
        ::grpc::experimental::MessageAllocator< ::AR51::StringMessage, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::StringMessage, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(30))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteVideo(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteVideo(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteAllVideos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_DeleteAllVideos() {
      ::grpc::Service::experimental().MarkMethodCallback(31,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->DeleteAllVideos(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_DeleteAllVideos(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(31))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteAllVideos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAllVideos(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteAllVideos(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAllVideoFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetAllVideoFiles() {
      ::grpc::Service::experimental().MarkMethodCallback(32,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::GetAllVideoFilesResponse>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::GetAllVideoFilesResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetAllVideoFiles(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetAllVideoFiles(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::GetAllVideoFilesResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::GetAllVideoFilesResponse>*>(
          ::grpc::Service::experimental().GetHandler(32))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAllVideoFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllVideoFiles(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAllVideoFilesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAllVideoFiles(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAllVideoFilesResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetCameraCharacteristics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetCameraCharacteristics() {
      ::grpc::Service::experimental().MarkMethodCallback(33,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GetCameraCharacteristicsRequest, ::AR51::BytesMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::GetCameraCharacteristicsRequest* request,
                 ::AR51::BytesMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetCameraCharacteristics(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetCameraCharacteristics(
        ::grpc::experimental::MessageAllocator< ::AR51::GetCameraCharacteristicsRequest, ::AR51::BytesMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GetCameraCharacteristicsRequest, ::AR51::BytesMessage>*>(
          ::grpc::Service::experimental().GetHandler(33))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetCameraCharacteristics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCameraCharacteristics(::grpc::ServerContext* context, const ::AR51::GetCameraCharacteristicsRequest* request, ::AR51::BytesMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCameraCharacteristics(::grpc::ServerContext* context, const ::AR51::GetCameraCharacteristicsRequest* request, ::AR51::BytesMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRecorderField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetRecorderField() {
      ::grpc::Service::experimental().MarkMethodCallback(34,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GetRecorderFieldRequest, ::AR51::BytesMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::GetRecorderFieldRequest* request,
                 ::AR51::BytesMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetRecorderField(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetRecorderField(
        ::grpc::experimental::MessageAllocator< ::AR51::GetRecorderFieldRequest, ::AR51::BytesMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GetRecorderFieldRequest, ::AR51::BytesMessage>*>(
          ::grpc::Service::experimental().GetHandler(34))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRecorderField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecorderField(::grpc::ServerContext* context, const ::AR51::GetRecorderFieldRequest* request, ::AR51::BytesMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetRecorderField(::grpc::ServerContext* context, const ::AR51::GetRecorderFieldRequest* request, ::AR51::BytesMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetRecorderField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetRecorderField() {
      ::grpc::Service::experimental().MarkMethodCallback(35,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetRecorderFieldRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::SetRecorderFieldRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetRecorderField(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetRecorderField(
        ::grpc::experimental::MessageAllocator< ::AR51::SetRecorderFieldRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetRecorderFieldRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(35))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetRecorderField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRecorderField(::grpc::ServerContext* context, const ::AR51::SetRecorderFieldRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetRecorderField(::grpc::ServerContext* context, const ::AR51::SetRecorderFieldRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_StartStreaming<ExperimentalWithCallbackMethod_StartRecorderStreaming<ExperimentalWithCallbackMethod_GetIsStreaming<ExperimentalWithCallbackMethod_GetHologramsEnabled<ExperimentalWithCallbackMethod_SetHologramsEnabled<ExperimentalWithCallbackMethod_GetPreviewWidth<ExperimentalWithCallbackMethod_SetPreviewWidth<ExperimentalWithCallbackMethod_GetPreviewHeight<ExperimentalWithCallbackMethod_SetPreviewHeight<ExperimentalWithCallbackMethod_GetExposureLock<ExperimentalWithCallbackMethod_SetExposureLock<ExperimentalWithCallbackMethod_GetExposureBiasMin<ExperimentalWithCallbackMethod_GetExposureBiasMax<ExperimentalWithCallbackMethod_GetExposureBias<ExperimentalWithCallbackMethod_SetExposureBias<ExperimentalWithCallbackMethod_GetAutoFocus<ExperimentalWithCallbackMethod_SetAutoFocus<ExperimentalWithCallbackMethod_GetIsRecording<ExperimentalWithCallbackMethod_GetIsRecordingReady<ExperimentalWithCallbackMethod_GetAutoExposureEnabled<ExperimentalWithCallbackMethod_SetAutoExposureEnabled<ExperimentalWithCallbackMethod_GetSensorExposureTime<ExperimentalWithCallbackMethod_SetSensorExposureTime<ExperimentalWithCallbackMethod_GetSensorSensitivity<ExperimentalWithCallbackMethod_SetSensorSensitivity<ExperimentalWithCallbackMethod_GetVideoRecordingSetting<ExperimentalWithCallbackMethod_StartRecording<ExperimentalWithCallbackMethod_StartMediaRecoder<ExperimentalWithCallbackMethod_StopRecording<ExperimentalWithCallbackMethod_DownloadVideo<ExperimentalWithCallbackMethod_DeleteVideo<ExperimentalWithCallbackMethod_DeleteAllVideos<ExperimentalWithCallbackMethod_GetAllVideoFiles<ExperimentalWithCallbackMethod_GetCameraCharacteristics<ExperimentalWithCallbackMethod_GetRecorderField<ExperimentalWithCallbackMethod_SetRecorderField<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_StartStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StartStreaming() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_StartStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartStreaming(::grpc::ServerContext* context, const ::AR51::CameraFeedRequest* request, ::grpc::ServerWriter< ::AR51::CameraFeedResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartRecorderStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StartRecorderStreaming() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_StartRecorderStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecorderStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::BytesMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetIsStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetIsStreaming() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetIsStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetHologramsEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetHologramsEnabled() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetHologramsEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetHologramsEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetHologramsEnabled() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_SetHologramsEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPreviewWidth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetPreviewWidth() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetPreviewWidth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetPreviewWidth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetPreviewWidth() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_SetPreviewWidth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPreviewHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetPreviewHeight() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetPreviewHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetPreviewHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetPreviewHeight() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_SetPreviewHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetExposureLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetExposureLock() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetExposureLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureLock(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetExposureLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetExposureLock() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_SetExposureLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExposureLock(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetExposureBiasMin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetExposureBiasMin() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetExposureBiasMin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureBiasMin(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetExposureBiasMax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetExposureBiasMax() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_GetExposureBiasMax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureBiasMax(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetExposureBias : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetExposureBias() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_GetExposureBias() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureBias(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetExposureBias : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetExposureBias() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_SetExposureBias() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExposureBias(::grpc::ServerContext* context, const ::AR51::Float32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAutoFocus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetAutoFocus() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_GetAutoFocus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoFocus(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetAutoFocus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetAutoFocus() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_SetAutoFocus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoFocus(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetIsRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetIsRecording() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_GetIsRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetIsRecordingReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetIsRecordingReady() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_GetIsRecordingReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsRecordingReady(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAutoExposureEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetAutoExposureEnabled() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_GetAutoExposureEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetAutoExposureEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetAutoExposureEnabled() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_SetAutoExposureEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSensorExposureTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetSensorExposureTime() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_GetSensorExposureTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSensorExposureTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetSensorExposureTime() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_SetSensorExposureTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Int64Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSensorSensitivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetSensorSensitivity() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_GetSensorSensitivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSensorSensitivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetSensorSensitivity() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_SetSensorSensitivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVideoRecordingSetting : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetVideoRecordingSetting() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_GetVideoRecordingSetting() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVideoRecordingSetting(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetVideoRecordingSettingResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StartRecording() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::StartRecordingRequest* request, ::AR51::StartRecordingResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartMediaRecoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StartMediaRecoder() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_StartMediaRecoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartMediaRecoder(::grpc::ServerContext* context, const ::AR51::StartMediaRecoderRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StopRecording() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DownloadVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DownloadVideo() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_DownloadVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadVideo(::grpc::ServerContext* context, const ::AR51::DownloadVideoRequest* request, ::grpc::ServerWriter< ::AR51::BytesMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DeleteVideo() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_DeleteVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteVideo(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteAllVideos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DeleteAllVideos() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_DeleteAllVideos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAllVideos(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAllVideoFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetAllVideoFiles() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_GetAllVideoFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllVideoFiles(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAllVideoFilesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCameraCharacteristics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetCameraCharacteristics() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_GetCameraCharacteristics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCameraCharacteristics(::grpc::ServerContext* context, const ::AR51::GetCameraCharacteristicsRequest* request, ::AR51::BytesMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRecorderField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetRecorderField() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_GetRecorderField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecorderField(::grpc::ServerContext* context, const ::AR51::GetRecorderFieldRequest* request, ::AR51::BytesMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRecorderField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetRecorderField() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_SetRecorderField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRecorderField(::grpc::ServerContext* context, const ::AR51::SetRecorderFieldRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StartStreaming() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_StartStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartStreaming(::grpc::ServerContext* context, const ::AR51::CameraFeedRequest* request, ::grpc::ServerWriter< ::AR51::CameraFeedResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartStreaming(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartRecorderStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StartRecorderStreaming() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_StartRecorderStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecorderStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::BytesMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRecorderStreaming(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetIsStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetIsStreaming() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetIsStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIsStreaming(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetHologramsEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetHologramsEnabled() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetHologramsEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetHologramsEnabled(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetHologramsEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetHologramsEnabled() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_SetHologramsEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetHologramsEnabled(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPreviewWidth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetPreviewWidth() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetPreviewWidth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPreviewWidth(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPreviewWidth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetPreviewWidth() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_SetPreviewWidth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPreviewWidth(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPreviewHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetPreviewHeight() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetPreviewHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPreviewHeight(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPreviewHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetPreviewHeight() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_SetPreviewHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPreviewHeight(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetExposureLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetExposureLock() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetExposureLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureLock(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExposureLock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetExposureLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetExposureLock() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_SetExposureLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExposureLock(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetExposureLock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetExposureBiasMin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetExposureBiasMin() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetExposureBiasMin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureBiasMin(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExposureBiasMin(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetExposureBiasMax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetExposureBiasMax() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_GetExposureBiasMax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureBiasMax(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExposureBiasMax(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetExposureBias : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetExposureBias() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_GetExposureBias() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureBias(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExposureBias(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetExposureBias : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetExposureBias() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_SetExposureBias() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExposureBias(::grpc::ServerContext* context, const ::AR51::Float32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetExposureBias(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAutoFocus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetAutoFocus() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_GetAutoFocus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoFocus(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAutoFocus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetAutoFocus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetAutoFocus() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_SetAutoFocus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoFocus(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAutoFocus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetIsRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetIsRecording() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_GetIsRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIsRecording(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetIsRecordingReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetIsRecordingReady() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_GetIsRecordingReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsRecordingReady(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIsRecordingReady(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAutoExposureEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetAutoExposureEnabled() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_GetAutoExposureEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAutoExposureEnabled(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetAutoExposureEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetAutoExposureEnabled() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_SetAutoExposureEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAutoExposureEnabled(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSensorExposureTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetSensorExposureTime() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_GetSensorExposureTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSensorExposureTime(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSensorExposureTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetSensorExposureTime() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_SetSensorExposureTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Int64Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSensorExposureTime(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSensorSensitivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetSensorSensitivity() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_GetSensorSensitivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSensorSensitivity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSensorSensitivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetSensorSensitivity() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_SetSensorSensitivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSensorSensitivity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVideoRecordingSetting : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetVideoRecordingSetting() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_GetVideoRecordingSetting() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVideoRecordingSetting(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetVideoRecordingSettingResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVideoRecordingSetting(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StartRecording() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::StartRecordingRequest* request, ::AR51::StartRecordingResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRecording(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartMediaRecoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StartMediaRecoder() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_StartMediaRecoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartMediaRecoder(::grpc::ServerContext* context, const ::AR51::StartMediaRecoderRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartMediaRecoder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StopRecording() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopRecording(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DownloadVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DownloadVideo() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_DownloadVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadVideo(::grpc::ServerContext* context, const ::AR51::DownloadVideoRequest* request, ::grpc::ServerWriter< ::AR51::BytesMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadVideo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(29, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DeleteVideo() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_DeleteVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteVideo(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteVideo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteAllVideos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DeleteAllVideos() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_DeleteAllVideos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAllVideos(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAllVideos(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAllVideoFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetAllVideoFiles() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_GetAllVideoFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllVideoFiles(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAllVideoFilesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllVideoFiles(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCameraCharacteristics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetCameraCharacteristics() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_GetCameraCharacteristics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCameraCharacteristics(::grpc::ServerContext* context, const ::AR51::GetCameraCharacteristicsRequest* request, ::AR51::BytesMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCameraCharacteristics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRecorderField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetRecorderField() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_GetRecorderField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecorderField(::grpc::ServerContext* context, const ::AR51::GetRecorderFieldRequest* request, ::AR51::BytesMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRecorderField(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetRecorderField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetRecorderField() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_SetRecorderField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRecorderField(::grpc::ServerContext* context, const ::AR51::SetRecorderFieldRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRecorderField(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StartStreaming() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->StartStreaming(); }));
    }
    ~ExperimentalWithRawCallbackMethod_StartStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartStreaming(::grpc::ServerContext* context, const ::AR51::CameraFeedRequest* request, ::grpc::ServerWriter< ::AR51::CameraFeedResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* StartStreaming() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartRecorderStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StartRecorderStreaming() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->StartRecorderStreaming(); }));
    }
    ~ExperimentalWithRawCallbackMethod_StartRecorderStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecorderStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::BytesMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* StartRecorderStreaming() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetIsStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetIsStreaming() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetIsStreaming(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetIsStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetIsStreaming(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetHologramsEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetHologramsEnabled() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetHologramsEnabled(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetHologramsEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetHologramsEnabled(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetHologramsEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetHologramsEnabled() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetHologramsEnabled(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetHologramsEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetHologramsEnabled(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetPreviewWidth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetPreviewWidth() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetPreviewWidth(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetPreviewWidth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetPreviewWidth(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetPreviewWidth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetPreviewWidth() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetPreviewWidth(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetPreviewWidth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetPreviewWidth(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetPreviewHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetPreviewHeight() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetPreviewHeight(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetPreviewHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetPreviewHeight(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetPreviewHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetPreviewHeight() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetPreviewHeight(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetPreviewHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetPreviewHeight(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetExposureLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetExposureLock() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetExposureLock(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetExposureLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureLock(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetExposureLock(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetExposureLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetExposureLock() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetExposureLock(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetExposureLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExposureLock(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetExposureLock(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetExposureBiasMin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetExposureBiasMin() {
      ::grpc::Service::experimental().MarkMethodRawCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetExposureBiasMin(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetExposureBiasMin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureBiasMin(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetExposureBiasMin(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetExposureBiasMax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetExposureBiasMax() {
      ::grpc::Service::experimental().MarkMethodRawCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetExposureBiasMax(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetExposureBiasMax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureBiasMax(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetExposureBiasMax(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetExposureBias : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetExposureBias() {
      ::grpc::Service::experimental().MarkMethodRawCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetExposureBias(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetExposureBias() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExposureBias(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetExposureBias(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetExposureBias : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetExposureBias() {
      ::grpc::Service::experimental().MarkMethodRawCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetExposureBias(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetExposureBias() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExposureBias(::grpc::ServerContext* context, const ::AR51::Float32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetExposureBias(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAutoFocus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAutoFocus() {
      ::grpc::Service::experimental().MarkMethodRawCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetAutoFocus(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAutoFocus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoFocus(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAutoFocus(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetAutoFocus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetAutoFocus() {
      ::grpc::Service::experimental().MarkMethodRawCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetAutoFocus(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetAutoFocus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoFocus(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetAutoFocus(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetIsRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetIsRecording() {
      ::grpc::Service::experimental().MarkMethodRawCallback(17,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetIsRecording(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetIsRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetIsRecording(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetIsRecordingReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetIsRecordingReady() {
      ::grpc::Service::experimental().MarkMethodRawCallback(18,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetIsRecordingReady(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetIsRecordingReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIsRecordingReady(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetIsRecordingReady(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAutoExposureEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAutoExposureEnabled() {
      ::grpc::Service::experimental().MarkMethodRawCallback(19,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetAutoExposureEnabled(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAutoExposureEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAutoExposureEnabled(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetAutoExposureEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetAutoExposureEnabled() {
      ::grpc::Service::experimental().MarkMethodRawCallback(20,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetAutoExposureEnabled(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetAutoExposureEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetAutoExposureEnabled(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetSensorExposureTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetSensorExposureTime() {
      ::grpc::Service::experimental().MarkMethodRawCallback(21,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetSensorExposureTime(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetSensorExposureTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetSensorExposureTime(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetSensorExposureTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetSensorExposureTime() {
      ::grpc::Service::experimental().MarkMethodRawCallback(22,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetSensorExposureTime(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetSensorExposureTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Int64Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetSensorExposureTime(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetSensorSensitivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetSensorSensitivity() {
      ::grpc::Service::experimental().MarkMethodRawCallback(23,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetSensorSensitivity(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetSensorSensitivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetSensorSensitivity(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetSensorSensitivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetSensorSensitivity() {
      ::grpc::Service::experimental().MarkMethodRawCallback(24,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetSensorSensitivity(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetSensorSensitivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetSensorSensitivity(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetVideoRecordingSetting : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetVideoRecordingSetting() {
      ::grpc::Service::experimental().MarkMethodRawCallback(25,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetVideoRecordingSetting(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetVideoRecordingSetting() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVideoRecordingSetting(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetVideoRecordingSettingResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetVideoRecordingSetting(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StartRecording() {
      ::grpc::Service::experimental().MarkMethodRawCallback(26,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StartRecording(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::StartRecordingRequest* request, ::AR51::StartRecordingResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StartRecording(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartMediaRecoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StartMediaRecoder() {
      ::grpc::Service::experimental().MarkMethodRawCallback(27,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StartMediaRecoder(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StartMediaRecoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartMediaRecoder(::grpc::ServerContext* context, const ::AR51::StartMediaRecoderRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StartMediaRecoder(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StopRecording() {
      ::grpc::Service::experimental().MarkMethodRawCallback(28,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StopRecording(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopRecording(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DownloadVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_DownloadVideo() {
      ::grpc::Service::experimental().MarkMethodRawCallback(29,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->DownloadVideo(); }));
    }
    ~ExperimentalWithRawCallbackMethod_DownloadVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadVideo(::grpc::ServerContext* context, const ::AR51::DownloadVideoRequest* request, ::grpc::ServerWriter< ::AR51::BytesMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* DownloadVideo() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteVideo() {
      ::grpc::Service::experimental().MarkMethodRawCallback(30,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->DeleteVideo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteVideo(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteVideo(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteAllVideos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteAllVideos() {
      ::grpc::Service::experimental().MarkMethodRawCallback(31,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->DeleteAllVideos(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteAllVideos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAllVideos(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteAllVideos(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAllVideoFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAllVideoFiles() {
      ::grpc::Service::experimental().MarkMethodRawCallback(32,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetAllVideoFiles(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAllVideoFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllVideoFiles(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAllVideoFilesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAllVideoFiles(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetCameraCharacteristics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetCameraCharacteristics() {
      ::grpc::Service::experimental().MarkMethodRawCallback(33,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetCameraCharacteristics(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetCameraCharacteristics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCameraCharacteristics(::grpc::ServerContext* context, const ::AR51::GetCameraCharacteristicsRequest* request, ::AR51::BytesMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCameraCharacteristics(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRecorderField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRecorderField() {
      ::grpc::Service::experimental().MarkMethodRawCallback(34,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetRecorderField(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRecorderField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecorderField(::grpc::ServerContext* context, const ::AR51::GetRecorderFieldRequest* request, ::AR51::BytesMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetRecorderField(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetRecorderField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetRecorderField() {
      ::grpc::Service::experimental().MarkMethodRawCallback(35,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetRecorderField(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetRecorderField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRecorderField(::grpc::ServerContext* context, const ::AR51::SetRecorderFieldRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetRecorderField(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetIsStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetIsStreaming() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>(std::bind(&WithStreamedUnaryMethod_GetIsStreaming<BaseClass>::StreamedGetIsStreaming, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetIsStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetIsStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetIsStreaming(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::BoolMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetHologramsEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetHologramsEnabled() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>(std::bind(&WithStreamedUnaryMethod_GetHologramsEnabled<BaseClass>::StreamedGetHologramsEnabled, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetHologramsEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetHologramsEnabled(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::BoolMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetHologramsEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetHologramsEnabled() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::BoolMessage, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetHologramsEnabled<BaseClass>::StreamedSetHologramsEnabled, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetHologramsEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetHologramsEnabled(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::BoolMessage,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPreviewWidth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetPreviewWidth() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Int32Message>(std::bind(&WithStreamedUnaryMethod_GetPreviewWidth<BaseClass>::StreamedGetPreviewWidth, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetPreviewWidth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPreviewWidth(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Int32Message>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPreviewWidth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetPreviewWidth() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Int32Message, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetPreviewWidth<BaseClass>::StreamedSetPreviewWidth, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetPreviewWidth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPreviewWidth(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Int32Message,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPreviewHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetPreviewHeight() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Int32Message>(std::bind(&WithStreamedUnaryMethod_GetPreviewHeight<BaseClass>::StreamedGetPreviewHeight, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetPreviewHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPreviewHeight(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Int32Message>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPreviewHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetPreviewHeight() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Int32Message, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetPreviewHeight<BaseClass>::StreamedSetPreviewHeight, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetPreviewHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPreviewHeight(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Int32Message,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetExposureLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetExposureLock() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>(std::bind(&WithStreamedUnaryMethod_GetExposureLock<BaseClass>::StreamedGetExposureLock, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetExposureLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetExposureLock(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetExposureLock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::BoolMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetExposureLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetExposureLock() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::BoolMessage, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetExposureLock<BaseClass>::StreamedSetExposureLock, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetExposureLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetExposureLock(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetExposureLock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::BoolMessage,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetExposureBiasMin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetExposureBiasMin() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Float32Message>(std::bind(&WithStreamedUnaryMethod_GetExposureBiasMin<BaseClass>::StreamedGetExposureBiasMin, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetExposureBiasMin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetExposureBiasMin(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetExposureBiasMin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Float32Message>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetExposureBiasMax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetExposureBiasMax() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Float32Message>(std::bind(&WithStreamedUnaryMethod_GetExposureBiasMax<BaseClass>::StreamedGetExposureBiasMax, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetExposureBiasMax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetExposureBiasMax(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetExposureBiasMax(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Float32Message>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetExposureBias : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetExposureBias() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Float32Message>(std::bind(&WithStreamedUnaryMethod_GetExposureBias<BaseClass>::StreamedGetExposureBias, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetExposureBias() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetExposureBias(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetExposureBias(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Float32Message>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetExposureBias : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetExposureBias() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Float32Message, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetExposureBias<BaseClass>::StreamedSetExposureBias, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetExposureBias() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetExposureBias(::grpc::ServerContext* context, const ::AR51::Float32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetExposureBias(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Float32Message,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAutoFocus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetAutoFocus() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>(std::bind(&WithStreamedUnaryMethod_GetAutoFocus<BaseClass>::StreamedGetAutoFocus, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetAutoFocus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAutoFocus(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAutoFocus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::BoolMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetAutoFocus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetAutoFocus() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::BoolMessage, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetAutoFocus<BaseClass>::StreamedSetAutoFocus, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetAutoFocus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetAutoFocus(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetAutoFocus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::BoolMessage,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetIsRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetIsRecording() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>(std::bind(&WithStreamedUnaryMethod_GetIsRecording<BaseClass>::StreamedGetIsRecording, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetIsRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetIsRecording(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::BoolMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetIsRecordingReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetIsRecordingReady() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>(std::bind(&WithStreamedUnaryMethod_GetIsRecordingReady<BaseClass>::StreamedGetIsRecordingReady, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetIsRecordingReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetIsRecordingReady(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetIsRecordingReady(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::BoolMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAutoExposureEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetAutoExposureEnabled() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::BoolMessage>(std::bind(&WithStreamedUnaryMethod_GetAutoExposureEnabled<BaseClass>::StreamedGetAutoExposureEnabled, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetAutoExposureEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAutoExposureEnabled(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::BoolMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetAutoExposureEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetAutoExposureEnabled() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::BoolMessage, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetAutoExposureEnabled<BaseClass>::StreamedSetAutoExposureEnabled, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetAutoExposureEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetAutoExposureEnabled(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::BoolMessage,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSensorExposureTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetSensorExposureTime() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Int64Message>(std::bind(&WithStreamedUnaryMethod_GetSensorExposureTime<BaseClass>::StreamedGetSensorExposureTime, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetSensorExposureTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSensorExposureTime(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Int64Message>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSensorExposureTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetSensorExposureTime() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Int64Message, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetSensorExposureTime<BaseClass>::StreamedSetSensorExposureTime, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetSensorExposureTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Int64Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSensorExposureTime(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Int64Message,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSensorSensitivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetSensorSensitivity() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Int32Message>(std::bind(&WithStreamedUnaryMethod_GetSensorSensitivity<BaseClass>::StreamedGetSensorSensitivity, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetSensorSensitivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSensorSensitivity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Int32Message>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSensorSensitivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetSensorSensitivity() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Int32Message, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetSensorSensitivity<BaseClass>::StreamedSetSensorSensitivity, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetSensorSensitivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSensorSensitivity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Int32Message,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVideoRecordingSetting : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetVideoRecordingSetting() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::GetVideoRecordingSettingResponse>(std::bind(&WithStreamedUnaryMethod_GetVideoRecordingSetting<BaseClass>::StreamedGetVideoRecordingSetting, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetVideoRecordingSetting() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVideoRecordingSetting(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetVideoRecordingSettingResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVideoRecordingSetting(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::GetVideoRecordingSettingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StartRecording() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::StartRecordingRequest, ::AR51::StartRecordingResponse>(std::bind(&WithStreamedUnaryMethod_StartRecording<BaseClass>::StreamedStartRecording, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::AR51::StartRecordingRequest* request, ::AR51::StartRecordingResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartRecording(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::StartRecordingRequest,::AR51::StartRecordingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartMediaRecoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StartMediaRecoder() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::StartMediaRecoderRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_StartMediaRecoder<BaseClass>::StreamedStartMediaRecoder, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StartMediaRecoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartMediaRecoder(::grpc::ServerContext* context, const ::AR51::StartMediaRecoderRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartMediaRecoder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::StartMediaRecoderRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StopRecording() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_StopRecording<BaseClass>::StreamedStopRecording, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopRecording(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DeleteVideo() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::StringMessage, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_DeleteVideo<BaseClass>::StreamedDeleteVideo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteVideo(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteVideo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::StringMessage,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteAllVideos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DeleteAllVideos() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_DeleteAllVideos<BaseClass>::StreamedDeleteAllVideos, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteAllVideos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteAllVideos(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteAllVideos(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAllVideoFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetAllVideoFiles() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::GetAllVideoFilesResponse>(std::bind(&WithStreamedUnaryMethod_GetAllVideoFiles<BaseClass>::StreamedGetAllVideoFiles, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetAllVideoFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAllVideoFiles(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAllVideoFilesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAllVideoFiles(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::GetAllVideoFilesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCameraCharacteristics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetCameraCharacteristics() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::GetCameraCharacteristicsRequest, ::AR51::BytesMessage>(std::bind(&WithStreamedUnaryMethod_GetCameraCharacteristics<BaseClass>::StreamedGetCameraCharacteristics, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetCameraCharacteristics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCameraCharacteristics(::grpc::ServerContext* context, const ::AR51::GetCameraCharacteristicsRequest* request, ::AR51::BytesMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCameraCharacteristics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::GetCameraCharacteristicsRequest,::AR51::BytesMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRecorderField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetRecorderField() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::GetRecorderFieldRequest, ::AR51::BytesMessage>(std::bind(&WithStreamedUnaryMethod_GetRecorderField<BaseClass>::StreamedGetRecorderField, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetRecorderField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRecorderField(::grpc::ServerContext* context, const ::AR51::GetRecorderFieldRequest* request, ::AR51::BytesMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRecorderField(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::GetRecorderFieldRequest,::AR51::BytesMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetRecorderField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetRecorderField() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::SetRecorderFieldRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetRecorderField<BaseClass>::StreamedSetRecorderField, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetRecorderField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetRecorderField(::grpc::ServerContext* context, const ::AR51::SetRecorderFieldRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetRecorderField(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::SetRecorderFieldRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetIsStreaming<WithStreamedUnaryMethod_GetHologramsEnabled<WithStreamedUnaryMethod_SetHologramsEnabled<WithStreamedUnaryMethod_GetPreviewWidth<WithStreamedUnaryMethod_SetPreviewWidth<WithStreamedUnaryMethod_GetPreviewHeight<WithStreamedUnaryMethod_SetPreviewHeight<WithStreamedUnaryMethod_GetExposureLock<WithStreamedUnaryMethod_SetExposureLock<WithStreamedUnaryMethod_GetExposureBiasMin<WithStreamedUnaryMethod_GetExposureBiasMax<WithStreamedUnaryMethod_GetExposureBias<WithStreamedUnaryMethod_SetExposureBias<WithStreamedUnaryMethod_GetAutoFocus<WithStreamedUnaryMethod_SetAutoFocus<WithStreamedUnaryMethod_GetIsRecording<WithStreamedUnaryMethod_GetIsRecordingReady<WithStreamedUnaryMethod_GetAutoExposureEnabled<WithStreamedUnaryMethod_SetAutoExposureEnabled<WithStreamedUnaryMethod_GetSensorExposureTime<WithStreamedUnaryMethod_SetSensorExposureTime<WithStreamedUnaryMethod_GetSensorSensitivity<WithStreamedUnaryMethod_SetSensorSensitivity<WithStreamedUnaryMethod_GetVideoRecordingSetting<WithStreamedUnaryMethod_StartRecording<WithStreamedUnaryMethod_StartMediaRecoder<WithStreamedUnaryMethod_StopRecording<WithStreamedUnaryMethod_DeleteVideo<WithStreamedUnaryMethod_DeleteAllVideos<WithStreamedUnaryMethod_GetAllVideoFiles<WithStreamedUnaryMethod_GetCameraCharacteristics<WithStreamedUnaryMethod_GetRecorderField<WithStreamedUnaryMethod_SetRecorderField<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_StartStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_StartStreaming() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::CameraFeedRequest, ::AR51::CameraFeedResponse>(std::bind(&WithSplitStreamingMethod_StartStreaming<BaseClass>::StreamedStartStreaming, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_StartStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartStreaming(::grpc::ServerContext* context, const ::AR51::CameraFeedRequest* request, ::grpc::ServerWriter< ::AR51::CameraFeedResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStartStreaming(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::CameraFeedRequest,::AR51::CameraFeedResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_StartRecorderStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_StartRecorderStreaming() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::Empty, ::AR51::BytesMessage>(std::bind(&WithSplitStreamingMethod_StartRecorderStreaming<BaseClass>::StreamedStartRecorderStreaming, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_StartRecorderStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartRecorderStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::BytesMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStartRecorderStreaming(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::Empty,::AR51::BytesMessage>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_DownloadVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_DownloadVideo() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::DownloadVideoRequest, ::AR51::BytesMessage>(std::bind(&WithSplitStreamingMethod_DownloadVideo<BaseClass>::StreamedDownloadVideo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_DownloadVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DownloadVideo(::grpc::ServerContext* context, const ::AR51::DownloadVideoRequest* request, ::grpc::ServerWriter< ::AR51::BytesMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedDownloadVideo(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::DownloadVideoRequest,::AR51::BytesMessage>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_StartStreaming<WithSplitStreamingMethod_StartRecorderStreaming<WithSplitStreamingMethod_DownloadVideo<Service > > > SplitStreamedService;
  typedef WithSplitStreamingMethod_StartStreaming<WithSplitStreamingMethod_StartRecorderStreaming<WithStreamedUnaryMethod_GetIsStreaming<WithStreamedUnaryMethod_GetHologramsEnabled<WithStreamedUnaryMethod_SetHologramsEnabled<WithStreamedUnaryMethod_GetPreviewWidth<WithStreamedUnaryMethod_SetPreviewWidth<WithStreamedUnaryMethod_GetPreviewHeight<WithStreamedUnaryMethod_SetPreviewHeight<WithStreamedUnaryMethod_GetExposureLock<WithStreamedUnaryMethod_SetExposureLock<WithStreamedUnaryMethod_GetExposureBiasMin<WithStreamedUnaryMethod_GetExposureBiasMax<WithStreamedUnaryMethod_GetExposureBias<WithStreamedUnaryMethod_SetExposureBias<WithStreamedUnaryMethod_GetAutoFocus<WithStreamedUnaryMethod_SetAutoFocus<WithStreamedUnaryMethod_GetIsRecording<WithStreamedUnaryMethod_GetIsRecordingReady<WithStreamedUnaryMethod_GetAutoExposureEnabled<WithStreamedUnaryMethod_SetAutoExposureEnabled<WithStreamedUnaryMethod_GetSensorExposureTime<WithStreamedUnaryMethod_SetSensorExposureTime<WithStreamedUnaryMethod_GetSensorSensitivity<WithStreamedUnaryMethod_SetSensorSensitivity<WithStreamedUnaryMethod_GetVideoRecordingSetting<WithStreamedUnaryMethod_StartRecording<WithStreamedUnaryMethod_StartMediaRecoder<WithStreamedUnaryMethod_StopRecording<WithSplitStreamingMethod_DownloadVideo<WithStreamedUnaryMethod_DeleteVideo<WithStreamedUnaryMethod_DeleteAllVideos<WithStreamedUnaryMethod_GetAllVideoFiles<WithStreamedUnaryMethod_GetCameraCharacteristics<WithStreamedUnaryMethod_GetRecorderField<WithStreamedUnaryMethod_SetRecorderField<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

// ========================================= Draw Service =======================================
class RenderService final {
 public:
  static constexpr char const* service_full_name() {
    return "AR51.RenderService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::RenderingResponse>> StartRendering(::grpc::ClientContext* context, const ::AR51::RenderingRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::RenderingResponse>>(StartRenderingRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::RenderingResponse>> AsyncStartRendering(::grpc::ClientContext* context, const ::AR51::RenderingRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::RenderingResponse>>(AsyncStartRenderingRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::RenderingResponse>> PrepareAsyncStartRendering(::grpc::ClientContext* context, const ::AR51::RenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::RenderingResponse>>(PrepareAsyncStartRenderingRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void StartRendering(::grpc::ClientContext* context, ::AR51::RenderingRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::RenderingResponse>* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientReaderInterface< ::AR51::RenderingResponse>* StartRenderingRaw(::grpc::ClientContext* context, const ::AR51::RenderingRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::RenderingResponse>* AsyncStartRenderingRaw(::grpc::ClientContext* context, const ::AR51::RenderingRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::RenderingResponse>* PrepareAsyncStartRenderingRaw(::grpc::ClientContext* context, const ::AR51::RenderingRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    std::unique_ptr< ::grpc::ClientReader< ::AR51::RenderingResponse>> StartRendering(::grpc::ClientContext* context, const ::AR51::RenderingRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::RenderingResponse>>(StartRenderingRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::RenderingResponse>> AsyncStartRendering(::grpc::ClientContext* context, const ::AR51::RenderingRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::RenderingResponse>>(AsyncStartRenderingRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::RenderingResponse>> PrepareAsyncStartRendering(::grpc::ClientContext* context, const ::AR51::RenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::RenderingResponse>>(PrepareAsyncStartRenderingRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void StartRendering(::grpc::ClientContext* context, ::AR51::RenderingRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::RenderingResponse>* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientReader< ::AR51::RenderingResponse>* StartRenderingRaw(::grpc::ClientContext* context, const ::AR51::RenderingRequest& request) override;
    ::grpc::ClientAsyncReader< ::AR51::RenderingResponse>* AsyncStartRenderingRaw(::grpc::ClientContext* context, const ::AR51::RenderingRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::RenderingResponse>* PrepareAsyncStartRenderingRaw(::grpc::ClientContext* context, const ::AR51::RenderingRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_StartRendering_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status StartRendering(::grpc::ServerContext* context, const ::AR51::RenderingRequest* request, ::grpc::ServerWriter< ::AR51::RenderingResponse>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_StartRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StartRendering() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_StartRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRendering(::grpc::ServerContext* context, const ::AR51::RenderingRequest* request, ::grpc::ServerWriter< ::AR51::RenderingResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRendering(::grpc::ServerContext* context, ::AR51::RenderingRequest* request, ::grpc::ServerAsyncWriter< ::AR51::RenderingResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_StartRendering<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StartRendering() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::RenderingRequest, ::AR51::RenderingResponse>(
          [this] { return this->StartRendering(); }));
    }
    ~ExperimentalWithCallbackMethod_StartRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRendering(::grpc::ServerContext* context, const ::AR51::RenderingRequest* request, ::grpc::ServerWriter< ::AR51::RenderingResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::RenderingRequest, ::AR51::RenderingResponse>* StartRendering() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::RenderingRequest, ::AR51::RenderingResponse>;}
  };
  typedef ExperimentalWithCallbackMethod_StartRendering<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_StartRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StartRendering() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_StartRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRendering(::grpc::ServerContext* context, const ::AR51::RenderingRequest* request, ::grpc::ServerWriter< ::AR51::RenderingResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StartRendering() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_StartRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRendering(::grpc::ServerContext* context, const ::AR51::RenderingRequest* request, ::grpc::ServerWriter< ::AR51::RenderingResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRendering(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StartRendering() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->StartRendering(); }));
    }
    ~ExperimentalWithRawCallbackMethod_StartRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRendering(::grpc::ServerContext* context, const ::AR51::RenderingRequest* request, ::grpc::ServerWriter< ::AR51::RenderingResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* StartRendering() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  typedef Service StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_StartRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_StartRendering() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::RenderingRequest, ::AR51::RenderingResponse>(std::bind(&WithSplitStreamingMethod_StartRendering<BaseClass>::StreamedStartRendering, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_StartRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartRendering(::grpc::ServerContext* context, const ::AR51::RenderingRequest* request, ::grpc::ServerWriter< ::AR51::RenderingResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStartRendering(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::RenderingRequest,::AR51::RenderingResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_StartRendering<Service > SplitStreamedService;
  typedef WithSplitStreamingMethod_StartRendering<Service > StreamedService;
};

// ========================================= Draw Service =======================================
class DrawService final {
 public:
  static constexpr char const* service_full_name() {
    return "AR51.DrawService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Line2D(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncLine2D(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncLine2DRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncLine2D(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncLine2DRaw(context, request, cq));
    }
    virtual ::grpc::Status Line3D(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncLine3D(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncLine3DRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncLine3D(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncLine3DRaw(context, request, cq));
    }
    virtual ::grpc::Status Rect(::grpc::ClientContext* context, const ::AR51::DrawRectRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncRect(::grpc::ClientContext* context, const ::AR51::DrawRectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncRectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncRect(::grpc::ClientContext* context, const ::AR51::DrawRectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncRectRaw(context, request, cq));
    }
    virtual ::grpc::Status Cube(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncCube(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncCubeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncCube(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncCubeRaw(context, request, cq));
    }
    virtual ::grpc::Status Circle(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncCircle(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncCircleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncCircle(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncCircleRaw(context, request, cq));
    }
    virtual ::grpc::Status Sphere(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSphere(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSphereRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSphere(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSphereRaw(context, request, cq));
    }
    virtual ::grpc::Status Clear(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncClear(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncClearRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncClear(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncClearRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void Line2D(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Line2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Line2D(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Line2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Line3D(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Line3D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Line3D(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Line3D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Rect(::grpc::ClientContext* context, const ::AR51::DrawRectRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Rect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Rect(::grpc::ClientContext* context, const ::AR51::DrawRectRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Rect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Cube(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Cube(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Cube(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Cube(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Circle(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Circle(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Circle(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Circle(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Sphere(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Sphere(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Sphere(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Sphere(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Clear(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Clear(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Clear(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Clear(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncLine2DRaw(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncLine2DRaw(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncLine3DRaw(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncLine3DRaw(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncRectRaw(::grpc::ClientContext* context, const ::AR51::DrawRectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncRectRaw(::grpc::ClientContext* context, const ::AR51::DrawRectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncCubeRaw(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncCubeRaw(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncCircleRaw(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncCircleRaw(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSphereRaw(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSphereRaw(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncClearRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncClearRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Line2D(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncLine2D(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncLine2DRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncLine2D(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncLine2DRaw(context, request, cq));
    }
    ::grpc::Status Line3D(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncLine3D(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncLine3DRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncLine3D(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncLine3DRaw(context, request, cq));
    }
    ::grpc::Status Rect(::grpc::ClientContext* context, const ::AR51::DrawRectRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncRect(::grpc::ClientContext* context, const ::AR51::DrawRectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncRectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncRect(::grpc::ClientContext* context, const ::AR51::DrawRectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncRectRaw(context, request, cq));
    }
    ::grpc::Status Cube(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncCube(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncCubeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncCube(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncCubeRaw(context, request, cq));
    }
    ::grpc::Status Circle(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncCircle(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncCircleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncCircle(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncCircleRaw(context, request, cq));
    }
    ::grpc::Status Sphere(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSphere(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSphereRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSphere(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSphereRaw(context, request, cq));
    }
    ::grpc::Status Clear(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncClear(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncClearRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncClear(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncClearRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Line2D(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Line2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Line2D(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Line2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Line3D(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Line3D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Line3D(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Line3D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Rect(::grpc::ClientContext* context, const ::AR51::DrawRectRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Rect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Rect(::grpc::ClientContext* context, const ::AR51::DrawRectRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Rect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Cube(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Cube(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Cube(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Cube(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Circle(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Circle(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Circle(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Circle(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Sphere(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Sphere(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Sphere(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Sphere(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Clear(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Clear(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Clear(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Clear(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncLine2DRaw(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncLine2DRaw(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncLine3DRaw(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncLine3DRaw(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncRectRaw(::grpc::ClientContext* context, const ::AR51::DrawRectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncRectRaw(::grpc::ClientContext* context, const ::AR51::DrawRectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncCubeRaw(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncCubeRaw(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncCircleRaw(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncCircleRaw(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSphereRaw(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSphereRaw(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncClearRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncClearRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Line2D_;
    const ::grpc::internal::RpcMethod rpcmethod_Line3D_;
    const ::grpc::internal::RpcMethod rpcmethod_Rect_;
    const ::grpc::internal::RpcMethod rpcmethod_Cube_;
    const ::grpc::internal::RpcMethod rpcmethod_Circle_;
    const ::grpc::internal::RpcMethod rpcmethod_Sphere_;
    const ::grpc::internal::RpcMethod rpcmethod_Clear_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Line2D(::grpc::ServerContext* context, const ::AR51::DrawLine2DRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status Line3D(::grpc::ServerContext* context, const ::AR51::DrawLine3DRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status Rect(::grpc::ServerContext* context, const ::AR51::DrawRectRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status Cube(::grpc::ServerContext* context, const ::AR51::DrawCubeRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status Circle(::grpc::ServerContext* context, const ::AR51::DrawCircleRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status Sphere(::grpc::ServerContext* context, const ::AR51::DrawSphereRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Line2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Line2D() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Line2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Line2D(::grpc::ServerContext* context, const ::AR51::DrawLine2DRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLine2D(::grpc::ServerContext* context, ::AR51::DrawLine2DRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Line3D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Line3D() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Line3D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Line3D(::grpc::ServerContext* context, const ::AR51::DrawLine3DRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLine3D(::grpc::ServerContext* context, ::AR51::DrawLine3DRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Rect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Rect() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Rect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rect(::grpc::ServerContext* context, const ::AR51::DrawRectRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRect(::grpc::ServerContext* context, ::AR51::DrawRectRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Cube : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Cube() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Cube() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Cube(::grpc::ServerContext* context, const ::AR51::DrawCubeRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCube(::grpc::ServerContext* context, ::AR51::DrawCubeRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Circle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Circle() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Circle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Circle(::grpc::ServerContext* context, const ::AR51::DrawCircleRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCircle(::grpc::ServerContext* context, ::AR51::DrawCircleRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Sphere : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Sphere() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_Sphere() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sphere(::grpc::ServerContext* context, const ::AR51::DrawSphereRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSphere(::grpc::ServerContext* context, ::AR51::DrawSphereRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Clear() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_Clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClear(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Line2D<WithAsyncMethod_Line3D<WithAsyncMethod_Rect<WithAsyncMethod_Cube<WithAsyncMethod_Circle<WithAsyncMethod_Sphere<WithAsyncMethod_Clear<Service > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Line2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Line2D() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::DrawLine2DRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::DrawLine2DRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Line2D(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Line2D(
        ::grpc::experimental::MessageAllocator< ::AR51::DrawLine2DRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::DrawLine2DRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Line2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Line2D(::grpc::ServerContext* context, const ::AR51::DrawLine2DRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Line2D(::grpc::ServerContext* context, const ::AR51::DrawLine2DRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Line3D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Line3D() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::DrawLine3DRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::DrawLine3DRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Line3D(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Line3D(
        ::grpc::experimental::MessageAllocator< ::AR51::DrawLine3DRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::DrawLine3DRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Line3D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Line3D(::grpc::ServerContext* context, const ::AR51::DrawLine3DRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Line3D(::grpc::ServerContext* context, const ::AR51::DrawLine3DRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Rect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Rect() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::DrawRectRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::DrawRectRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Rect(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Rect(
        ::grpc::experimental::MessageAllocator< ::AR51::DrawRectRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::DrawRectRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Rect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rect(::grpc::ServerContext* context, const ::AR51::DrawRectRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Rect(::grpc::ServerContext* context, const ::AR51::DrawRectRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Cube : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Cube() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::DrawCubeRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::DrawCubeRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Cube(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Cube(
        ::grpc::experimental::MessageAllocator< ::AR51::DrawCubeRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::DrawCubeRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Cube() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Cube(::grpc::ServerContext* context, const ::AR51::DrawCubeRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Cube(::grpc::ServerContext* context, const ::AR51::DrawCubeRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Circle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Circle() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::DrawCircleRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::DrawCircleRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Circle(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Circle(
        ::grpc::experimental::MessageAllocator< ::AR51::DrawCircleRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::DrawCircleRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Circle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Circle(::grpc::ServerContext* context, const ::AR51::DrawCircleRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Circle(::grpc::ServerContext* context, const ::AR51::DrawCircleRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Sphere : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Sphere() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::DrawSphereRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::DrawSphereRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Sphere(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Sphere(
        ::grpc::experimental::MessageAllocator< ::AR51::DrawSphereRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::DrawSphereRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Sphere() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sphere(::grpc::ServerContext* context, const ::AR51::DrawSphereRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Sphere(::grpc::ServerContext* context, const ::AR51::DrawSphereRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Clear() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Clear(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Clear(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_Line2D<ExperimentalWithCallbackMethod_Line3D<ExperimentalWithCallbackMethod_Rect<ExperimentalWithCallbackMethod_Cube<ExperimentalWithCallbackMethod_Circle<ExperimentalWithCallbackMethod_Sphere<ExperimentalWithCallbackMethod_Clear<Service > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Line2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Line2D() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Line2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Line2D(::grpc::ServerContext* context, const ::AR51::DrawLine2DRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Line3D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Line3D() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Line3D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Line3D(::grpc::ServerContext* context, const ::AR51::DrawLine3DRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Rect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Rect() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Rect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rect(::grpc::ServerContext* context, const ::AR51::DrawRectRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Cube : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Cube() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Cube() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Cube(::grpc::ServerContext* context, const ::AR51::DrawCubeRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Circle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Circle() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Circle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Circle(::grpc::ServerContext* context, const ::AR51::DrawCircleRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Sphere : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Sphere() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_Sphere() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sphere(::grpc::ServerContext* context, const ::AR51::DrawSphereRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Clear() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_Clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Line2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Line2D() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Line2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Line2D(::grpc::ServerContext* context, const ::AR51::DrawLine2DRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLine2D(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Line3D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Line3D() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Line3D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Line3D(::grpc::ServerContext* context, const ::AR51::DrawLine3DRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLine3D(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Rect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Rect() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Rect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rect(::grpc::ServerContext* context, const ::AR51::DrawRectRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRect(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Cube : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Cube() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Cube() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Cube(::grpc::ServerContext* context, const ::AR51::DrawCubeRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCube(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Circle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Circle() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_Circle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Circle(::grpc::ServerContext* context, const ::AR51::DrawCircleRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCircle(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Sphere : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Sphere() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_Sphere() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sphere(::grpc::ServerContext* context, const ::AR51::DrawSphereRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSphere(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Clear() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_Clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClear(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Line2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Line2D() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Line2D(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Line2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Line2D(::grpc::ServerContext* context, const ::AR51::DrawLine2DRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Line2D(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Line3D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Line3D() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Line3D(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Line3D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Line3D(::grpc::ServerContext* context, const ::AR51::DrawLine3DRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Line3D(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Rect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Rect() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Rect(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Rect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rect(::grpc::ServerContext* context, const ::AR51::DrawRectRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Rect(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Cube : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Cube() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Cube(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Cube() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Cube(::grpc::ServerContext* context, const ::AR51::DrawCubeRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Cube(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Circle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Circle() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Circle(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Circle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Circle(::grpc::ServerContext* context, const ::AR51::DrawCircleRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Circle(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Sphere : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Sphere() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Sphere(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Sphere() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sphere(::grpc::ServerContext* context, const ::AR51::DrawSphereRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Sphere(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Clear() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Clear(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Clear(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Line2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Line2D() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::DrawLine2DRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_Line2D<BaseClass>::StreamedLine2D, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Line2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Line2D(::grpc::ServerContext* context, const ::AR51::DrawLine2DRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLine2D(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::DrawLine2DRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Line3D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Line3D() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::DrawLine3DRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_Line3D<BaseClass>::StreamedLine3D, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Line3D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Line3D(::grpc::ServerContext* context, const ::AR51::DrawLine3DRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLine3D(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::DrawLine3DRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Rect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Rect() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::DrawRectRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_Rect<BaseClass>::StreamedRect, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Rect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Rect(::grpc::ServerContext* context, const ::AR51::DrawRectRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRect(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::DrawRectRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Cube : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Cube() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::DrawCubeRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_Cube<BaseClass>::StreamedCube, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Cube() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Cube(::grpc::ServerContext* context, const ::AR51::DrawCubeRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCube(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::DrawCubeRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Circle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Circle() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::DrawCircleRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_Circle<BaseClass>::StreamedCircle, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Circle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Circle(::grpc::ServerContext* context, const ::AR51::DrawCircleRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCircle(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::DrawCircleRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Sphere : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Sphere() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::DrawSphereRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_Sphere<BaseClass>::StreamedSphere, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Sphere() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Sphere(::grpc::ServerContext* context, const ::AR51::DrawSphereRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSphere(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::DrawSphereRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Clear() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_Clear<BaseClass>::StreamedClear, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClear(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Line2D<WithStreamedUnaryMethod_Line3D<WithStreamedUnaryMethod_Rect<WithStreamedUnaryMethod_Cube<WithStreamedUnaryMethod_Circle<WithStreamedUnaryMethod_Sphere<WithStreamedUnaryMethod_Clear<Service > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Line2D<WithStreamedUnaryMethod_Line3D<WithStreamedUnaryMethod_Rect<WithStreamedUnaryMethod_Cube<WithStreamedUnaryMethod_Circle<WithStreamedUnaryMethod_Sphere<WithStreamedUnaryMethod_Clear<Service > > > > > > > StreamedService;
};

// ========================================= Unity Service =======================================
class UnityService final {
 public:
  static constexpr char const* service_full_name() {
    return "AR51.UnityService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetPyTime(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Float64Message* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>> AsyncGetPyTime(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>>(AsyncGetPyTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>> PrepareAsyncGetPyTime(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>>(PrepareAsyncGetPyTimeRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Float64Message* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>> AsyncGetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>>(AsyncGetPyTimeOffsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>> PrepareAsyncGetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>>(PrepareAsyncGetPyTimeOffsetRaw(context, request, cq));
    }
    virtual ::grpc::Status SetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Float64Message& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Float64Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetPyTimeOffsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Float64Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetPyTimeOffsetRaw(context, request, cq));
    }
    virtual ::grpc::Status Instantiate(::grpc::ClientContext* context, const ::AR51::InstantiateRequest& request, ::AR51::ObjectIdMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>> AsyncInstantiate(::grpc::ClientContext* context, const ::AR51::InstantiateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>>(AsyncInstantiateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>> PrepareAsyncInstantiate(::grpc::ClientContext* context, const ::AR51::InstantiateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>>(PrepareAsyncInstantiateRaw(context, request, cq));
    }
    virtual ::grpc::Status FindGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::AR51::ObjectIdMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>> AsyncFindGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>>(AsyncFindGameObjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>> PrepareAsyncFindGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>>(PrepareAsyncFindGameObjectRaw(context, request, cq));
    }
    virtual ::grpc::Status FindAnchorGameObject(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::AR51::ObjectIdMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>> AsyncFindAnchorGameObject(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>>(AsyncFindAnchorGameObjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>> PrepareAsyncFindAnchorGameObject(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>>(PrepareAsyncFindAnchorGameObjectRaw(context, request, cq));
    }
    virtual ::grpc::Status GetMainCamera(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::ObjectIdMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>> AsyncGetMainCamera(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>>(AsyncGetMainCameraRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>> PrepareAsyncGetMainCamera(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>>(PrepareAsyncGetMainCameraRaw(context, request, cq));
    }
    virtual ::grpc::Status Destroy(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncDestroy(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncDestroyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncDestroy(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncDestroyRaw(context, request, cq));
    }
    virtual ::grpc::Status CreatePrimitive(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest& request, ::AR51::ObjectIdMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>> AsyncCreatePrimitive(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>>(AsyncCreatePrimitiveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>> PrepareAsyncCreatePrimitive(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>>(PrepareAsyncCreatePrimitiveRaw(context, request, cq));
    }
    virtual ::grpc::Status NewGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::AR51::ObjectIdMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>> AsyncNewGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>>(AsyncNewGameObjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>> PrepareAsyncNewGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>>(PrepareAsyncNewGameObjectRaw(context, request, cq));
    }
    virtual ::grpc::Status ClearInstances(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncClearInstances(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncClearInstancesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncClearInstances(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncClearInstancesRaw(context, request, cq));
    }
    virtual ::grpc::Status SetParent(::grpc::ClientContext* context, const ::AR51::SetParentRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetParent(::grpc::ClientContext* context, const ::AR51::SetParentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetParentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetParent(::grpc::ClientContext* context, const ::AR51::SetParentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetParentRaw(context, request, cq));
    }
    virtual ::grpc::Status GetName(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::AR51::NameRequest* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::NameRequest>> AsyncGetName(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::NameRequest>>(AsyncGetNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::NameRequest>> PrepareAsyncGetName(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::NameRequest>>(PrepareAsyncGetNameRaw(context, request, cq));
    }
    virtual ::grpc::Status SetName(::grpc::ClientContext* context, const ::AR51::SetNameRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetName(::grpc::ClientContext* context, const ::AR51::SetNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetName(::grpc::ClientContext* context, const ::AR51::SetNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetNameRaw(context, request, cq));
    }
    virtual ::grpc::Status GetActive(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::AR51::ActiveMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ActiveMessage>> AsyncGetActive(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ActiveMessage>>(AsyncGetActiveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ActiveMessage>> PrepareAsyncGetActive(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ActiveMessage>>(PrepareAsyncGetActiveRaw(context, request, cq));
    }
    virtual ::grpc::Status SetActive(::grpc::ClientContext* context, const ::AR51::ActiveMessage& request, ::AR51::ActiveMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ActiveMessage>> AsyncSetActive(::grpc::ClientContext* context, const ::AR51::ActiveMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ActiveMessage>>(AsyncSetActiveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ActiveMessage>> PrepareAsyncSetActive(::grpc::ClientContext* context, const ::AR51::ActiveMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ActiveMessage>>(PrepareAsyncSetActiveRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::AR51::TransformMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::TransformMessage>> AsyncGetTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::TransformMessage>>(AsyncGetTransformRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::TransformMessage>> PrepareAsyncGetTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::TransformMessage>>(PrepareAsyncGetTransformRaw(context, request, cq));
    }
    virtual ::grpc::Status SetTransform(::grpc::ClientContext* context, const ::AR51::SetTransformRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetTransform(::grpc::ClientContext* context, const ::AR51::SetTransformRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetTransformRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetTransform(::grpc::ClientContext* context, const ::AR51::SetTransformRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetTransformRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::TransformMessage>> StreamTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::TransformMessage>>(StreamTransformRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::TransformMessage>> AsyncStreamTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::TransformMessage>>(AsyncStreamTransformRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::TransformMessage>> PrepareAsyncStreamTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::TransformMessage>>(PrepareAsyncStreamTransformRaw(context, request, cq));
    }
    virtual ::grpc::Status GetComponent(::grpc::ClientContext* context, const ::AR51::ComponentRequest& request, ::AR51::ObjectIdMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>> AsyncGetComponent(::grpc::ClientContext* context, const ::AR51::ComponentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>>(AsyncGetComponentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>> PrepareAsyncGetComponent(::grpc::ClientContext* context, const ::AR51::ComponentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>>(PrepareAsyncGetComponentRaw(context, request, cq));
    }
    virtual ::grpc::Status GetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::AR51::ComponentFieldMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ComponentFieldMessage>> AsyncGetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ComponentFieldMessage>>(AsyncGetComponentFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ComponentFieldMessage>> PrepareAsyncGetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ComponentFieldMessage>>(PrepareAsyncGetComponentFieldRaw(context, request, cq));
    }
    virtual ::grpc::Status SetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetComponentFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetComponentFieldRaw(context, request, cq));
    }
    virtual ::grpc::Status SetCameraProject(::grpc::ClientContext* context, const ::AR51::TransformMessage& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetCameraProject(::grpc::ClientContext* context, const ::AR51::TransformMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetCameraProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetCameraProject(::grpc::ClientContext* context, const ::AR51::TransformMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetCameraProjectRaw(context, request, cq));
    }
    virtual ::grpc::Status SetRendererEnabled(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetRendererEnabled(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetRendererEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetRendererEnabled(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetRendererEnabledRaw(context, request, cq));
    }
    virtual ::grpc::Status SetMaterialTexture(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetMaterialTexture(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetMaterialTextureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetMaterialTexture(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetMaterialTextureRaw(context, request, cq));
    }
    virtual ::grpc::Status SetMaterialInt32(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetMaterialInt32(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetMaterialInt32Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetMaterialInt32(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetMaterialInt32Raw(context, request, cq));
    }
    virtual ::grpc::Status SetMaterialFloat(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetMaterialFloat(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetMaterialFloatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetMaterialFloat(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetMaterialFloatRaw(context, request, cq));
    }
    virtual ::grpc::Status SetMaterialColor(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetMaterialColor(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetMaterialColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetMaterialColor(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetMaterialColorRaw(context, request, cq));
    }
    virtual ::grpc::Status GetMaterialColor(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest& request, ::AR51::Color* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Color>> AsyncGetMaterialColor(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Color>>(AsyncGetMaterialColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Color>> PrepareAsyncGetMaterialColor(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Color>>(PrepareAsyncGetMaterialColorRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void GetPyTime(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPyTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPyTime(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetPyTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPyTimeOffset(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetPyTimeOffset(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Float64Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPyTimeOffset(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Float64Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetPyTimeOffset(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Instantiate(::grpc::ClientContext* context, const ::AR51::InstantiateRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Instantiate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Instantiate(::grpc::ClientContext* context, const ::AR51::InstantiateRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Instantiate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void FindGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FindGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FindGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void FindGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void FindAnchorGameObject(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FindAnchorGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FindAnchorGameObject(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void FindAnchorGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMainCamera(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMainCamera(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMainCamera(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMainCamera(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Destroy(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Destroy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Destroy(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Destroy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CreatePrimitive(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreatePrimitive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreatePrimitive(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CreatePrimitive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void NewGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NewGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NewGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void NewGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ClearInstances(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ClearInstances(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ClearInstances(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ClearInstances(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetParent(::grpc::ClientContext* context, const ::AR51::SetParentRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetParent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetParent(::grpc::ClientContext* context, const ::AR51::SetParentRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetParent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetName(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::NameRequest* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::NameRequest* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetName(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::NameRequest* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::NameRequest* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetName(::grpc::ClientContext* context, const ::AR51::SetNameRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetName(::grpc::ClientContext* context, const ::AR51::SetNameRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetActive(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::ActiveMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetActive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ActiveMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetActive(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::ActiveMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetActive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ActiveMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetActive(::grpc::ClientContext* context, const ::AR51::ActiveMessage* request, ::AR51::ActiveMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetActive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ActiveMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetActive(::grpc::ClientContext* context, const ::AR51::ActiveMessage* request, ::AR51::ActiveMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetActive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ActiveMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest* request, ::AR51::TransformMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTransform(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::TransformMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest* request, ::AR51::TransformMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetTransform(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::TransformMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetTransform(::grpc::ClientContext* context, const ::AR51::SetTransformRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetTransform(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetTransform(::grpc::ClientContext* context, const ::AR51::SetTransformRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetTransform(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StreamTransform(::grpc::ClientContext* context, ::AR51::GetTransformRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::TransformMessage>* reactor) = 0;
      virtual void GetComponent(::grpc::ClientContext* context, const ::AR51::ComponentRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetComponent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetComponent(::grpc::ClientContext* context, const ::AR51::ComponentRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetComponent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::ComponentFieldMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetComponentField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ComponentFieldMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::ComponentFieldMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetComponentField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ComponentFieldMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetComponentField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetComponentField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetCameraProject(::grpc::ClientContext* context, const ::AR51::TransformMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCameraProject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCameraProject(::grpc::ClientContext* context, const ::AR51::TransformMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetCameraProject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetRendererEnabled(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRendererEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRendererEnabled(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetRendererEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetMaterialTexture(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetMaterialTexture(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetMaterialTexture(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetMaterialTexture(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetMaterialInt32(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetMaterialInt32(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetMaterialInt32(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetMaterialInt32(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetMaterialFloat(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetMaterialFloat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetMaterialFloat(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetMaterialFloat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetMaterialColor(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetMaterialColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetMaterialColor(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetMaterialColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMaterialColor(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest* request, ::AR51::Color* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMaterialColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Color* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMaterialColor(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest* request, ::AR51::Color* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMaterialColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Color* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>* AsyncGetPyTimeRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>* PrepareAsyncGetPyTimeRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>* AsyncGetPyTimeOffsetRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Float64Message>* PrepareAsyncGetPyTimeOffsetRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetPyTimeOffsetRaw(::grpc::ClientContext* context, const ::AR51::Float64Message& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetPyTimeOffsetRaw(::grpc::ClientContext* context, const ::AR51::Float64Message& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>* AsyncInstantiateRaw(::grpc::ClientContext* context, const ::AR51::InstantiateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>* PrepareAsyncInstantiateRaw(::grpc::ClientContext* context, const ::AR51::InstantiateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>* AsyncFindGameObjectRaw(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>* PrepareAsyncFindGameObjectRaw(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>* AsyncFindAnchorGameObjectRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>* PrepareAsyncFindAnchorGameObjectRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>* AsyncGetMainCameraRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>* PrepareAsyncGetMainCameraRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncDestroyRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncDestroyRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>* AsyncCreatePrimitiveRaw(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>* PrepareAsyncCreatePrimitiveRaw(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>* AsyncNewGameObjectRaw(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>* PrepareAsyncNewGameObjectRaw(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncClearInstancesRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncClearInstancesRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetParentRaw(::grpc::ClientContext* context, const ::AR51::SetParentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetParentRaw(::grpc::ClientContext* context, const ::AR51::SetParentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::NameRequest>* AsyncGetNameRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::NameRequest>* PrepareAsyncGetNameRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetNameRaw(::grpc::ClientContext* context, const ::AR51::SetNameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetNameRaw(::grpc::ClientContext* context, const ::AR51::SetNameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ActiveMessage>* AsyncGetActiveRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ActiveMessage>* PrepareAsyncGetActiveRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ActiveMessage>* AsyncSetActiveRaw(::grpc::ClientContext* context, const ::AR51::ActiveMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ActiveMessage>* PrepareAsyncSetActiveRaw(::grpc::ClientContext* context, const ::AR51::ActiveMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::TransformMessage>* AsyncGetTransformRaw(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::TransformMessage>* PrepareAsyncGetTransformRaw(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetTransformRaw(::grpc::ClientContext* context, const ::AR51::SetTransformRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetTransformRaw(::grpc::ClientContext* context, const ::AR51::SetTransformRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::AR51::TransformMessage>* StreamTransformRaw(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::TransformMessage>* AsyncStreamTransformRaw(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::TransformMessage>* PrepareAsyncStreamTransformRaw(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>* AsyncGetComponentRaw(::grpc::ClientContext* context, const ::AR51::ComponentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ObjectIdMessage>* PrepareAsyncGetComponentRaw(::grpc::ClientContext* context, const ::AR51::ComponentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ComponentFieldMessage>* AsyncGetComponentFieldRaw(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::ComponentFieldMessage>* PrepareAsyncGetComponentFieldRaw(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetComponentFieldRaw(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetComponentFieldRaw(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetCameraProjectRaw(::grpc::ClientContext* context, const ::AR51::TransformMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetCameraProjectRaw(::grpc::ClientContext* context, const ::AR51::TransformMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetRendererEnabledRaw(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetRendererEnabledRaw(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetMaterialTextureRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetMaterialTextureRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetMaterialInt32Raw(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetMaterialInt32Raw(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetMaterialFloatRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetMaterialFloatRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetMaterialColorRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetMaterialColorRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Color>* AsyncGetMaterialColorRaw(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Color>* PrepareAsyncGetMaterialColorRaw(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetPyTime(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Float64Message* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>> AsyncGetPyTime(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>>(AsyncGetPyTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>> PrepareAsyncGetPyTime(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>>(PrepareAsyncGetPyTimeRaw(context, request, cq));
    }
    ::grpc::Status GetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Float64Message* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>> AsyncGetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>>(AsyncGetPyTimeOffsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>> PrepareAsyncGetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>>(PrepareAsyncGetPyTimeOffsetRaw(context, request, cq));
    }
    ::grpc::Status SetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Float64Message& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Float64Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetPyTimeOffsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Float64Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetPyTimeOffsetRaw(context, request, cq));
    }
    ::grpc::Status Instantiate(::grpc::ClientContext* context, const ::AR51::InstantiateRequest& request, ::AR51::ObjectIdMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>> AsyncInstantiate(::grpc::ClientContext* context, const ::AR51::InstantiateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>>(AsyncInstantiateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>> PrepareAsyncInstantiate(::grpc::ClientContext* context, const ::AR51::InstantiateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>>(PrepareAsyncInstantiateRaw(context, request, cq));
    }
    ::grpc::Status FindGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::AR51::ObjectIdMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>> AsyncFindGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>>(AsyncFindGameObjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>> PrepareAsyncFindGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>>(PrepareAsyncFindGameObjectRaw(context, request, cq));
    }
    ::grpc::Status FindAnchorGameObject(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::AR51::ObjectIdMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>> AsyncFindAnchorGameObject(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>>(AsyncFindAnchorGameObjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>> PrepareAsyncFindAnchorGameObject(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>>(PrepareAsyncFindAnchorGameObjectRaw(context, request, cq));
    }
    ::grpc::Status GetMainCamera(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::ObjectIdMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>> AsyncGetMainCamera(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>>(AsyncGetMainCameraRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>> PrepareAsyncGetMainCamera(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>>(PrepareAsyncGetMainCameraRaw(context, request, cq));
    }
    ::grpc::Status Destroy(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncDestroy(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncDestroyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncDestroy(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncDestroyRaw(context, request, cq));
    }
    ::grpc::Status CreatePrimitive(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest& request, ::AR51::ObjectIdMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>> AsyncCreatePrimitive(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>>(AsyncCreatePrimitiveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>> PrepareAsyncCreatePrimitive(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>>(PrepareAsyncCreatePrimitiveRaw(context, request, cq));
    }
    ::grpc::Status NewGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::AR51::ObjectIdMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>> AsyncNewGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>>(AsyncNewGameObjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>> PrepareAsyncNewGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>>(PrepareAsyncNewGameObjectRaw(context, request, cq));
    }
    ::grpc::Status ClearInstances(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncClearInstances(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncClearInstancesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncClearInstances(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncClearInstancesRaw(context, request, cq));
    }
    ::grpc::Status SetParent(::grpc::ClientContext* context, const ::AR51::SetParentRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetParent(::grpc::ClientContext* context, const ::AR51::SetParentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetParentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetParent(::grpc::ClientContext* context, const ::AR51::SetParentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetParentRaw(context, request, cq));
    }
    ::grpc::Status GetName(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::AR51::NameRequest* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::NameRequest>> AsyncGetName(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::NameRequest>>(AsyncGetNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::NameRequest>> PrepareAsyncGetName(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::NameRequest>>(PrepareAsyncGetNameRaw(context, request, cq));
    }
    ::grpc::Status SetName(::grpc::ClientContext* context, const ::AR51::SetNameRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetName(::grpc::ClientContext* context, const ::AR51::SetNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetName(::grpc::ClientContext* context, const ::AR51::SetNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetNameRaw(context, request, cq));
    }
    ::grpc::Status GetActive(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::AR51::ActiveMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ActiveMessage>> AsyncGetActive(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ActiveMessage>>(AsyncGetActiveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ActiveMessage>> PrepareAsyncGetActive(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ActiveMessage>>(PrepareAsyncGetActiveRaw(context, request, cq));
    }
    ::grpc::Status SetActive(::grpc::ClientContext* context, const ::AR51::ActiveMessage& request, ::AR51::ActiveMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ActiveMessage>> AsyncSetActive(::grpc::ClientContext* context, const ::AR51::ActiveMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ActiveMessage>>(AsyncSetActiveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ActiveMessage>> PrepareAsyncSetActive(::grpc::ClientContext* context, const ::AR51::ActiveMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ActiveMessage>>(PrepareAsyncSetActiveRaw(context, request, cq));
    }
    ::grpc::Status GetTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::AR51::TransformMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::TransformMessage>> AsyncGetTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::TransformMessage>>(AsyncGetTransformRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::TransformMessage>> PrepareAsyncGetTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::TransformMessage>>(PrepareAsyncGetTransformRaw(context, request, cq));
    }
    ::grpc::Status SetTransform(::grpc::ClientContext* context, const ::AR51::SetTransformRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetTransform(::grpc::ClientContext* context, const ::AR51::SetTransformRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetTransformRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetTransform(::grpc::ClientContext* context, const ::AR51::SetTransformRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetTransformRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::AR51::TransformMessage>> StreamTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::TransformMessage>>(StreamTransformRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::TransformMessage>> AsyncStreamTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::TransformMessage>>(AsyncStreamTransformRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::TransformMessage>> PrepareAsyncStreamTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::TransformMessage>>(PrepareAsyncStreamTransformRaw(context, request, cq));
    }
    ::grpc::Status GetComponent(::grpc::ClientContext* context, const ::AR51::ComponentRequest& request, ::AR51::ObjectIdMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>> AsyncGetComponent(::grpc::ClientContext* context, const ::AR51::ComponentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>>(AsyncGetComponentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>> PrepareAsyncGetComponent(::grpc::ClientContext* context, const ::AR51::ComponentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>>(PrepareAsyncGetComponentRaw(context, request, cq));
    }
    ::grpc::Status GetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::AR51::ComponentFieldMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ComponentFieldMessage>> AsyncGetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ComponentFieldMessage>>(AsyncGetComponentFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ComponentFieldMessage>> PrepareAsyncGetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::ComponentFieldMessage>>(PrepareAsyncGetComponentFieldRaw(context, request, cq));
    }
    ::grpc::Status SetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetComponentFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetComponentFieldRaw(context, request, cq));
    }
    ::grpc::Status SetCameraProject(::grpc::ClientContext* context, const ::AR51::TransformMessage& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetCameraProject(::grpc::ClientContext* context, const ::AR51::TransformMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetCameraProjectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetCameraProject(::grpc::ClientContext* context, const ::AR51::TransformMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetCameraProjectRaw(context, request, cq));
    }
    ::grpc::Status SetRendererEnabled(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetRendererEnabled(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetRendererEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetRendererEnabled(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetRendererEnabledRaw(context, request, cq));
    }
    ::grpc::Status SetMaterialTexture(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetMaterialTexture(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetMaterialTextureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetMaterialTexture(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetMaterialTextureRaw(context, request, cq));
    }
    ::grpc::Status SetMaterialInt32(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetMaterialInt32(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetMaterialInt32Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetMaterialInt32(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetMaterialInt32Raw(context, request, cq));
    }
    ::grpc::Status SetMaterialFloat(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetMaterialFloat(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetMaterialFloatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetMaterialFloat(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetMaterialFloatRaw(context, request, cq));
    }
    ::grpc::Status SetMaterialColor(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetMaterialColor(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetMaterialColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetMaterialColor(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetMaterialColorRaw(context, request, cq));
    }
    ::grpc::Status GetMaterialColor(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest& request, ::AR51::Color* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Color>> AsyncGetMaterialColor(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Color>>(AsyncGetMaterialColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Color>> PrepareAsyncGetMaterialColor(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Color>>(PrepareAsyncGetMaterialColorRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetPyTime(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) override;
      void GetPyTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) override;
      void GetPyTime(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetPyTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) override;
      void GetPyTimeOffset(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)>) override;
      void GetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetPyTimeOffset(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Float64Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetPyTimeOffset(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Float64Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetPyTimeOffset(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Instantiate(::grpc::ClientContext* context, const ::AR51::InstantiateRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) override;
      void Instantiate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) override;
      void Instantiate(::grpc::ClientContext* context, const ::AR51::InstantiateRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Instantiate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void FindGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) override;
      void FindGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) override;
      void FindGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void FindGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void FindAnchorGameObject(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) override;
      void FindAnchorGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) override;
      void FindAnchorGameObject(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void FindAnchorGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMainCamera(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) override;
      void GetMainCamera(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) override;
      void GetMainCamera(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMainCamera(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Destroy(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Destroy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Destroy(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Destroy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreatePrimitive(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) override;
      void CreatePrimitive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) override;
      void CreatePrimitive(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreatePrimitive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void NewGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) override;
      void NewGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) override;
      void NewGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void NewGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ClearInstances(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void ClearInstances(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void ClearInstances(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ClearInstances(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetParent(::grpc::ClientContext* context, const ::AR51::SetParentRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetParent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetParent(::grpc::ClientContext* context, const ::AR51::SetParentRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetParent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetName(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::NameRequest* response, std::function<void(::grpc::Status)>) override;
      void GetName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::NameRequest* response, std::function<void(::grpc::Status)>) override;
      void GetName(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::NameRequest* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::NameRequest* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetName(::grpc::ClientContext* context, const ::AR51::SetNameRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetName(::grpc::ClientContext* context, const ::AR51::SetNameRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetActive(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::ActiveMessage* response, std::function<void(::grpc::Status)>) override;
      void GetActive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ActiveMessage* response, std::function<void(::grpc::Status)>) override;
      void GetActive(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::ActiveMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetActive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ActiveMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetActive(::grpc::ClientContext* context, const ::AR51::ActiveMessage* request, ::AR51::ActiveMessage* response, std::function<void(::grpc::Status)>) override;
      void SetActive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ActiveMessage* response, std::function<void(::grpc::Status)>) override;
      void SetActive(::grpc::ClientContext* context, const ::AR51::ActiveMessage* request, ::AR51::ActiveMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetActive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ActiveMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest* request, ::AR51::TransformMessage* response, std::function<void(::grpc::Status)>) override;
      void GetTransform(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::TransformMessage* response, std::function<void(::grpc::Status)>) override;
      void GetTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest* request, ::AR51::TransformMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetTransform(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::TransformMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetTransform(::grpc::ClientContext* context, const ::AR51::SetTransformRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetTransform(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetTransform(::grpc::ClientContext* context, const ::AR51::SetTransformRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetTransform(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StreamTransform(::grpc::ClientContext* context, ::AR51::GetTransformRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::TransformMessage>* reactor) override;
      void GetComponent(::grpc::ClientContext* context, const ::AR51::ComponentRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) override;
      void GetComponent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)>) override;
      void GetComponent(::grpc::ClientContext* context, const ::AR51::ComponentRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetComponent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::ComponentFieldMessage* response, std::function<void(::grpc::Status)>) override;
      void GetComponentField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ComponentFieldMessage* response, std::function<void(::grpc::Status)>) override;
      void GetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::ComponentFieldMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetComponentField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ComponentFieldMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetComponentField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetComponentField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetCameraProject(::grpc::ClientContext* context, const ::AR51::TransformMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetCameraProject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetCameraProject(::grpc::ClientContext* context, const ::AR51::TransformMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetCameraProject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetRendererEnabled(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetRendererEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetRendererEnabled(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetRendererEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetMaterialTexture(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetMaterialTexture(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetMaterialTexture(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetMaterialTexture(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetMaterialInt32(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetMaterialInt32(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetMaterialInt32(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetMaterialInt32(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetMaterialFloat(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetMaterialFloat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetMaterialFloat(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetMaterialFloat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetMaterialColor(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetMaterialColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetMaterialColor(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetMaterialColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMaterialColor(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest* request, ::AR51::Color* response, std::function<void(::grpc::Status)>) override;
      void GetMaterialColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Color* response, std::function<void(::grpc::Status)>) override;
      void GetMaterialColor(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest* request, ::AR51::Color* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMaterialColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Color* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* AsyncGetPyTimeRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* PrepareAsyncGetPyTimeRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* AsyncGetPyTimeOffsetRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* PrepareAsyncGetPyTimeOffsetRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetPyTimeOffsetRaw(::grpc::ClientContext* context, const ::AR51::Float64Message& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetPyTimeOffsetRaw(::grpc::ClientContext* context, const ::AR51::Float64Message& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* AsyncInstantiateRaw(::grpc::ClientContext* context, const ::AR51::InstantiateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* PrepareAsyncInstantiateRaw(::grpc::ClientContext* context, const ::AR51::InstantiateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* AsyncFindGameObjectRaw(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* PrepareAsyncFindGameObjectRaw(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* AsyncFindAnchorGameObjectRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* PrepareAsyncFindAnchorGameObjectRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* AsyncGetMainCameraRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* PrepareAsyncGetMainCameraRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncDestroyRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncDestroyRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* AsyncCreatePrimitiveRaw(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* PrepareAsyncCreatePrimitiveRaw(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* AsyncNewGameObjectRaw(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* PrepareAsyncNewGameObjectRaw(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncClearInstancesRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncClearInstancesRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetParentRaw(::grpc::ClientContext* context, const ::AR51::SetParentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetParentRaw(::grpc::ClientContext* context, const ::AR51::SetParentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::NameRequest>* AsyncGetNameRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::NameRequest>* PrepareAsyncGetNameRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetNameRaw(::grpc::ClientContext* context, const ::AR51::SetNameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetNameRaw(::grpc::ClientContext* context, const ::AR51::SetNameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ActiveMessage>* AsyncGetActiveRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ActiveMessage>* PrepareAsyncGetActiveRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ActiveMessage>* AsyncSetActiveRaw(::grpc::ClientContext* context, const ::AR51::ActiveMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ActiveMessage>* PrepareAsyncSetActiveRaw(::grpc::ClientContext* context, const ::AR51::ActiveMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::TransformMessage>* AsyncGetTransformRaw(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::TransformMessage>* PrepareAsyncGetTransformRaw(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetTransformRaw(::grpc::ClientContext* context, const ::AR51::SetTransformRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetTransformRaw(::grpc::ClientContext* context, const ::AR51::SetTransformRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::AR51::TransformMessage>* StreamTransformRaw(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request) override;
    ::grpc::ClientAsyncReader< ::AR51::TransformMessage>* AsyncStreamTransformRaw(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::TransformMessage>* PrepareAsyncStreamTransformRaw(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* AsyncGetComponentRaw(::grpc::ClientContext* context, const ::AR51::ComponentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* PrepareAsyncGetComponentRaw(::grpc::ClientContext* context, const ::AR51::ComponentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ComponentFieldMessage>* AsyncGetComponentFieldRaw(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::ComponentFieldMessage>* PrepareAsyncGetComponentFieldRaw(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetComponentFieldRaw(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetComponentFieldRaw(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetCameraProjectRaw(::grpc::ClientContext* context, const ::AR51::TransformMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetCameraProjectRaw(::grpc::ClientContext* context, const ::AR51::TransformMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetRendererEnabledRaw(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetRendererEnabledRaw(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetMaterialTextureRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetMaterialTextureRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetMaterialInt32Raw(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetMaterialInt32Raw(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetMaterialFloatRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetMaterialFloatRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetMaterialColorRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetMaterialColorRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Color>* AsyncGetMaterialColorRaw(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Color>* PrepareAsyncGetMaterialColorRaw(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetPyTime_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPyTimeOffset_;
    const ::grpc::internal::RpcMethod rpcmethod_SetPyTimeOffset_;
    const ::grpc::internal::RpcMethod rpcmethod_Instantiate_;
    const ::grpc::internal::RpcMethod rpcmethod_FindGameObject_;
    const ::grpc::internal::RpcMethod rpcmethod_FindAnchorGameObject_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMainCamera_;
    const ::grpc::internal::RpcMethod rpcmethod_Destroy_;
    const ::grpc::internal::RpcMethod rpcmethod_CreatePrimitive_;
    const ::grpc::internal::RpcMethod rpcmethod_NewGameObject_;
    const ::grpc::internal::RpcMethod rpcmethod_ClearInstances_;
    const ::grpc::internal::RpcMethod rpcmethod_SetParent_;
    const ::grpc::internal::RpcMethod rpcmethod_GetName_;
    const ::grpc::internal::RpcMethod rpcmethod_SetName_;
    const ::grpc::internal::RpcMethod rpcmethod_GetActive_;
    const ::grpc::internal::RpcMethod rpcmethod_SetActive_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTransform_;
    const ::grpc::internal::RpcMethod rpcmethod_SetTransform_;
    const ::grpc::internal::RpcMethod rpcmethod_StreamTransform_;
    const ::grpc::internal::RpcMethod rpcmethod_GetComponent_;
    const ::grpc::internal::RpcMethod rpcmethod_GetComponentField_;
    const ::grpc::internal::RpcMethod rpcmethod_SetComponentField_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCameraProject_;
    const ::grpc::internal::RpcMethod rpcmethod_SetRendererEnabled_;
    const ::grpc::internal::RpcMethod rpcmethod_SetMaterialTexture_;
    const ::grpc::internal::RpcMethod rpcmethod_SetMaterialInt32_;
    const ::grpc::internal::RpcMethod rpcmethod_SetMaterialFloat_;
    const ::grpc::internal::RpcMethod rpcmethod_SetMaterialColor_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMaterialColor_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetPyTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response);
    virtual ::grpc::Status GetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response);
    virtual ::grpc::Status SetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Float64Message* request, ::AR51::Empty* response);
    virtual ::grpc::Status Instantiate(::grpc::ServerContext* context, const ::AR51::InstantiateRequest* request, ::AR51::ObjectIdMessage* response);
    virtual ::grpc::Status FindGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response);
    virtual ::grpc::Status FindAnchorGameObject(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::ObjectIdMessage* response);
    virtual ::grpc::Status GetMainCamera(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::ObjectIdMessage* response);
    virtual ::grpc::Status Destroy(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::Empty* response);
    virtual ::grpc::Status CreatePrimitive(::grpc::ServerContext* context, const ::AR51::CreatePrimitiveRequest* request, ::AR51::ObjectIdMessage* response);
    virtual ::grpc::Status NewGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response);
    virtual ::grpc::Status ClearInstances(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response);
    virtual ::grpc::Status SetParent(::grpc::ServerContext* context, const ::AR51::SetParentRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status GetName(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::NameRequest* response);
    virtual ::grpc::Status SetName(::grpc::ServerContext* context, const ::AR51::SetNameRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status GetActive(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::ActiveMessage* response);
    virtual ::grpc::Status SetActive(::grpc::ServerContext* context, const ::AR51::ActiveMessage* request, ::AR51::ActiveMessage* response);
    virtual ::grpc::Status GetTransform(::grpc::ServerContext* context, const ::AR51::GetTransformRequest* request, ::AR51::TransformMessage* response);
    virtual ::grpc::Status SetTransform(::grpc::ServerContext* context, const ::AR51::SetTransformRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status StreamTransform(::grpc::ServerContext* context, const ::AR51::GetTransformRequest* request, ::grpc::ServerWriter< ::AR51::TransformMessage>* writer);
    virtual ::grpc::Status GetComponent(::grpc::ServerContext* context, const ::AR51::ComponentRequest* request, ::AR51::ObjectIdMessage* response);
    virtual ::grpc::Status GetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::ComponentFieldMessage* response);
    virtual ::grpc::Status SetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::Empty* response);
    virtual ::grpc::Status SetCameraProject(::grpc::ServerContext* context, const ::AR51::TransformMessage* request, ::AR51::Empty* response);
    virtual ::grpc::Status SetRendererEnabled(::grpc::ServerContext* context, const ::AR51::SetRendererEnabledRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status SetMaterialTexture(::grpc::ServerContext* context, const ::AR51::SetMaterialTextureRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status SetMaterialInt32(::grpc::ServerContext* context, const ::AR51::SetMaterialInt32Request* request, ::AR51::Empty* response);
    virtual ::grpc::Status SetMaterialFloat(::grpc::ServerContext* context, const ::AR51::SetMaterialFloatRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status SetMaterialColor(::grpc::ServerContext* context, const ::AR51::SetMaterialColorRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status GetMaterialColor(::grpc::ServerContext* context, const ::AR51::GetMaterialColorRequest* request, ::AR51::Color* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPyTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetPyTime() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetPyTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPyTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPyTime(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Float64Message>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPyTimeOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetPyTimeOffset() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetPyTimeOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPyTimeOffset(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Float64Message>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPyTimeOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetPyTimeOffset() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SetPyTimeOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Float64Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPyTimeOffset(::grpc::ServerContext* context, ::AR51::Float64Message* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Instantiate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Instantiate() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Instantiate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Instantiate(::grpc::ServerContext* context, const ::AR51::InstantiateRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInstantiate(::grpc::ServerContext* context, ::AR51::InstantiateRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::ObjectIdMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FindGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_FindGameObject() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_FindGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindGameObject(::grpc::ServerContext* context, ::AR51::NameRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::ObjectIdMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FindAnchorGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_FindAnchorGameObject() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_FindAnchorGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindAnchorGameObject(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindAnchorGameObject(::grpc::ServerContext* context, ::AR51::AnchorRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::ObjectIdMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMainCamera : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetMainCamera() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetMainCamera() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMainCamera(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMainCamera(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::ObjectIdMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Destroy() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_Destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Destroy(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroy(::grpc::ServerContext* context, ::AR51::ObjectIdMessage* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreatePrimitive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CreatePrimitive() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_CreatePrimitive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreatePrimitive(::grpc::ServerContext* context, const ::AR51::CreatePrimitiveRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreatePrimitive(::grpc::ServerContext* context, ::AR51::CreatePrimitiveRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::ObjectIdMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NewGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_NewGameObject() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_NewGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNewGameObject(::grpc::ServerContext* context, ::AR51::NameRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::ObjectIdMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ClearInstances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ClearInstances() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_ClearInstances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearInstances(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearInstances(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetParent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetParent() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_SetParent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetParent(::grpc::ServerContext* context, const ::AR51::SetParentRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetParent(::grpc::ServerContext* context, ::AR51::SetParentRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetName() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_GetName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetName(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::NameRequest* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetName(::grpc::ServerContext* context, ::AR51::ObjectIdMessage* request, ::grpc::ServerAsyncResponseWriter< ::AR51::NameRequest>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetName() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_SetName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetName(::grpc::ServerContext* context, const ::AR51::SetNameRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetName(::grpc::ServerContext* context, ::AR51::SetNameRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetActive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetActive() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_GetActive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActive(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::ActiveMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActive(::grpc::ServerContext* context, ::AR51::ObjectIdMessage* request, ::grpc::ServerAsyncResponseWriter< ::AR51::ActiveMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetActive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetActive() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_SetActive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetActive(::grpc::ServerContext* context, const ::AR51::ActiveMessage* request, ::AR51::ActiveMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetActive(::grpc::ServerContext* context, ::AR51::ActiveMessage* request, ::grpc::ServerAsyncResponseWriter< ::AR51::ActiveMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetTransform() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_GetTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransform(::grpc::ServerContext* context, const ::AR51::GetTransformRequest* request, ::AR51::TransformMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTransform(::grpc::ServerContext* context, ::AR51::GetTransformRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::TransformMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetTransform() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_SetTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTransform(::grpc::ServerContext* context, const ::AR51::SetTransformRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTransform(::grpc::ServerContext* context, ::AR51::SetTransformRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StreamTransform() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_StreamTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamTransform(::grpc::ServerContext* context, const ::AR51::GetTransformRequest* request, ::grpc::ServerWriter< ::AR51::TransformMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamTransform(::grpc::ServerContext* context, ::AR51::GetTransformRequest* request, ::grpc::ServerAsyncWriter< ::AR51::TransformMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(18, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetComponent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetComponent() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_GetComponent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetComponent(::grpc::ServerContext* context, const ::AR51::ComponentRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetComponent(::grpc::ServerContext* context, ::AR51::ComponentRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::ObjectIdMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetComponentField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetComponentField() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_GetComponentField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::ComponentFieldMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetComponentField(::grpc::ServerContext* context, ::AR51::ComponentFieldMessage* request, ::grpc::ServerAsyncResponseWriter< ::AR51::ComponentFieldMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetComponentField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetComponentField() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_SetComponentField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetComponentField(::grpc::ServerContext* context, ::AR51::ComponentFieldMessage* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCameraProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetCameraProject() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_SetCameraProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCameraProject(::grpc::ServerContext* context, const ::AR51::TransformMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCameraProject(::grpc::ServerContext* context, ::AR51::TransformMessage* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRendererEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetRendererEnabled() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_SetRendererEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRendererEnabled(::grpc::ServerContext* context, const ::AR51::SetRendererEnabledRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRendererEnabled(::grpc::ServerContext* context, ::AR51::SetRendererEnabledRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetMaterialTexture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetMaterialTexture() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_SetMaterialTexture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialTexture(::grpc::ServerContext* context, const ::AR51::SetMaterialTextureRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetMaterialTexture(::grpc::ServerContext* context, ::AR51::SetMaterialTextureRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetMaterialInt32 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetMaterialInt32() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_SetMaterialInt32() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialInt32(::grpc::ServerContext* context, const ::AR51::SetMaterialInt32Request* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetMaterialInt32(::grpc::ServerContext* context, ::AR51::SetMaterialInt32Request* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetMaterialFloat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetMaterialFloat() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_SetMaterialFloat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialFloat(::grpc::ServerContext* context, const ::AR51::SetMaterialFloatRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetMaterialFloat(::grpc::ServerContext* context, ::AR51::SetMaterialFloatRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetMaterialColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetMaterialColor() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_SetMaterialColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialColor(::grpc::ServerContext* context, const ::AR51::SetMaterialColorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetMaterialColor(::grpc::ServerContext* context, ::AR51::SetMaterialColorRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMaterialColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetMaterialColor() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_GetMaterialColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMaterialColor(::grpc::ServerContext* context, const ::AR51::GetMaterialColorRequest* request, ::AR51::Color* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMaterialColor(::grpc::ServerContext* context, ::AR51::GetMaterialColorRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Color>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetPyTime<WithAsyncMethod_GetPyTimeOffset<WithAsyncMethod_SetPyTimeOffset<WithAsyncMethod_Instantiate<WithAsyncMethod_FindGameObject<WithAsyncMethod_FindAnchorGameObject<WithAsyncMethod_GetMainCamera<WithAsyncMethod_Destroy<WithAsyncMethod_CreatePrimitive<WithAsyncMethod_NewGameObject<WithAsyncMethod_ClearInstances<WithAsyncMethod_SetParent<WithAsyncMethod_GetName<WithAsyncMethod_SetName<WithAsyncMethod_GetActive<WithAsyncMethod_SetActive<WithAsyncMethod_GetTransform<WithAsyncMethod_SetTransform<WithAsyncMethod_StreamTransform<WithAsyncMethod_GetComponent<WithAsyncMethod_GetComponentField<WithAsyncMethod_SetComponentField<WithAsyncMethod_SetCameraProject<WithAsyncMethod_SetRendererEnabled<WithAsyncMethod_SetMaterialTexture<WithAsyncMethod_SetMaterialInt32<WithAsyncMethod_SetMaterialFloat<WithAsyncMethod_SetMaterialColor<WithAsyncMethod_GetMaterialColor<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetPyTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetPyTime() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Float64Message>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Float64Message* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetPyTime(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetPyTime(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Float64Message>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Float64Message>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetPyTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPyTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetPyTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetPyTimeOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetPyTimeOffset() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Float64Message>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Float64Message* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetPyTimeOffset(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetPyTimeOffset(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Float64Message>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Float64Message>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetPyTimeOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetPyTimeOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetPyTimeOffset() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Float64Message, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Float64Message* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetPyTimeOffset(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetPyTimeOffset(
        ::grpc::experimental::MessageAllocator< ::AR51::Float64Message, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Float64Message, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetPyTimeOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Float64Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Float64Message* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Instantiate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Instantiate() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::InstantiateRequest, ::AR51::ObjectIdMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::InstantiateRequest* request,
                 ::AR51::ObjectIdMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Instantiate(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Instantiate(
        ::grpc::experimental::MessageAllocator< ::AR51::InstantiateRequest, ::AR51::ObjectIdMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::InstantiateRequest, ::AR51::ObjectIdMessage>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Instantiate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Instantiate(::grpc::ServerContext* context, const ::AR51::InstantiateRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Instantiate(::grpc::ServerContext* context, const ::AR51::InstantiateRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FindGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_FindGameObject() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::NameRequest, ::AR51::ObjectIdMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::NameRequest* request,
                 ::AR51::ObjectIdMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->FindGameObject(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_FindGameObject(
        ::grpc::experimental::MessageAllocator< ::AR51::NameRequest, ::AR51::ObjectIdMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::NameRequest, ::AR51::ObjectIdMessage>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FindGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void FindGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FindAnchorGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_FindAnchorGameObject() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::AnchorRequest, ::AR51::ObjectIdMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::AnchorRequest* request,
                 ::AR51::ObjectIdMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->FindAnchorGameObject(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_FindAnchorGameObject(
        ::grpc::experimental::MessageAllocator< ::AR51::AnchorRequest, ::AR51::ObjectIdMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::AnchorRequest, ::AR51::ObjectIdMessage>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FindAnchorGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindAnchorGameObject(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void FindAnchorGameObject(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetMainCamera : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetMainCamera() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::ObjectIdMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::ObjectIdMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetMainCamera(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetMainCamera(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::ObjectIdMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::ObjectIdMessage>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetMainCamera() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMainCamera(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMainCamera(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Destroy() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::ObjectIdMessage, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::ObjectIdMessage* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Destroy(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Destroy(
        ::grpc::experimental::MessageAllocator< ::AR51::ObjectIdMessage, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::ObjectIdMessage, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Destroy(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Destroy(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreatePrimitive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CreatePrimitive() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CreatePrimitiveRequest, ::AR51::ObjectIdMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::CreatePrimitiveRequest* request,
                 ::AR51::ObjectIdMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CreatePrimitive(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CreatePrimitive(
        ::grpc::experimental::MessageAllocator< ::AR51::CreatePrimitiveRequest, ::AR51::ObjectIdMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CreatePrimitiveRequest, ::AR51::ObjectIdMessage>*>(
          ::grpc::Service::experimental().GetHandler(8))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreatePrimitive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreatePrimitive(::grpc::ServerContext* context, const ::AR51::CreatePrimitiveRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreatePrimitive(::grpc::ServerContext* context, const ::AR51::CreatePrimitiveRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NewGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_NewGameObject() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::NameRequest, ::AR51::ObjectIdMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::NameRequest* request,
                 ::AR51::ObjectIdMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->NewGameObject(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_NewGameObject(
        ::grpc::experimental::MessageAllocator< ::AR51::NameRequest, ::AR51::ObjectIdMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::NameRequest, ::AR51::ObjectIdMessage>*>(
          ::grpc::Service::experimental().GetHandler(9))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NewGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void NewGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ClearInstances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ClearInstances() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ClearInstances(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ClearInstances(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(10))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ClearInstances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearInstances(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ClearInstances(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetParent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetParent() {
      ::grpc::Service::experimental().MarkMethodCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetParentRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::SetParentRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetParent(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetParent(
        ::grpc::experimental::MessageAllocator< ::AR51::SetParentRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetParentRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(11))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetParent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetParent(::grpc::ServerContext* context, const ::AR51::SetParentRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetParent(::grpc::ServerContext* context, const ::AR51::SetParentRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetName() {
      ::grpc::Service::experimental().MarkMethodCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::ObjectIdMessage, ::AR51::NameRequest>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::ObjectIdMessage* request,
                 ::AR51::NameRequest* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetName(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetName(
        ::grpc::experimental::MessageAllocator< ::AR51::ObjectIdMessage, ::AR51::NameRequest>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::ObjectIdMessage, ::AR51::NameRequest>*>(
          ::grpc::Service::experimental().GetHandler(12))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetName(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::NameRequest* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetName(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::NameRequest* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetName() {
      ::grpc::Service::experimental().MarkMethodCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetNameRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::SetNameRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetName(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetName(
        ::grpc::experimental::MessageAllocator< ::AR51::SetNameRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetNameRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(13))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetName(::grpc::ServerContext* context, const ::AR51::SetNameRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetName(::grpc::ServerContext* context, const ::AR51::SetNameRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetActive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetActive() {
      ::grpc::Service::experimental().MarkMethodCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::ObjectIdMessage, ::AR51::ActiveMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::ObjectIdMessage* request,
                 ::AR51::ActiveMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetActive(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetActive(
        ::grpc::experimental::MessageAllocator< ::AR51::ObjectIdMessage, ::AR51::ActiveMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::ObjectIdMessage, ::AR51::ActiveMessage>*>(
          ::grpc::Service::experimental().GetHandler(14))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetActive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActive(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::ActiveMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetActive(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::ActiveMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetActive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetActive() {
      ::grpc::Service::experimental().MarkMethodCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::ActiveMessage, ::AR51::ActiveMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::ActiveMessage* request,
                 ::AR51::ActiveMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetActive(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetActive(
        ::grpc::experimental::MessageAllocator< ::AR51::ActiveMessage, ::AR51::ActiveMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::ActiveMessage, ::AR51::ActiveMessage>*>(
          ::grpc::Service::experimental().GetHandler(15))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetActive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetActive(::grpc::ServerContext* context, const ::AR51::ActiveMessage* request, ::AR51::ActiveMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetActive(::grpc::ServerContext* context, const ::AR51::ActiveMessage* request, ::AR51::ActiveMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetTransform() {
      ::grpc::Service::experimental().MarkMethodCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GetTransformRequest, ::AR51::TransformMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::GetTransformRequest* request,
                 ::AR51::TransformMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetTransform(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetTransform(
        ::grpc::experimental::MessageAllocator< ::AR51::GetTransformRequest, ::AR51::TransformMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GetTransformRequest, ::AR51::TransformMessage>*>(
          ::grpc::Service::experimental().GetHandler(16))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransform(::grpc::ServerContext* context, const ::AR51::GetTransformRequest* request, ::AR51::TransformMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetTransform(::grpc::ServerContext* context, const ::AR51::GetTransformRequest* request, ::AR51::TransformMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetTransform() {
      ::grpc::Service::experimental().MarkMethodCallback(17,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetTransformRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::SetTransformRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetTransform(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetTransform(
        ::grpc::experimental::MessageAllocator< ::AR51::SetTransformRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetTransformRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(17))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTransform(::grpc::ServerContext* context, const ::AR51::SetTransformRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetTransform(::grpc::ServerContext* context, const ::AR51::SetTransformRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StreamTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StreamTransform() {
      ::grpc::Service::experimental().MarkMethodCallback(18,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::GetTransformRequest, ::AR51::TransformMessage>(
          [this] { return this->StreamTransform(); }));
    }
    ~ExperimentalWithCallbackMethod_StreamTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamTransform(::grpc::ServerContext* context, const ::AR51::GetTransformRequest* request, ::grpc::ServerWriter< ::AR51::TransformMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::GetTransformRequest, ::AR51::TransformMessage>* StreamTransform() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::GetTransformRequest, ::AR51::TransformMessage>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetComponent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetComponent() {
      ::grpc::Service::experimental().MarkMethodCallback(19,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::ComponentRequest, ::AR51::ObjectIdMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::ComponentRequest* request,
                 ::AR51::ObjectIdMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetComponent(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetComponent(
        ::grpc::experimental::MessageAllocator< ::AR51::ComponentRequest, ::AR51::ObjectIdMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::ComponentRequest, ::AR51::ObjectIdMessage>*>(
          ::grpc::Service::experimental().GetHandler(19))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetComponent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetComponent(::grpc::ServerContext* context, const ::AR51::ComponentRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetComponent(::grpc::ServerContext* context, const ::AR51::ComponentRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetComponentField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetComponentField() {
      ::grpc::Service::experimental().MarkMethodCallback(20,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::ComponentFieldMessage, ::AR51::ComponentFieldMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::ComponentFieldMessage* request,
                 ::AR51::ComponentFieldMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetComponentField(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetComponentField(
        ::grpc::experimental::MessageAllocator< ::AR51::ComponentFieldMessage, ::AR51::ComponentFieldMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::ComponentFieldMessage, ::AR51::ComponentFieldMessage>*>(
          ::grpc::Service::experimental().GetHandler(20))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetComponentField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::ComponentFieldMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::ComponentFieldMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetComponentField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetComponentField() {
      ::grpc::Service::experimental().MarkMethodCallback(21,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::ComponentFieldMessage, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::ComponentFieldMessage* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetComponentField(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetComponentField(
        ::grpc::experimental::MessageAllocator< ::AR51::ComponentFieldMessage, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::ComponentFieldMessage, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(21))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetComponentField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetCameraProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetCameraProject() {
      ::grpc::Service::experimental().MarkMethodCallback(22,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::TransformMessage, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::TransformMessage* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetCameraProject(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetCameraProject(
        ::grpc::experimental::MessageAllocator< ::AR51::TransformMessage, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::TransformMessage, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(22))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetCameraProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCameraProject(::grpc::ServerContext* context, const ::AR51::TransformMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetCameraProject(::grpc::ServerContext* context, const ::AR51::TransformMessage* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetRendererEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetRendererEnabled() {
      ::grpc::Service::experimental().MarkMethodCallback(23,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetRendererEnabledRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::SetRendererEnabledRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetRendererEnabled(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetRendererEnabled(
        ::grpc::experimental::MessageAllocator< ::AR51::SetRendererEnabledRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetRendererEnabledRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(23))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetRendererEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRendererEnabled(::grpc::ServerContext* context, const ::AR51::SetRendererEnabledRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetRendererEnabled(::grpc::ServerContext* context, const ::AR51::SetRendererEnabledRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetMaterialTexture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetMaterialTexture() {
      ::grpc::Service::experimental().MarkMethodCallback(24,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetMaterialTextureRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::SetMaterialTextureRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetMaterialTexture(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetMaterialTexture(
        ::grpc::experimental::MessageAllocator< ::AR51::SetMaterialTextureRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetMaterialTextureRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(24))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetMaterialTexture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialTexture(::grpc::ServerContext* context, const ::AR51::SetMaterialTextureRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetMaterialTexture(::grpc::ServerContext* context, const ::AR51::SetMaterialTextureRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetMaterialInt32 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetMaterialInt32() {
      ::grpc::Service::experimental().MarkMethodCallback(25,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetMaterialInt32Request, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::SetMaterialInt32Request* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetMaterialInt32(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetMaterialInt32(
        ::grpc::experimental::MessageAllocator< ::AR51::SetMaterialInt32Request, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetMaterialInt32Request, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(25))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetMaterialInt32() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialInt32(::grpc::ServerContext* context, const ::AR51::SetMaterialInt32Request* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetMaterialInt32(::grpc::ServerContext* context, const ::AR51::SetMaterialInt32Request* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetMaterialFloat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetMaterialFloat() {
      ::grpc::Service::experimental().MarkMethodCallback(26,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetMaterialFloatRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::SetMaterialFloatRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetMaterialFloat(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetMaterialFloat(
        ::grpc::experimental::MessageAllocator< ::AR51::SetMaterialFloatRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetMaterialFloatRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(26))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetMaterialFloat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialFloat(::grpc::ServerContext* context, const ::AR51::SetMaterialFloatRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetMaterialFloat(::grpc::ServerContext* context, const ::AR51::SetMaterialFloatRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetMaterialColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetMaterialColor() {
      ::grpc::Service::experimental().MarkMethodCallback(27,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetMaterialColorRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::SetMaterialColorRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetMaterialColor(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetMaterialColor(
        ::grpc::experimental::MessageAllocator< ::AR51::SetMaterialColorRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetMaterialColorRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(27))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetMaterialColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialColor(::grpc::ServerContext* context, const ::AR51::SetMaterialColorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetMaterialColor(::grpc::ServerContext* context, const ::AR51::SetMaterialColorRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetMaterialColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetMaterialColor() {
      ::grpc::Service::experimental().MarkMethodCallback(28,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GetMaterialColorRequest, ::AR51::Color>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::GetMaterialColorRequest* request,
                 ::AR51::Color* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetMaterialColor(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetMaterialColor(
        ::grpc::experimental::MessageAllocator< ::AR51::GetMaterialColorRequest, ::AR51::Color>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GetMaterialColorRequest, ::AR51::Color>*>(
          ::grpc::Service::experimental().GetHandler(28))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetMaterialColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMaterialColor(::grpc::ServerContext* context, const ::AR51::GetMaterialColorRequest* request, ::AR51::Color* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMaterialColor(::grpc::ServerContext* context, const ::AR51::GetMaterialColorRequest* request, ::AR51::Color* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_GetPyTime<ExperimentalWithCallbackMethod_GetPyTimeOffset<ExperimentalWithCallbackMethod_SetPyTimeOffset<ExperimentalWithCallbackMethod_Instantiate<ExperimentalWithCallbackMethod_FindGameObject<ExperimentalWithCallbackMethod_FindAnchorGameObject<ExperimentalWithCallbackMethod_GetMainCamera<ExperimentalWithCallbackMethod_Destroy<ExperimentalWithCallbackMethod_CreatePrimitive<ExperimentalWithCallbackMethod_NewGameObject<ExperimentalWithCallbackMethod_ClearInstances<ExperimentalWithCallbackMethod_SetParent<ExperimentalWithCallbackMethod_GetName<ExperimentalWithCallbackMethod_SetName<ExperimentalWithCallbackMethod_GetActive<ExperimentalWithCallbackMethod_SetActive<ExperimentalWithCallbackMethod_GetTransform<ExperimentalWithCallbackMethod_SetTransform<ExperimentalWithCallbackMethod_StreamTransform<ExperimentalWithCallbackMethod_GetComponent<ExperimentalWithCallbackMethod_GetComponentField<ExperimentalWithCallbackMethod_SetComponentField<ExperimentalWithCallbackMethod_SetCameraProject<ExperimentalWithCallbackMethod_SetRendererEnabled<ExperimentalWithCallbackMethod_SetMaterialTexture<ExperimentalWithCallbackMethod_SetMaterialInt32<ExperimentalWithCallbackMethod_SetMaterialFloat<ExperimentalWithCallbackMethod_SetMaterialColor<ExperimentalWithCallbackMethod_GetMaterialColor<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetPyTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetPyTime() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetPyTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPyTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPyTimeOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetPyTimeOffset() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetPyTimeOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetPyTimeOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetPyTimeOffset() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SetPyTimeOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Float64Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Instantiate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Instantiate() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Instantiate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Instantiate(::grpc::ServerContext* context, const ::AR51::InstantiateRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FindGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_FindGameObject() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_FindGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FindAnchorGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_FindAnchorGameObject() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_FindAnchorGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindAnchorGameObject(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMainCamera : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetMainCamera() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetMainCamera() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMainCamera(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Destroy() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_Destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Destroy(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreatePrimitive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CreatePrimitive() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_CreatePrimitive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreatePrimitive(::grpc::ServerContext* context, const ::AR51::CreatePrimitiveRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NewGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_NewGameObject() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_NewGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ClearInstances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ClearInstances() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_ClearInstances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearInstances(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetParent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetParent() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_SetParent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetParent(::grpc::ServerContext* context, const ::AR51::SetParentRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetName() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_GetName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetName(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::NameRequest* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetName() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_SetName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetName(::grpc::ServerContext* context, const ::AR51::SetNameRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetActive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetActive() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_GetActive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActive(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::ActiveMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetActive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetActive() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_SetActive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetActive(::grpc::ServerContext* context, const ::AR51::ActiveMessage* request, ::AR51::ActiveMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetTransform() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_GetTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransform(::grpc::ServerContext* context, const ::AR51::GetTransformRequest* request, ::AR51::TransformMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetTransform() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_SetTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTransform(::grpc::ServerContext* context, const ::AR51::SetTransformRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StreamTransform() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_StreamTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamTransform(::grpc::ServerContext* context, const ::AR51::GetTransformRequest* request, ::grpc::ServerWriter< ::AR51::TransformMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetComponent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetComponent() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_GetComponent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetComponent(::grpc::ServerContext* context, const ::AR51::ComponentRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetComponentField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetComponentField() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_GetComponentField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::ComponentFieldMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetComponentField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetComponentField() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_SetComponentField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCameraProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetCameraProject() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_SetCameraProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCameraProject(::grpc::ServerContext* context, const ::AR51::TransformMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRendererEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetRendererEnabled() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_SetRendererEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRendererEnabled(::grpc::ServerContext* context, const ::AR51::SetRendererEnabledRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetMaterialTexture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetMaterialTexture() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_SetMaterialTexture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialTexture(::grpc::ServerContext* context, const ::AR51::SetMaterialTextureRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetMaterialInt32 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetMaterialInt32() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_SetMaterialInt32() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialInt32(::grpc::ServerContext* context, const ::AR51::SetMaterialInt32Request* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetMaterialFloat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetMaterialFloat() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_SetMaterialFloat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialFloat(::grpc::ServerContext* context, const ::AR51::SetMaterialFloatRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetMaterialColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetMaterialColor() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_SetMaterialColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialColor(::grpc::ServerContext* context, const ::AR51::SetMaterialColorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMaterialColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetMaterialColor() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_GetMaterialColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMaterialColor(::grpc::ServerContext* context, const ::AR51::GetMaterialColorRequest* request, ::AR51::Color* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPyTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetPyTime() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetPyTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPyTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPyTime(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPyTimeOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetPyTimeOffset() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetPyTimeOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPyTimeOffset(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPyTimeOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetPyTimeOffset() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SetPyTimeOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Float64Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPyTimeOffset(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Instantiate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Instantiate() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Instantiate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Instantiate(::grpc::ServerContext* context, const ::AR51::InstantiateRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInstantiate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FindGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_FindGameObject() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_FindGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindGameObject(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FindAnchorGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_FindAnchorGameObject() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_FindAnchorGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindAnchorGameObject(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindAnchorGameObject(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMainCamera : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetMainCamera() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetMainCamera() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMainCamera(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMainCamera(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Destroy() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_Destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Destroy(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroy(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreatePrimitive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CreatePrimitive() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_CreatePrimitive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreatePrimitive(::grpc::ServerContext* context, const ::AR51::CreatePrimitiveRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreatePrimitive(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NewGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_NewGameObject() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_NewGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNewGameObject(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ClearInstances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ClearInstances() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_ClearInstances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearInstances(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearInstances(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetParent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetParent() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_SetParent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetParent(::grpc::ServerContext* context, const ::AR51::SetParentRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetParent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetName() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_GetName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetName(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::NameRequest* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetName(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetName() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_SetName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetName(::grpc::ServerContext* context, const ::AR51::SetNameRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetName(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetActive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetActive() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_GetActive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActive(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::ActiveMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActive(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetActive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetActive() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_SetActive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetActive(::grpc::ServerContext* context, const ::AR51::ActiveMessage* request, ::AR51::ActiveMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetActive(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetTransform() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_GetTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransform(::grpc::ServerContext* context, const ::AR51::GetTransformRequest* request, ::AR51::TransformMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTransform(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetTransform() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_SetTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTransform(::grpc::ServerContext* context, const ::AR51::SetTransformRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTransform(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StreamTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StreamTransform() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_StreamTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamTransform(::grpc::ServerContext* context, const ::AR51::GetTransformRequest* request, ::grpc::ServerWriter< ::AR51::TransformMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamTransform(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(18, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetComponent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetComponent() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_GetComponent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetComponent(::grpc::ServerContext* context, const ::AR51::ComponentRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetComponent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetComponentField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetComponentField() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_GetComponentField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::ComponentFieldMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetComponentField(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetComponentField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetComponentField() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_SetComponentField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetComponentField(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCameraProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetCameraProject() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_SetCameraProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCameraProject(::grpc::ServerContext* context, const ::AR51::TransformMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCameraProject(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetRendererEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetRendererEnabled() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_SetRendererEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRendererEnabled(::grpc::ServerContext* context, const ::AR51::SetRendererEnabledRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRendererEnabled(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetMaterialTexture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetMaterialTexture() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_SetMaterialTexture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialTexture(::grpc::ServerContext* context, const ::AR51::SetMaterialTextureRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetMaterialTexture(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetMaterialInt32 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetMaterialInt32() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_SetMaterialInt32() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialInt32(::grpc::ServerContext* context, const ::AR51::SetMaterialInt32Request* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetMaterialInt32(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetMaterialFloat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetMaterialFloat() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_SetMaterialFloat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialFloat(::grpc::ServerContext* context, const ::AR51::SetMaterialFloatRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetMaterialFloat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetMaterialColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetMaterialColor() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_SetMaterialColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialColor(::grpc::ServerContext* context, const ::AR51::SetMaterialColorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetMaterialColor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMaterialColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetMaterialColor() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_GetMaterialColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMaterialColor(::grpc::ServerContext* context, const ::AR51::GetMaterialColorRequest* request, ::AR51::Color* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMaterialColor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetPyTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetPyTime() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetPyTime(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetPyTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPyTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetPyTime(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetPyTimeOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetPyTimeOffset() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetPyTimeOffset(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetPyTimeOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetPyTimeOffset(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetPyTimeOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetPyTimeOffset() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetPyTimeOffset(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetPyTimeOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Float64Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetPyTimeOffset(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Instantiate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Instantiate() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Instantiate(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Instantiate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Instantiate(::grpc::ServerContext* context, const ::AR51::InstantiateRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Instantiate(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FindGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_FindGameObject() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->FindGameObject(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_FindGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void FindGameObject(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FindAnchorGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_FindAnchorGameObject() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->FindAnchorGameObject(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_FindAnchorGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindAnchorGameObject(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void FindAnchorGameObject(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetMainCamera : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetMainCamera() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetMainCamera(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetMainCamera() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMainCamera(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMainCamera(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Destroy() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Destroy(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Destroy(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Destroy(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreatePrimitive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CreatePrimitive() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CreatePrimitive(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CreatePrimitive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreatePrimitive(::grpc::ServerContext* context, const ::AR51::CreatePrimitiveRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreatePrimitive(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NewGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_NewGameObject() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->NewGameObject(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_NewGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void NewGameObject(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ClearInstances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ClearInstances() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ClearInstances(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ClearInstances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearInstances(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ClearInstances(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetParent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetParent() {
      ::grpc::Service::experimental().MarkMethodRawCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetParent(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetParent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetParent(::grpc::ServerContext* context, const ::AR51::SetParentRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetParent(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetName() {
      ::grpc::Service::experimental().MarkMethodRawCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetName(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetName(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::NameRequest* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetName(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetName() {
      ::grpc::Service::experimental().MarkMethodRawCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetName(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetName(::grpc::ServerContext* context, const ::AR51::SetNameRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetName(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetActive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetActive() {
      ::grpc::Service::experimental().MarkMethodRawCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetActive(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetActive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActive(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::ActiveMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetActive(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetActive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetActive() {
      ::grpc::Service::experimental().MarkMethodRawCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetActive(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetActive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetActive(::grpc::ServerContext* context, const ::AR51::ActiveMessage* request, ::AR51::ActiveMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetActive(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetTransform() {
      ::grpc::Service::experimental().MarkMethodRawCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetTransform(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransform(::grpc::ServerContext* context, const ::AR51::GetTransformRequest* request, ::AR51::TransformMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetTransform(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetTransform() {
      ::grpc::Service::experimental().MarkMethodRawCallback(17,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetTransform(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTransform(::grpc::ServerContext* context, const ::AR51::SetTransformRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetTransform(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StreamTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StreamTransform() {
      ::grpc::Service::experimental().MarkMethodRawCallback(18,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->StreamTransform(); }));
    }
    ~ExperimentalWithRawCallbackMethod_StreamTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamTransform(::grpc::ServerContext* context, const ::AR51::GetTransformRequest* request, ::grpc::ServerWriter< ::AR51::TransformMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* StreamTransform() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetComponent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetComponent() {
      ::grpc::Service::experimental().MarkMethodRawCallback(19,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetComponent(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetComponent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetComponent(::grpc::ServerContext* context, const ::AR51::ComponentRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetComponent(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetComponentField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetComponentField() {
      ::grpc::Service::experimental().MarkMethodRawCallback(20,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetComponentField(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetComponentField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::ComponentFieldMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetComponentField(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetComponentField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetComponentField() {
      ::grpc::Service::experimental().MarkMethodRawCallback(21,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetComponentField(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetComponentField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetComponentField(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetCameraProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetCameraProject() {
      ::grpc::Service::experimental().MarkMethodRawCallback(22,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetCameraProject(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetCameraProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCameraProject(::grpc::ServerContext* context, const ::AR51::TransformMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetCameraProject(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetRendererEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetRendererEnabled() {
      ::grpc::Service::experimental().MarkMethodRawCallback(23,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetRendererEnabled(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetRendererEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRendererEnabled(::grpc::ServerContext* context, const ::AR51::SetRendererEnabledRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetRendererEnabled(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetMaterialTexture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetMaterialTexture() {
      ::grpc::Service::experimental().MarkMethodRawCallback(24,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetMaterialTexture(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetMaterialTexture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialTexture(::grpc::ServerContext* context, const ::AR51::SetMaterialTextureRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetMaterialTexture(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetMaterialInt32 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetMaterialInt32() {
      ::grpc::Service::experimental().MarkMethodRawCallback(25,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetMaterialInt32(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetMaterialInt32() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialInt32(::grpc::ServerContext* context, const ::AR51::SetMaterialInt32Request* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetMaterialInt32(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetMaterialFloat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetMaterialFloat() {
      ::grpc::Service::experimental().MarkMethodRawCallback(26,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetMaterialFloat(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetMaterialFloat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialFloat(::grpc::ServerContext* context, const ::AR51::SetMaterialFloatRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetMaterialFloat(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetMaterialColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetMaterialColor() {
      ::grpc::Service::experimental().MarkMethodRawCallback(27,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetMaterialColor(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetMaterialColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaterialColor(::grpc::ServerContext* context, const ::AR51::SetMaterialColorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetMaterialColor(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetMaterialColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetMaterialColor() {
      ::grpc::Service::experimental().MarkMethodRawCallback(28,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetMaterialColor(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetMaterialColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMaterialColor(::grpc::ServerContext* context, const ::AR51::GetMaterialColorRequest* request, ::AR51::Color* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMaterialColor(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPyTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetPyTime() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Float64Message>(std::bind(&WithStreamedUnaryMethod_GetPyTime<BaseClass>::StreamedGetPyTime, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetPyTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPyTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPyTime(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Float64Message>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPyTimeOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetPyTimeOffset() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Float64Message>(std::bind(&WithStreamedUnaryMethod_GetPyTimeOffset<BaseClass>::StreamedGetPyTimeOffset, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetPyTimeOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPyTimeOffset(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Float64Message>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPyTimeOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetPyTimeOffset() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Float64Message, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetPyTimeOffset<BaseClass>::StreamedSetPyTimeOffset, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetPyTimeOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Float64Message* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPyTimeOffset(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Float64Message,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Instantiate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Instantiate() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::InstantiateRequest, ::AR51::ObjectIdMessage>(std::bind(&WithStreamedUnaryMethod_Instantiate<BaseClass>::StreamedInstantiate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Instantiate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Instantiate(::grpc::ServerContext* context, const ::AR51::InstantiateRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInstantiate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::InstantiateRequest,::AR51::ObjectIdMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FindGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_FindGameObject() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::NameRequest, ::AR51::ObjectIdMessage>(std::bind(&WithStreamedUnaryMethod_FindGameObject<BaseClass>::StreamedFindGameObject, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_FindGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FindGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFindGameObject(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::NameRequest,::AR51::ObjectIdMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FindAnchorGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_FindAnchorGameObject() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::AnchorRequest, ::AR51::ObjectIdMessage>(std::bind(&WithStreamedUnaryMethod_FindAnchorGameObject<BaseClass>::StreamedFindAnchorGameObject, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_FindAnchorGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FindAnchorGameObject(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFindAnchorGameObject(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::AnchorRequest,::AR51::ObjectIdMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMainCamera : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetMainCamera() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::ObjectIdMessage>(std::bind(&WithStreamedUnaryMethod_GetMainCamera<BaseClass>::StreamedGetMainCamera, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetMainCamera() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMainCamera(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMainCamera(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::ObjectIdMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Destroy() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::ObjectIdMessage, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_Destroy<BaseClass>::StreamedDestroy, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Destroy(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDestroy(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::ObjectIdMessage,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreatePrimitive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CreatePrimitive() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::CreatePrimitiveRequest, ::AR51::ObjectIdMessage>(std::bind(&WithStreamedUnaryMethod_CreatePrimitive<BaseClass>::StreamedCreatePrimitive, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreatePrimitive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreatePrimitive(::grpc::ServerContext* context, const ::AR51::CreatePrimitiveRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreatePrimitive(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::CreatePrimitiveRequest,::AR51::ObjectIdMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NewGameObject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_NewGameObject() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::NameRequest, ::AR51::ObjectIdMessage>(std::bind(&WithStreamedUnaryMethod_NewGameObject<BaseClass>::StreamedNewGameObject, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_NewGameObject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NewGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNewGameObject(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::NameRequest,::AR51::ObjectIdMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ClearInstances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ClearInstances() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_ClearInstances<BaseClass>::StreamedClearInstances, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ClearInstances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ClearInstances(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClearInstances(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetParent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetParent() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::SetParentRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetParent<BaseClass>::StreamedSetParent, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetParent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetParent(::grpc::ServerContext* context, const ::AR51::SetParentRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetParent(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::SetParentRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetName() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::ObjectIdMessage, ::AR51::NameRequest>(std::bind(&WithStreamedUnaryMethod_GetName<BaseClass>::StreamedGetName, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetName(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::NameRequest* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetName(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::ObjectIdMessage,::AR51::NameRequest>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetName() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::SetNameRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetName<BaseClass>::StreamedSetName, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetName(::grpc::ServerContext* context, const ::AR51::SetNameRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetName(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::SetNameRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetActive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetActive() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::ObjectIdMessage, ::AR51::ActiveMessage>(std::bind(&WithStreamedUnaryMethod_GetActive<BaseClass>::StreamedGetActive, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetActive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetActive(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::ActiveMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetActive(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::ObjectIdMessage,::AR51::ActiveMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetActive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetActive() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::ActiveMessage, ::AR51::ActiveMessage>(std::bind(&WithStreamedUnaryMethod_SetActive<BaseClass>::StreamedSetActive, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetActive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetActive(::grpc::ServerContext* context, const ::AR51::ActiveMessage* request, ::AR51::ActiveMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetActive(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::ActiveMessage,::AR51::ActiveMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetTransform() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::GetTransformRequest, ::AR51::TransformMessage>(std::bind(&WithStreamedUnaryMethod_GetTransform<BaseClass>::StreamedGetTransform, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTransform(::grpc::ServerContext* context, const ::AR51::GetTransformRequest* request, ::AR51::TransformMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTransform(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::GetTransformRequest,::AR51::TransformMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetTransform() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::SetTransformRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetTransform<BaseClass>::StreamedSetTransform, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetTransform(::grpc::ServerContext* context, const ::AR51::SetTransformRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetTransform(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::SetTransformRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetComponent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetComponent() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::ComponentRequest, ::AR51::ObjectIdMessage>(std::bind(&WithStreamedUnaryMethod_GetComponent<BaseClass>::StreamedGetComponent, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetComponent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetComponent(::grpc::ServerContext* context, const ::AR51::ComponentRequest* request, ::AR51::ObjectIdMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetComponent(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::ComponentRequest,::AR51::ObjectIdMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetComponentField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetComponentField() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::ComponentFieldMessage, ::AR51::ComponentFieldMessage>(std::bind(&WithStreamedUnaryMethod_GetComponentField<BaseClass>::StreamedGetComponentField, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetComponentField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::ComponentFieldMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetComponentField(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::ComponentFieldMessage,::AR51::ComponentFieldMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetComponentField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetComponentField() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::ComponentFieldMessage, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetComponentField<BaseClass>::StreamedSetComponentField, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetComponentField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetComponentField(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::ComponentFieldMessage,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCameraProject : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetCameraProject() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::TransformMessage, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetCameraProject<BaseClass>::StreamedSetCameraProject, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetCameraProject() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCameraProject(::grpc::ServerContext* context, const ::AR51::TransformMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCameraProject(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::TransformMessage,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetRendererEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetRendererEnabled() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::SetRendererEnabledRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetRendererEnabled<BaseClass>::StreamedSetRendererEnabled, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetRendererEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetRendererEnabled(::grpc::ServerContext* context, const ::AR51::SetRendererEnabledRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetRendererEnabled(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::SetRendererEnabledRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetMaterialTexture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetMaterialTexture() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::SetMaterialTextureRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetMaterialTexture<BaseClass>::StreamedSetMaterialTexture, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetMaterialTexture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetMaterialTexture(::grpc::ServerContext* context, const ::AR51::SetMaterialTextureRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetMaterialTexture(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::SetMaterialTextureRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetMaterialInt32 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetMaterialInt32() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::SetMaterialInt32Request, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetMaterialInt32<BaseClass>::StreamedSetMaterialInt32, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetMaterialInt32() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetMaterialInt32(::grpc::ServerContext* context, const ::AR51::SetMaterialInt32Request* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetMaterialInt32(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::SetMaterialInt32Request,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetMaterialFloat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetMaterialFloat() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::SetMaterialFloatRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetMaterialFloat<BaseClass>::StreamedSetMaterialFloat, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetMaterialFloat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetMaterialFloat(::grpc::ServerContext* context, const ::AR51::SetMaterialFloatRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetMaterialFloat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::SetMaterialFloatRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetMaterialColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetMaterialColor() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::SetMaterialColorRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetMaterialColor<BaseClass>::StreamedSetMaterialColor, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetMaterialColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetMaterialColor(::grpc::ServerContext* context, const ::AR51::SetMaterialColorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetMaterialColor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::SetMaterialColorRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMaterialColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetMaterialColor() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::GetMaterialColorRequest, ::AR51::Color>(std::bind(&WithStreamedUnaryMethod_GetMaterialColor<BaseClass>::StreamedGetMaterialColor, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetMaterialColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMaterialColor(::grpc::ServerContext* context, const ::AR51::GetMaterialColorRequest* request, ::AR51::Color* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMaterialColor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::GetMaterialColorRequest,::AR51::Color>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetPyTime<WithStreamedUnaryMethod_GetPyTimeOffset<WithStreamedUnaryMethod_SetPyTimeOffset<WithStreamedUnaryMethod_Instantiate<WithStreamedUnaryMethod_FindGameObject<WithStreamedUnaryMethod_FindAnchorGameObject<WithStreamedUnaryMethod_GetMainCamera<WithStreamedUnaryMethod_Destroy<WithStreamedUnaryMethod_CreatePrimitive<WithStreamedUnaryMethod_NewGameObject<WithStreamedUnaryMethod_ClearInstances<WithStreamedUnaryMethod_SetParent<WithStreamedUnaryMethod_GetName<WithStreamedUnaryMethod_SetName<WithStreamedUnaryMethod_GetActive<WithStreamedUnaryMethod_SetActive<WithStreamedUnaryMethod_GetTransform<WithStreamedUnaryMethod_SetTransform<WithStreamedUnaryMethod_GetComponent<WithStreamedUnaryMethod_GetComponentField<WithStreamedUnaryMethod_SetComponentField<WithStreamedUnaryMethod_SetCameraProject<WithStreamedUnaryMethod_SetRendererEnabled<WithStreamedUnaryMethod_SetMaterialTexture<WithStreamedUnaryMethod_SetMaterialInt32<WithStreamedUnaryMethod_SetMaterialFloat<WithStreamedUnaryMethod_SetMaterialColor<WithStreamedUnaryMethod_GetMaterialColor<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_StreamTransform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_StreamTransform() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::GetTransformRequest, ::AR51::TransformMessage>(std::bind(&WithSplitStreamingMethod_StreamTransform<BaseClass>::StreamedStreamTransform, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_StreamTransform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StreamTransform(::grpc::ServerContext* context, const ::AR51::GetTransformRequest* request, ::grpc::ServerWriter< ::AR51::TransformMessage>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStreamTransform(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::GetTransformRequest,::AR51::TransformMessage>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_StreamTransform<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetPyTime<WithStreamedUnaryMethod_GetPyTimeOffset<WithStreamedUnaryMethod_SetPyTimeOffset<WithStreamedUnaryMethod_Instantiate<WithStreamedUnaryMethod_FindGameObject<WithStreamedUnaryMethod_FindAnchorGameObject<WithStreamedUnaryMethod_GetMainCamera<WithStreamedUnaryMethod_Destroy<WithStreamedUnaryMethod_CreatePrimitive<WithStreamedUnaryMethod_NewGameObject<WithStreamedUnaryMethod_ClearInstances<WithStreamedUnaryMethod_SetParent<WithStreamedUnaryMethod_GetName<WithStreamedUnaryMethod_SetName<WithStreamedUnaryMethod_GetActive<WithStreamedUnaryMethod_SetActive<WithStreamedUnaryMethod_GetTransform<WithStreamedUnaryMethod_SetTransform<WithSplitStreamingMethod_StreamTransform<WithStreamedUnaryMethod_GetComponent<WithStreamedUnaryMethod_GetComponentField<WithStreamedUnaryMethod_SetComponentField<WithStreamedUnaryMethod_SetCameraProject<WithStreamedUnaryMethod_SetRendererEnabled<WithStreamedUnaryMethod_SetMaterialTexture<WithStreamedUnaryMethod_SetMaterialInt32<WithStreamedUnaryMethod_SetMaterialFloat<WithStreamedUnaryMethod_SetMaterialColor<WithStreamedUnaryMethod_GetMaterialColor<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

// ========================================= Anchor Service =======================================
class AnchorService final {
 public:
  static constexpr char const* service_full_name() {
    return "AR51.AnchorService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status CreateAnchor(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncCreateAnchor(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncCreateAnchorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncCreateAnchor(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncCreateAnchorRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncDeleteAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncDeleteAnchorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncDeleteAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncDeleteAnchorRaw(context, request, cq));
    }
    virtual ::grpc::Status GetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::AR51::BoolMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> AsyncGetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(AsyncGetAnchorVisibilityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>> PrepareAsyncGetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>>(PrepareAsyncGetAnchorVisibilityRaw(context, request, cq));
    }
    virtual ::grpc::Status SetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetAnchorVisibilityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetAnchorVisibilityRaw(context, request, cq));
    }
    virtual ::grpc::Status TapToPlaceAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncTapToPlaceAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncTapToPlaceAnchorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncTapToPlaceAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncTapToPlaceAnchorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::AnchorBytes>> DownloadAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::AnchorBytes>>(DownloadAnchorRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::AnchorBytes>> AsyncDownloadAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::AnchorBytes>>(AsyncDownloadAnchorRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::AnchorBytes>> PrepareAsyncDownloadAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::AnchorBytes>>(PrepareAsyncDownloadAnchorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriterInterface< ::AR51::AnchorBytes>> UploadAnchor(::grpc::ClientContext* context, ::AR51::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::AR51::AnchorBytes>>(UploadAnchorRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::AR51::AnchorBytes>> AsyncUploadAnchor(::grpc::ClientContext* context, ::AR51::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::AR51::AnchorBytes>>(AsyncUploadAnchorRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::AR51::AnchorBytes>> PrepareAsyncUploadAnchor(::grpc::ClientContext* context, ::AR51::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::AR51::AnchorBytes>>(PrepareAsyncUploadAnchorRaw(context, response, cq));
    }
    virtual ::grpc::Status GetAnchorIds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::AnchorIdsReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::AnchorIdsReply>> AsyncGetAnchorIds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::AnchorIdsReply>>(AsyncGetAnchorIdsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::AnchorIdsReply>> PrepareAsyncGetAnchorIds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::AnchorIdsReply>>(PrepareAsyncGetAnchorIdsRaw(context, request, cq));
    }
    virtual ::grpc::Status SetAllAnchorVisibility(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetAllAnchorVisibility(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetAllAnchorVisibilityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetAllAnchorVisibility(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetAllAnchorVisibilityRaw(context, request, cq));
    }
    virtual ::grpc::Status Clear(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncClear(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncClearRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncClear(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncClearRaw(context, request, cq));
    }
    // ---- Guardians ----
    virtual ::grpc::Status GetGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::AR51::GetGuardianResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetGuardianResponse>> AsyncGetGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetGuardianResponse>>(AsyncGetGuardianRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetGuardianResponse>> PrepareAsyncGetGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetGuardianResponse>>(PrepareAsyncGetGuardianRaw(context, request, cq));
    }
    virtual ::grpc::Status GetGuardianIds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::GetGuardianIdsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetGuardianIdsResponse>> AsyncGetGuardianIds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetGuardianIdsResponse>>(AsyncGetGuardianIdsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetGuardianIdsResponse>> PrepareAsyncGetGuardianIds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetGuardianIdsResponse>>(PrepareAsyncGetGuardianIdsRaw(context, request, cq));
    }
    virtual ::grpc::Status CreateGuardian(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncCreateGuardian(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncCreateGuardianRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncCreateGuardian(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncCreateGuardianRaw(context, request, cq));
    }
    virtual ::grpc::Status DestroyGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncDestroyGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncDestroyGuardianRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncDestroyGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncDestroyGuardianRaw(context, request, cq));
    }
    virtual ::grpc::Status ClearGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncClearGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncClearGuardiansRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncClearGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncClearGuardiansRaw(context, request, cq));
    }
    virtual ::grpc::Status ShowGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncShowGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncShowGuardianRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncShowGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncShowGuardianRaw(context, request, cq));
    }
    virtual ::grpc::Status HideGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncHideGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncHideGuardianRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncHideGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncHideGuardianRaw(context, request, cq));
    }
    virtual ::grpc::Status ShowAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncShowAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncShowAllGuardiansRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncShowAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncShowAllGuardiansRaw(context, request, cq));
    }
    virtual ::grpc::Status HideAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncHideAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncHideAllGuardiansRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncHideAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncHideAllGuardiansRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void CreateAnchor(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateAnchor(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CreateAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void TapToPlaceAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TapToPlaceAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TapToPlaceAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void TapToPlaceAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DownloadAnchor(::grpc::ClientContext* context, ::AR51::AnchorRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::AnchorBytes>* reactor) = 0;
      virtual void UploadAnchor(::grpc::ClientContext* context, ::AR51::Empty* response, ::grpc::experimental::ClientWriteReactor< ::AR51::AnchorBytes>* reactor) = 0;
      virtual void GetAnchorIds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::AnchorIdsReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAnchorIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::AnchorIdsReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAnchorIds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::AnchorIdsReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAnchorIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::AnchorIdsReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetAllAnchorVisibility(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAllAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAllAnchorVisibility(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetAllAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Clear(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Clear(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Clear(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Clear(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // ---- Guardians ----
      virtual void GetGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::GetGuardianResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetGuardianResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::GetGuardianResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetGuardianResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetGuardianIds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetGuardianIdsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGuardianIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetGuardianIdsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGuardianIds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetGuardianIdsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetGuardianIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetGuardianIdsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CreateGuardian(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateGuardian(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CreateGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DestroyGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DestroyGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DestroyGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DestroyGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ClearGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ClearGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ClearGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ClearGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ShowGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ShowGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ShowGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ShowGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void HideGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HideGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HideGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void HideGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ShowAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ShowAllGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ShowAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ShowAllGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void HideAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HideAllGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HideAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void HideAllGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncCreateAnchorRaw(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncCreateAnchorRaw(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncDeleteAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncDeleteAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* AsyncGetAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::BoolMessage>* PrepareAsyncGetAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncTapToPlaceAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncTapToPlaceAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::AR51::AnchorBytes>* DownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::AnchorBytes>* AsyncDownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::AnchorBytes>* PrepareAsyncDownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::AR51::AnchorBytes>* UploadAnchorRaw(::grpc::ClientContext* context, ::AR51::Empty* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::AR51::AnchorBytes>* AsyncUploadAnchorRaw(::grpc::ClientContext* context, ::AR51::Empty* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::AR51::AnchorBytes>* PrepareAsyncUploadAnchorRaw(::grpc::ClientContext* context, ::AR51::Empty* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::AnchorIdsReply>* AsyncGetAnchorIdsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::AnchorIdsReply>* PrepareAsyncGetAnchorIdsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetAllAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetAllAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncClearRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncClearRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetGuardianResponse>* AsyncGetGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetGuardianResponse>* PrepareAsyncGetGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetGuardianIdsResponse>* AsyncGetGuardianIdsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::GetGuardianIdsResponse>* PrepareAsyncGetGuardianIdsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncCreateGuardianRaw(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncCreateGuardianRaw(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncDestroyGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncDestroyGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncClearGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncClearGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncShowGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncShowGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncHideGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncHideGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncShowAllGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncShowAllGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncHideAllGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncHideAllGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status CreateAnchor(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncCreateAnchor(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncCreateAnchorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncCreateAnchor(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncCreateAnchorRaw(context, request, cq));
    }
    ::grpc::Status DeleteAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncDeleteAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncDeleteAnchorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncDeleteAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncDeleteAnchorRaw(context, request, cq));
    }
    ::grpc::Status GetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::AR51::BoolMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> AsyncGetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(AsyncGetAnchorVisibilityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>> PrepareAsyncGetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>>(PrepareAsyncGetAnchorVisibilityRaw(context, request, cq));
    }
    ::grpc::Status SetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetAnchorVisibilityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetAnchorVisibilityRaw(context, request, cq));
    }
    ::grpc::Status TapToPlaceAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncTapToPlaceAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncTapToPlaceAnchorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncTapToPlaceAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncTapToPlaceAnchorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::AR51::AnchorBytes>> DownloadAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::AnchorBytes>>(DownloadAnchorRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::AnchorBytes>> AsyncDownloadAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::AnchorBytes>>(AsyncDownloadAnchorRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::AnchorBytes>> PrepareAsyncDownloadAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::AnchorBytes>>(PrepareAsyncDownloadAnchorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::AR51::AnchorBytes>> UploadAnchor(::grpc::ClientContext* context, ::AR51::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::AR51::AnchorBytes>>(UploadAnchorRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::AR51::AnchorBytes>> AsyncUploadAnchor(::grpc::ClientContext* context, ::AR51::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::AR51::AnchorBytes>>(AsyncUploadAnchorRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::AR51::AnchorBytes>> PrepareAsyncUploadAnchor(::grpc::ClientContext* context, ::AR51::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::AR51::AnchorBytes>>(PrepareAsyncUploadAnchorRaw(context, response, cq));
    }
    ::grpc::Status GetAnchorIds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::AnchorIdsReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::AnchorIdsReply>> AsyncGetAnchorIds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::AnchorIdsReply>>(AsyncGetAnchorIdsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::AnchorIdsReply>> PrepareAsyncGetAnchorIds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::AnchorIdsReply>>(PrepareAsyncGetAnchorIdsRaw(context, request, cq));
    }
    ::grpc::Status SetAllAnchorVisibility(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetAllAnchorVisibility(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetAllAnchorVisibilityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetAllAnchorVisibility(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetAllAnchorVisibilityRaw(context, request, cq));
    }
    ::grpc::Status Clear(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncClear(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncClearRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncClear(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncClearRaw(context, request, cq));
    }
    ::grpc::Status GetGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::AR51::GetGuardianResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetGuardianResponse>> AsyncGetGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetGuardianResponse>>(AsyncGetGuardianRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetGuardianResponse>> PrepareAsyncGetGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetGuardianResponse>>(PrepareAsyncGetGuardianRaw(context, request, cq));
    }
    ::grpc::Status GetGuardianIds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::GetGuardianIdsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetGuardianIdsResponse>> AsyncGetGuardianIds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetGuardianIdsResponse>>(AsyncGetGuardianIdsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetGuardianIdsResponse>> PrepareAsyncGetGuardianIds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::GetGuardianIdsResponse>>(PrepareAsyncGetGuardianIdsRaw(context, request, cq));
    }
    ::grpc::Status CreateGuardian(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncCreateGuardian(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncCreateGuardianRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncCreateGuardian(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncCreateGuardianRaw(context, request, cq));
    }
    ::grpc::Status DestroyGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncDestroyGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncDestroyGuardianRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncDestroyGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncDestroyGuardianRaw(context, request, cq));
    }
    ::grpc::Status ClearGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncClearGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncClearGuardiansRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncClearGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncClearGuardiansRaw(context, request, cq));
    }
    ::grpc::Status ShowGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncShowGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncShowGuardianRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncShowGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncShowGuardianRaw(context, request, cq));
    }
    ::grpc::Status HideGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncHideGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncHideGuardianRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncHideGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncHideGuardianRaw(context, request, cq));
    }
    ::grpc::Status ShowAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncShowAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncShowAllGuardiansRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncShowAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncShowAllGuardiansRaw(context, request, cq));
    }
    ::grpc::Status HideAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncHideAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncHideAllGuardiansRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncHideAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncHideAllGuardiansRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void CreateAnchor(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void CreateAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void CreateAnchor(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void DeleteAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void DeleteAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)>) override;
      void GetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void TapToPlaceAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void TapToPlaceAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void TapToPlaceAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void TapToPlaceAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DownloadAnchor(::grpc::ClientContext* context, ::AR51::AnchorRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::AnchorBytes>* reactor) override;
      void UploadAnchor(::grpc::ClientContext* context, ::AR51::Empty* response, ::grpc::experimental::ClientWriteReactor< ::AR51::AnchorBytes>* reactor) override;
      void GetAnchorIds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::AnchorIdsReply* response, std::function<void(::grpc::Status)>) override;
      void GetAnchorIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::AnchorIdsReply* response, std::function<void(::grpc::Status)>) override;
      void GetAnchorIds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::AnchorIdsReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAnchorIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::AnchorIdsReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetAllAnchorVisibility(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetAllAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetAllAnchorVisibility(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetAllAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Clear(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Clear(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void Clear(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Clear(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::GetGuardianResponse* response, std::function<void(::grpc::Status)>) override;
      void GetGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetGuardianResponse* response, std::function<void(::grpc::Status)>) override;
      void GetGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::GetGuardianResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetGuardianResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetGuardianIds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetGuardianIdsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetGuardianIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetGuardianIdsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetGuardianIds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetGuardianIdsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetGuardianIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetGuardianIdsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateGuardian(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void CreateGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void CreateGuardian(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DestroyGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void DestroyGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void DestroyGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DestroyGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ClearGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void ClearGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void ClearGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ClearGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ShowGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void ShowGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void ShowGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ShowGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void HideGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void HideGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void HideGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void HideGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ShowAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void ShowAllGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void ShowAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ShowAllGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void HideAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void HideAllGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void HideAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void HideAllGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncCreateAnchorRaw(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncCreateAnchorRaw(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncDeleteAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncDeleteAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AsyncGetAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* PrepareAsyncGetAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncTapToPlaceAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncTapToPlaceAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::AR51::AnchorBytes>* DownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request) override;
    ::grpc::ClientAsyncReader< ::AR51::AnchorBytes>* AsyncDownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::AnchorBytes>* PrepareAsyncDownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::AR51::AnchorBytes>* UploadAnchorRaw(::grpc::ClientContext* context, ::AR51::Empty* response) override;
    ::grpc::ClientAsyncWriter< ::AR51::AnchorBytes>* AsyncUploadAnchorRaw(::grpc::ClientContext* context, ::AR51::Empty* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::AR51::AnchorBytes>* PrepareAsyncUploadAnchorRaw(::grpc::ClientContext* context, ::AR51::Empty* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::AnchorIdsReply>* AsyncGetAnchorIdsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::AnchorIdsReply>* PrepareAsyncGetAnchorIdsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetAllAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetAllAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncClearRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncClearRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::GetGuardianResponse>* AsyncGetGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::GetGuardianResponse>* PrepareAsyncGetGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::GetGuardianIdsResponse>* AsyncGetGuardianIdsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::GetGuardianIdsResponse>* PrepareAsyncGetGuardianIdsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncCreateGuardianRaw(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncCreateGuardianRaw(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncDestroyGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncDestroyGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncClearGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncClearGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncShowGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncShowGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncHideGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncHideGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncShowAllGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncShowAllGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncHideAllGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncHideAllGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CreateAnchor_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteAnchor_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAnchorVisibility_;
    const ::grpc::internal::RpcMethod rpcmethod_SetAnchorVisibility_;
    const ::grpc::internal::RpcMethod rpcmethod_TapToPlaceAnchor_;
    const ::grpc::internal::RpcMethod rpcmethod_DownloadAnchor_;
    const ::grpc::internal::RpcMethod rpcmethod_UploadAnchor_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAnchorIds_;
    const ::grpc::internal::RpcMethod rpcmethod_SetAllAnchorVisibility_;
    const ::grpc::internal::RpcMethod rpcmethod_Clear_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGuardian_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGuardianIds_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateGuardian_;
    const ::grpc::internal::RpcMethod rpcmethod_DestroyGuardian_;
    const ::grpc::internal::RpcMethod rpcmethod_ClearGuardians_;
    const ::grpc::internal::RpcMethod rpcmethod_ShowGuardian_;
    const ::grpc::internal::RpcMethod rpcmethod_HideGuardian_;
    const ::grpc::internal::RpcMethod rpcmethod_ShowAllGuardians_;
    const ::grpc::internal::RpcMethod rpcmethod_HideAllGuardians_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status CreateAnchor(::grpc::ServerContext* context, const ::AR51::CreateAnchorRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status DeleteAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status GetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::BoolMessage* response);
    virtual ::grpc::Status SetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::SetAnchorVisiliblityRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status TapToPlaceAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status DownloadAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::grpc::ServerWriter< ::AR51::AnchorBytes>* writer);
    virtual ::grpc::Status UploadAnchor(::grpc::ServerContext* context, ::grpc::ServerReader< ::AR51::AnchorBytes>* reader, ::AR51::Empty* response);
    virtual ::grpc::Status GetAnchorIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::AnchorIdsReply* response);
    virtual ::grpc::Status SetAllAnchorVisibility(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response);
    virtual ::grpc::Status Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response);
    // ---- Guardians ----
    virtual ::grpc::Status GetGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::GetGuardianResponse* response);
    virtual ::grpc::Status GetGuardianIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetGuardianIdsResponse* response);
    virtual ::grpc::Status CreateGuardian(::grpc::ServerContext* context, const ::AR51::CreateGuardianRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status DestroyGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status ClearGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response);
    virtual ::grpc::Status ShowGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status HideGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response);
    virtual ::grpc::Status ShowAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response);
    virtual ::grpc::Status HideAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CreateAnchor() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CreateAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAnchor(::grpc::ServerContext* context, const ::AR51::CreateAnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateAnchor(::grpc::ServerContext* context, ::AR51::CreateAnchorRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DeleteAnchor() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_DeleteAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAnchor(::grpc::ServerContext* context, ::AR51::AnchorRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetAnchorVisibility() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAnchorVisibility(::grpc::ServerContext* context, ::AR51::AnchorRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::BoolMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetAnchorVisibility() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SetAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::SetAnchorVisiliblityRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAnchorVisibility(::grpc::ServerContext* context, ::AR51::SetAnchorVisiliblityRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TapToPlaceAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_TapToPlaceAnchor() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_TapToPlaceAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TapToPlaceAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTapToPlaceAnchor(::grpc::ServerContext* context, ::AR51::AnchorRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DownloadAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DownloadAnchor() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_DownloadAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::grpc::ServerWriter< ::AR51::AnchorBytes>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadAnchor(::grpc::ServerContext* context, ::AR51::AnchorRequest* request, ::grpc::ServerAsyncWriter< ::AR51::AnchorBytes>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UploadAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UploadAnchor() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_UploadAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadAnchor(::grpc::ServerContext* context, ::grpc::ServerReader< ::AR51::AnchorBytes>* reader, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadAnchor(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::AR51::Empty, ::AR51::AnchorBytes>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(6, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAnchorIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetAnchorIds() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetAnchorIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnchorIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::AnchorIdsReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAnchorIds(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::AnchorIdsReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetAllAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetAllAnchorVisibility() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_SetAllAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAllAnchorVisibility(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAllAnchorVisibility(::grpc::ServerContext* context, ::AR51::BoolMessage* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Clear() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_Clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClear(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetGuardian() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::GetGuardianResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGuardian(::grpc::ServerContext* context, ::AR51::GuardianRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::GetGuardianResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGuardianIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetGuardianIds() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetGuardianIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGuardianIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetGuardianIdsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGuardianIds(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::GetGuardianIdsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CreateGuardian() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_CreateGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGuardian(::grpc::ServerContext* context, const ::AR51::CreateGuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateGuardian(::grpc::ServerContext* context, ::AR51::CreateGuardianRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DestroyGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DestroyGuardian() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_DestroyGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyGuardian(::grpc::ServerContext* context, ::AR51::GuardianRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ClearGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ClearGuardians() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_ClearGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearGuardians(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ShowGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ShowGuardian() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_ShowGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShowGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestShowGuardian(::grpc::ServerContext* context, ::AR51::GuardianRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HideGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_HideGuardian() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_HideGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HideGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHideGuardian(::grpc::ServerContext* context, ::AR51::GuardianRequest* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ShowAllGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ShowAllGuardians() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_ShowAllGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShowAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestShowAllGuardians(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HideAllGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_HideAllGuardians() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_HideAllGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HideAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHideAllGuardians(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CreateAnchor<WithAsyncMethod_DeleteAnchor<WithAsyncMethod_GetAnchorVisibility<WithAsyncMethod_SetAnchorVisibility<WithAsyncMethod_TapToPlaceAnchor<WithAsyncMethod_DownloadAnchor<WithAsyncMethod_UploadAnchor<WithAsyncMethod_GetAnchorIds<WithAsyncMethod_SetAllAnchorVisibility<WithAsyncMethod_Clear<WithAsyncMethod_GetGuardian<WithAsyncMethod_GetGuardianIds<WithAsyncMethod_CreateGuardian<WithAsyncMethod_DestroyGuardian<WithAsyncMethod_ClearGuardians<WithAsyncMethod_ShowGuardian<WithAsyncMethod_HideGuardian<WithAsyncMethod_ShowAllGuardians<WithAsyncMethod_HideAllGuardians<Service > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CreateAnchor() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CreateAnchorRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::CreateAnchorRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CreateAnchor(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CreateAnchor(
        ::grpc::experimental::MessageAllocator< ::AR51::CreateAnchorRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CreateAnchorRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAnchor(::grpc::ServerContext* context, const ::AR51::CreateAnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateAnchor(::grpc::ServerContext* context, const ::AR51::CreateAnchorRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_DeleteAnchor() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::AnchorRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::AnchorRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->DeleteAnchor(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_DeleteAnchor(
        ::grpc::experimental::MessageAllocator< ::AR51::AnchorRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::AnchorRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetAnchorVisibility() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::AnchorRequest, ::AR51::BoolMessage>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::AnchorRequest* request,
                 ::AR51::BoolMessage* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetAnchorVisibility(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetAnchorVisibility(
        ::grpc::experimental::MessageAllocator< ::AR51::AnchorRequest, ::AR51::BoolMessage>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::AnchorRequest, ::AR51::BoolMessage>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::BoolMessage* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetAnchorVisibility() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetAnchorVisiliblityRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::SetAnchorVisiliblityRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetAnchorVisibility(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetAnchorVisibility(
        ::grpc::experimental::MessageAllocator< ::AR51::SetAnchorVisiliblityRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::SetAnchorVisiliblityRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::SetAnchorVisiliblityRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::SetAnchorVisiliblityRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TapToPlaceAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_TapToPlaceAnchor() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::AnchorRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::AnchorRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->TapToPlaceAnchor(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_TapToPlaceAnchor(
        ::grpc::experimental::MessageAllocator< ::AR51::AnchorRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::AnchorRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TapToPlaceAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TapToPlaceAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void TapToPlaceAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DownloadAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_DownloadAnchor() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::AnchorRequest, ::AR51::AnchorBytes>(
          [this] { return this->DownloadAnchor(); }));
    }
    ~ExperimentalWithCallbackMethod_DownloadAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::grpc::ServerWriter< ::AR51::AnchorBytes>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::AnchorRequest, ::AR51::AnchorBytes>* DownloadAnchor() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::AnchorRequest, ::AR51::AnchorBytes>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UploadAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UploadAnchor() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc_impl::internal::CallbackClientStreamingHandler< ::AR51::AnchorBytes, ::AR51::Empty>(
          [this] { return this->UploadAnchor(); }));
    }
    ~ExperimentalWithCallbackMethod_UploadAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadAnchor(::grpc::ServerContext* context, ::grpc::ServerReader< ::AR51::AnchorBytes>* reader, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerReadReactor< ::AR51::AnchorBytes, ::AR51::Empty>* UploadAnchor() {
      return new ::grpc_impl::internal::UnimplementedReadReactor<
        ::AR51::AnchorBytes, ::AR51::Empty>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAnchorIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetAnchorIds() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::AnchorIdsReply>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::AnchorIdsReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetAnchorIds(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetAnchorIds(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::AnchorIdsReply>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::AnchorIdsReply>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAnchorIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnchorIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::AnchorIdsReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAnchorIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::AnchorIdsReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetAllAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetAllAnchorVisibility() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::BoolMessage, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::BoolMessage* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetAllAnchorVisibility(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetAllAnchorVisibility(
        ::grpc::experimental::MessageAllocator< ::AR51::BoolMessage, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::BoolMessage, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(8))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetAllAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAllAnchorVisibility(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetAllAnchorVisibility(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Clear() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Clear(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Clear(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(9))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetGuardian() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GuardianRequest, ::AR51::GetGuardianResponse>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::GuardianRequest* request,
                 ::AR51::GetGuardianResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetGuardian(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetGuardian(
        ::grpc::experimental::MessageAllocator< ::AR51::GuardianRequest, ::AR51::GetGuardianResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GuardianRequest, ::AR51::GetGuardianResponse>*>(
          ::grpc::Service::experimental().GetHandler(10))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::GetGuardianResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::GetGuardianResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetGuardianIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetGuardianIds() {
      ::grpc::Service::experimental().MarkMethodCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::GetGuardianIdsResponse>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::GetGuardianIdsResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetGuardianIds(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetGuardianIds(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::GetGuardianIdsResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::GetGuardianIdsResponse>*>(
          ::grpc::Service::experimental().GetHandler(11))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetGuardianIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGuardianIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetGuardianIdsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetGuardianIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetGuardianIdsResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CreateGuardian() {
      ::grpc::Service::experimental().MarkMethodCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CreateGuardianRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::CreateGuardianRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CreateGuardian(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CreateGuardian(
        ::grpc::experimental::MessageAllocator< ::AR51::CreateGuardianRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::CreateGuardianRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(12))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGuardian(::grpc::ServerContext* context, const ::AR51::CreateGuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateGuardian(::grpc::ServerContext* context, const ::AR51::CreateGuardianRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DestroyGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_DestroyGuardian() {
      ::grpc::Service::experimental().MarkMethodCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GuardianRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::GuardianRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->DestroyGuardian(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_DestroyGuardian(
        ::grpc::experimental::MessageAllocator< ::AR51::GuardianRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GuardianRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(13))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DestroyGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DestroyGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ClearGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ClearGuardians() {
      ::grpc::Service::experimental().MarkMethodCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ClearGuardians(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ClearGuardians(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(14))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ClearGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ClearGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ShowGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ShowGuardian() {
      ::grpc::Service::experimental().MarkMethodCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GuardianRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::GuardianRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ShowGuardian(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ShowGuardian(
        ::grpc::experimental::MessageAllocator< ::AR51::GuardianRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GuardianRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(15))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ShowGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShowGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ShowGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_HideGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_HideGuardian() {
      ::grpc::Service::experimental().MarkMethodCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GuardianRequest, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::GuardianRequest* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->HideGuardian(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_HideGuardian(
        ::grpc::experimental::MessageAllocator< ::AR51::GuardianRequest, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::GuardianRequest, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(16))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_HideGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HideGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void HideGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ShowAllGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ShowAllGuardians() {
      ::grpc::Service::experimental().MarkMethodCallback(17,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ShowAllGuardians(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ShowAllGuardians(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(17))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ShowAllGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShowAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ShowAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_HideAllGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_HideAllGuardians() {
      ::grpc::Service::experimental().MarkMethodCallback(18,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->HideAllGuardians(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_HideAllGuardians(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(18))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_HideAllGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HideAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void HideAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_CreateAnchor<ExperimentalWithCallbackMethod_DeleteAnchor<ExperimentalWithCallbackMethod_GetAnchorVisibility<ExperimentalWithCallbackMethod_SetAnchorVisibility<ExperimentalWithCallbackMethod_TapToPlaceAnchor<ExperimentalWithCallbackMethod_DownloadAnchor<ExperimentalWithCallbackMethod_UploadAnchor<ExperimentalWithCallbackMethod_GetAnchorIds<ExperimentalWithCallbackMethod_SetAllAnchorVisibility<ExperimentalWithCallbackMethod_Clear<ExperimentalWithCallbackMethod_GetGuardian<ExperimentalWithCallbackMethod_GetGuardianIds<ExperimentalWithCallbackMethod_CreateGuardian<ExperimentalWithCallbackMethod_DestroyGuardian<ExperimentalWithCallbackMethod_ClearGuardians<ExperimentalWithCallbackMethod_ShowGuardian<ExperimentalWithCallbackMethod_HideGuardian<ExperimentalWithCallbackMethod_ShowAllGuardians<ExperimentalWithCallbackMethod_HideAllGuardians<Service > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CreateAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CreateAnchor() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CreateAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAnchor(::grpc::ServerContext* context, const ::AR51::CreateAnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DeleteAnchor() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_DeleteAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetAnchorVisibility() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetAnchorVisibility() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SetAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::SetAnchorVisiliblityRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TapToPlaceAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_TapToPlaceAnchor() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_TapToPlaceAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TapToPlaceAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DownloadAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DownloadAnchor() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_DownloadAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::grpc::ServerWriter< ::AR51::AnchorBytes>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UploadAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UploadAnchor() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_UploadAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadAnchor(::grpc::ServerContext* context, ::grpc::ServerReader< ::AR51::AnchorBytes>* reader, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAnchorIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetAnchorIds() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetAnchorIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnchorIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::AnchorIdsReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetAllAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetAllAnchorVisibility() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_SetAllAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAllAnchorVisibility(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Clear() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_Clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetGuardian() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::GetGuardianResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGuardianIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetGuardianIds() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetGuardianIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGuardianIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetGuardianIdsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CreateGuardian() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_CreateGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGuardian(::grpc::ServerContext* context, const ::AR51::CreateGuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DestroyGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DestroyGuardian() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_DestroyGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ClearGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ClearGuardians() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_ClearGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ShowGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ShowGuardian() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_ShowGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShowGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HideGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_HideGuardian() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_HideGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HideGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ShowAllGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ShowAllGuardians() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_ShowAllGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShowAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HideAllGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_HideAllGuardians() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_HideAllGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HideAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CreateAnchor() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CreateAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAnchor(::grpc::ServerContext* context, const ::AR51::CreateAnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateAnchor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DeleteAnchor() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_DeleteAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAnchor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetAnchorVisibility() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAnchorVisibility(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetAnchorVisibility() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_SetAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::SetAnchorVisiliblityRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAnchorVisibility(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TapToPlaceAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_TapToPlaceAnchor() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_TapToPlaceAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TapToPlaceAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTapToPlaceAnchor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DownloadAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DownloadAnchor() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_DownloadAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::grpc::ServerWriter< ::AR51::AnchorBytes>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadAnchor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UploadAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UploadAnchor() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_UploadAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadAnchor(::grpc::ServerContext* context, ::grpc::ServerReader< ::AR51::AnchorBytes>* reader, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadAnchor(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(6, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAnchorIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetAnchorIds() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetAnchorIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnchorIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::AnchorIdsReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAnchorIds(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetAllAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetAllAnchorVisibility() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_SetAllAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAllAnchorVisibility(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAllAnchorVisibility(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Clear() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_Clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClear(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetGuardian() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::GetGuardianResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGuardian(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGuardianIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetGuardianIds() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetGuardianIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGuardianIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetGuardianIdsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGuardianIds(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CreateGuardian() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_CreateGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGuardian(::grpc::ServerContext* context, const ::AR51::CreateGuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateGuardian(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DestroyGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DestroyGuardian() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_DestroyGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyGuardian(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ClearGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ClearGuardians() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_ClearGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearGuardians(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ShowGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ShowGuardian() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_ShowGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShowGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestShowGuardian(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HideGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_HideGuardian() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_HideGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HideGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHideGuardian(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ShowAllGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ShowAllGuardians() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_ShowAllGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShowAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestShowAllGuardians(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HideAllGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_HideAllGuardians() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_HideAllGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HideAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHideAllGuardians(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateAnchor() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CreateAnchor(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAnchor(::grpc::ServerContext* context, const ::AR51::CreateAnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateAnchor(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteAnchor() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->DeleteAnchor(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteAnchor(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAnchorVisibility() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetAnchorVisibility(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAnchorVisibility(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetAnchorVisibility() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetAnchorVisibility(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::SetAnchorVisiliblityRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetAnchorVisibility(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TapToPlaceAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_TapToPlaceAnchor() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->TapToPlaceAnchor(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_TapToPlaceAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TapToPlaceAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void TapToPlaceAnchor(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DownloadAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_DownloadAnchor() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->DownloadAnchor(); }));
    }
    ~ExperimentalWithRawCallbackMethod_DownloadAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::grpc::ServerWriter< ::AR51::AnchorBytes>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* DownloadAnchor() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UploadAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UploadAnchor() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc_impl::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->UploadAnchor(); }));
    }
    ~ExperimentalWithRawCallbackMethod_UploadAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadAnchor(::grpc::ServerContext* context, ::grpc::ServerReader< ::AR51::AnchorBytes>* reader, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerReadReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* UploadAnchor() {
      return new ::grpc_impl::internal::UnimplementedReadReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAnchorIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAnchorIds() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetAnchorIds(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAnchorIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnchorIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::AnchorIdsReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAnchorIds(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetAllAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetAllAnchorVisibility() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetAllAnchorVisibility(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetAllAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAllAnchorVisibility(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetAllAnchorVisibility(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Clear() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Clear(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Clear(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetGuardian() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetGuardian(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::GetGuardianResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetGuardian(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetGuardianIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetGuardianIds() {
      ::grpc::Service::experimental().MarkMethodRawCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetGuardianIds(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetGuardianIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGuardianIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetGuardianIdsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetGuardianIds(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateGuardian() {
      ::grpc::Service::experimental().MarkMethodRawCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CreateGuardian(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGuardian(::grpc::ServerContext* context, const ::AR51::CreateGuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CreateGuardian(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DestroyGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_DestroyGuardian() {
      ::grpc::Service::experimental().MarkMethodRawCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->DestroyGuardian(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_DestroyGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DestroyGuardian(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ClearGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ClearGuardians() {
      ::grpc::Service::experimental().MarkMethodRawCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ClearGuardians(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ClearGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ClearGuardians(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ShowGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ShowGuardian() {
      ::grpc::Service::experimental().MarkMethodRawCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ShowGuardian(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ShowGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShowGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ShowGuardian(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_HideGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_HideGuardian() {
      ::grpc::Service::experimental().MarkMethodRawCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->HideGuardian(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_HideGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HideGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void HideGuardian(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ShowAllGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ShowAllGuardians() {
      ::grpc::Service::experimental().MarkMethodRawCallback(17,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ShowAllGuardians(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ShowAllGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShowAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ShowAllGuardians(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_HideAllGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_HideAllGuardians() {
      ::grpc::Service::experimental().MarkMethodRawCallback(18,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->HideAllGuardians(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_HideAllGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HideAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void HideAllGuardians(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CreateAnchor() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::CreateAnchorRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_CreateAnchor<BaseClass>::StreamedCreateAnchor, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateAnchor(::grpc::ServerContext* context, const ::AR51::CreateAnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateAnchor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::CreateAnchorRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DeleteAnchor() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::AnchorRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_DeleteAnchor<BaseClass>::StreamedDeleteAnchor, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteAnchor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::AnchorRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetAnchorVisibility() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::AnchorRequest, ::AR51::BoolMessage>(std::bind(&WithStreamedUnaryMethod_GetAnchorVisibility<BaseClass>::StreamedGetAnchorVisibility, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::BoolMessage* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAnchorVisibility(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::AnchorRequest,::AR51::BoolMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetAnchorVisibility() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::SetAnchorVisiliblityRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetAnchorVisibility<BaseClass>::StreamedSetAnchorVisibility, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::SetAnchorVisiliblityRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetAnchorVisibility(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::SetAnchorVisiliblityRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TapToPlaceAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_TapToPlaceAnchor() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::AnchorRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_TapToPlaceAnchor<BaseClass>::StreamedTapToPlaceAnchor, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_TapToPlaceAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TapToPlaceAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTapToPlaceAnchor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::AnchorRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAnchorIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetAnchorIds() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::AnchorIdsReply>(std::bind(&WithStreamedUnaryMethod_GetAnchorIds<BaseClass>::StreamedGetAnchorIds, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetAnchorIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAnchorIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::AnchorIdsReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAnchorIds(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::AnchorIdsReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetAllAnchorVisibility : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetAllAnchorVisibility() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::BoolMessage, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetAllAnchorVisibility<BaseClass>::StreamedSetAllAnchorVisibility, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetAllAnchorVisibility() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetAllAnchorVisibility(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetAllAnchorVisibility(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::BoolMessage,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Clear() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_Clear<BaseClass>::StreamedClear, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClear(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetGuardian() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::GuardianRequest, ::AR51::GetGuardianResponse>(std::bind(&WithStreamedUnaryMethod_GetGuardian<BaseClass>::StreamedGetGuardian, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::GetGuardianResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetGuardian(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::GuardianRequest,::AR51::GetGuardianResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetGuardianIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetGuardianIds() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::GetGuardianIdsResponse>(std::bind(&WithStreamedUnaryMethod_GetGuardianIds<BaseClass>::StreamedGetGuardianIds, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetGuardianIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGuardianIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetGuardianIdsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetGuardianIds(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::GetGuardianIdsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CreateGuardian() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::CreateGuardianRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_CreateGuardian<BaseClass>::StreamedCreateGuardian, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateGuardian(::grpc::ServerContext* context, const ::AR51::CreateGuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateGuardian(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::CreateGuardianRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DestroyGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DestroyGuardian() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::GuardianRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_DestroyGuardian<BaseClass>::StreamedDestroyGuardian, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DestroyGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DestroyGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDestroyGuardian(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::GuardianRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ClearGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ClearGuardians() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_ClearGuardians<BaseClass>::StreamedClearGuardians, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ClearGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ClearGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClearGuardians(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ShowGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ShowGuardian() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::GuardianRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_ShowGuardian<BaseClass>::StreamedShowGuardian, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ShowGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ShowGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedShowGuardian(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::GuardianRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HideGuardian : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_HideGuardian() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::GuardianRequest, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_HideGuardian<BaseClass>::StreamedHideGuardian, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_HideGuardian() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HideGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHideGuardian(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::GuardianRequest,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ShowAllGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ShowAllGuardians() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_ShowAllGuardians<BaseClass>::StreamedShowAllGuardians, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ShowAllGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ShowAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedShowAllGuardians(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HideAllGuardians : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_HideAllGuardians() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_HideAllGuardians<BaseClass>::StreamedHideAllGuardians, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_HideAllGuardians() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HideAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHideAllGuardians(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CreateAnchor<WithStreamedUnaryMethod_DeleteAnchor<WithStreamedUnaryMethod_GetAnchorVisibility<WithStreamedUnaryMethod_SetAnchorVisibility<WithStreamedUnaryMethod_TapToPlaceAnchor<WithStreamedUnaryMethod_GetAnchorIds<WithStreamedUnaryMethod_SetAllAnchorVisibility<WithStreamedUnaryMethod_Clear<WithStreamedUnaryMethod_GetGuardian<WithStreamedUnaryMethod_GetGuardianIds<WithStreamedUnaryMethod_CreateGuardian<WithStreamedUnaryMethod_DestroyGuardian<WithStreamedUnaryMethod_ClearGuardians<WithStreamedUnaryMethod_ShowGuardian<WithStreamedUnaryMethod_HideGuardian<WithStreamedUnaryMethod_ShowAllGuardians<WithStreamedUnaryMethod_HideAllGuardians<Service > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_DownloadAnchor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_DownloadAnchor() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::AnchorRequest, ::AR51::AnchorBytes>(std::bind(&WithSplitStreamingMethod_DownloadAnchor<BaseClass>::StreamedDownloadAnchor, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_DownloadAnchor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DownloadAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::grpc::ServerWriter< ::AR51::AnchorBytes>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedDownloadAnchor(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::AnchorRequest,::AR51::AnchorBytes>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_DownloadAnchor<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_CreateAnchor<WithStreamedUnaryMethod_DeleteAnchor<WithStreamedUnaryMethod_GetAnchorVisibility<WithStreamedUnaryMethod_SetAnchorVisibility<WithStreamedUnaryMethod_TapToPlaceAnchor<WithSplitStreamingMethod_DownloadAnchor<WithStreamedUnaryMethod_GetAnchorIds<WithStreamedUnaryMethod_SetAllAnchorVisibility<WithStreamedUnaryMethod_Clear<WithStreamedUnaryMethod_GetGuardian<WithStreamedUnaryMethod_GetGuardianIds<WithStreamedUnaryMethod_CreateGuardian<WithStreamedUnaryMethod_DestroyGuardian<WithStreamedUnaryMethod_ClearGuardians<WithStreamedUnaryMethod_ShowGuardian<WithStreamedUnaryMethod_HideGuardian<WithStreamedUnaryMethod_ShowAllGuardians<WithStreamedUnaryMethod_HideAllGuardians<Service > > > > > > > > > > > > > > > > > > StreamedService;
};

// ========================================= Debug Service =======================================
//
class DebugService final {
 public:
  static constexpr char const* service_full_name() {
    return "AR51.DebugService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetAllFields(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::FieldInfos* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::FieldInfos>> AsyncGetAllFields(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::FieldInfos>>(AsyncGetAllFieldsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::FieldInfos>> PrepareAsyncGetAllFields(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::FieldInfos>>(PrepareAsyncGetAllFieldsRaw(context, request, cq));
    }
    virtual ::grpc::Status SetField(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::AR51::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> AsyncSetField(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(AsyncSetFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>> PrepareAsyncSetField(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>>(PrepareAsyncSetFieldRaw(context, request, cq));
    }
    virtual ::grpc::Status GetField(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::AR51::FieldInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::FieldInfo>> AsyncGetField(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::FieldInfo>>(AsyncGetFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::FieldInfo>> PrepareAsyncGetField(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AR51::FieldInfo>>(PrepareAsyncGetFieldRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void GetAllFields(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::FieldInfos* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAllFields(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::FieldInfos* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAllFields(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::FieldInfos* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAllFields(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::FieldInfos* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetField(::grpc::ClientContext* context, const ::AR51::FieldInfo* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetField(::grpc::ClientContext* context, const ::AR51::FieldInfo* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetField(::grpc::ClientContext* context, const ::AR51::FieldInfo* request, ::AR51::FieldInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::FieldInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetField(::grpc::ClientContext* context, const ::AR51::FieldInfo* request, ::AR51::FieldInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::FieldInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::FieldInfos>* AsyncGetAllFieldsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::FieldInfos>* PrepareAsyncGetAllFieldsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* AsyncSetFieldRaw(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::Empty>* PrepareAsyncSetFieldRaw(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::FieldInfo>* AsyncGetFieldRaw(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AR51::FieldInfo>* PrepareAsyncGetFieldRaw(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetAllFields(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::FieldInfos* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::FieldInfos>> AsyncGetAllFields(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::FieldInfos>>(AsyncGetAllFieldsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::FieldInfos>> PrepareAsyncGetAllFields(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::FieldInfos>>(PrepareAsyncGetAllFieldsRaw(context, request, cq));
    }
    ::grpc::Status SetField(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::AR51::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> AsyncSetField(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(AsyncSetFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>> PrepareAsyncSetField(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::Empty>>(PrepareAsyncSetFieldRaw(context, request, cq));
    }
    ::grpc::Status GetField(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::AR51::FieldInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::FieldInfo>> AsyncGetField(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::FieldInfo>>(AsyncGetFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::FieldInfo>> PrepareAsyncGetField(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AR51::FieldInfo>>(PrepareAsyncGetFieldRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetAllFields(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::FieldInfos* response, std::function<void(::grpc::Status)>) override;
      void GetAllFields(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::FieldInfos* response, std::function<void(::grpc::Status)>) override;
      void GetAllFields(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::FieldInfos* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAllFields(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::FieldInfos* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetField(::grpc::ClientContext* context, const ::AR51::FieldInfo* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetField(::grpc::ClientContext* context, const ::AR51::FieldInfo* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetField(::grpc::ClientContext* context, const ::AR51::FieldInfo* request, ::AR51::FieldInfo* response, std::function<void(::grpc::Status)>) override;
      void GetField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::FieldInfo* response, std::function<void(::grpc::Status)>) override;
      void GetField(::grpc::ClientContext* context, const ::AR51::FieldInfo* request, ::AR51::FieldInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::FieldInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::AR51::FieldInfos>* AsyncGetAllFieldsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::FieldInfos>* PrepareAsyncGetAllFieldsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AsyncSetFieldRaw(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::Empty>* PrepareAsyncSetFieldRaw(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::FieldInfo>* AsyncGetFieldRaw(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AR51::FieldInfo>* PrepareAsyncGetFieldRaw(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetAllFields_;
    const ::grpc::internal::RpcMethod rpcmethod_SetField_;
    const ::grpc::internal::RpcMethod rpcmethod_GetField_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetAllFields(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::FieldInfos* response);
    virtual ::grpc::Status SetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::Empty* response);
    virtual ::grpc::Status GetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::FieldInfo* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAllFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetAllFields() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetAllFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllFields(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::FieldInfos* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllFields(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AR51::FieldInfos>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetField() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_SetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetField(::grpc::ServerContext* context, ::AR51::FieldInfo* request, ::grpc::ServerAsyncResponseWriter< ::AR51::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetField() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::FieldInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetField(::grpc::ServerContext* context, ::AR51::FieldInfo* request, ::grpc::ServerAsyncResponseWriter< ::AR51::FieldInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetAllFields<WithAsyncMethod_SetField<WithAsyncMethod_GetField<Service > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAllFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetAllFields() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::FieldInfos>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::Empty* request,
                 ::AR51::FieldInfos* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetAllFields(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetAllFields(
        ::grpc::experimental::MessageAllocator< ::AR51::Empty, ::AR51::FieldInfos>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::Empty, ::AR51::FieldInfos>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAllFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllFields(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::FieldInfos* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAllFields(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::FieldInfos* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetField() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::FieldInfo, ::AR51::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::FieldInfo* request,
                 ::AR51::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetField(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetField(
        ::grpc::experimental::MessageAllocator< ::AR51::FieldInfo, ::AR51::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::FieldInfo, ::AR51::Empty>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetField() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::AR51::FieldInfo, ::AR51::FieldInfo>(
          [this](::grpc::ServerContext* context,
                 const ::AR51::FieldInfo* request,
                 ::AR51::FieldInfo* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetField(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetField(
        ::grpc::experimental::MessageAllocator< ::AR51::FieldInfo, ::AR51::FieldInfo>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::AR51::FieldInfo, ::AR51::FieldInfo>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::FieldInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::FieldInfo* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_GetAllFields<ExperimentalWithCallbackMethod_SetField<ExperimentalWithCallbackMethod_GetField<Service > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetAllFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetAllFields() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetAllFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllFields(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::FieldInfos* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetField() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_SetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetField() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::FieldInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAllFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetAllFields() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetAllFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllFields(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::FieldInfos* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllFields(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetField() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_SetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetField(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetField() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::FieldInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetField(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAllFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAllFields() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetAllFields(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAllFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllFields(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::FieldInfos* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAllFields(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetField() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetField(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetField(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetField() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetField(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::FieldInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetField(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAllFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetAllFields() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::Empty, ::AR51::FieldInfos>(std::bind(&WithStreamedUnaryMethod_GetAllFields<BaseClass>::StreamedGetAllFields, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetAllFields() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAllFields(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::FieldInfos* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAllFields(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::Empty,::AR51::FieldInfos>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetField() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::FieldInfo, ::AR51::Empty>(std::bind(&WithStreamedUnaryMethod_SetField<BaseClass>::StreamedSetField, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetField(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::FieldInfo,::AR51::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetField() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::AR51::FieldInfo, ::AR51::FieldInfo>(std::bind(&WithStreamedUnaryMethod_GetField<BaseClass>::StreamedGetField, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::FieldInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetField(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AR51::FieldInfo,::AR51::FieldInfo>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetAllFields<WithStreamedUnaryMethod_SetField<WithStreamedUnaryMethod_GetField<Service > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetAllFields<WithStreamedUnaryMethod_SetField<WithStreamedUnaryMethod_GetField<Service > > > StreamedService;
};

class HandSkeletonService final {
 public:
  static constexpr char const* service_full_name() {
    return "AR51.HandSkeletonService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::TwoHandsInfoResponse>> StartStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::AR51::TwoHandsInfoResponse>>(StartStreamingRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::TwoHandsInfoResponse>> AsyncStartStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::TwoHandsInfoResponse>>(AsyncStartStreamingRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::TwoHandsInfoResponse>> PrepareAsyncStartStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::AR51::TwoHandsInfoResponse>>(PrepareAsyncStartStreamingRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void StartStreaming(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::TwoHandsInfoResponse>* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientReaderInterface< ::AR51::TwoHandsInfoResponse>* StartStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::TwoHandsInfoResponse>* AsyncStartStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::AR51::TwoHandsInfoResponse>* PrepareAsyncStartStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    std::unique_ptr< ::grpc::ClientReader< ::AR51::TwoHandsInfoResponse>> StartStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::AR51::TwoHandsInfoResponse>>(StartStreamingRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::TwoHandsInfoResponse>> AsyncStartStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::TwoHandsInfoResponse>>(AsyncStartStreamingRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::TwoHandsInfoResponse>> PrepareAsyncStartStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::AR51::TwoHandsInfoResponse>>(PrepareAsyncStartStreamingRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void StartStreaming(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::TwoHandsInfoResponse>* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientReader< ::AR51::TwoHandsInfoResponse>* StartStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) override;
    ::grpc::ClientAsyncReader< ::AR51::TwoHandsInfoResponse>* AsyncStartStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::AR51::TwoHandsInfoResponse>* PrepareAsyncStartStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_StartStreaming_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status StartStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::TwoHandsInfoResponse>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_StartStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StartStreaming() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_StartStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::TwoHandsInfoResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartStreaming(::grpc::ServerContext* context, ::AR51::Empty* request, ::grpc::ServerAsyncWriter< ::AR51::TwoHandsInfoResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_StartStreaming<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StartStreaming() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::AR51::Empty, ::AR51::TwoHandsInfoResponse>(
          [this] { return this->StartStreaming(); }));
    }
    ~ExperimentalWithCallbackMethod_StartStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::TwoHandsInfoResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::AR51::Empty, ::AR51::TwoHandsInfoResponse>* StartStreaming() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::AR51::Empty, ::AR51::TwoHandsInfoResponse>;}
  };
  typedef ExperimentalWithCallbackMethod_StartStreaming<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_StartStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StartStreaming() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_StartStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::TwoHandsInfoResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StartStreaming() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_StartStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::TwoHandsInfoResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartStreaming(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StartStreaming() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->StartStreaming(); }));
    }
    ~ExperimentalWithRawCallbackMethod_StartStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::TwoHandsInfoResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* StartStreaming() {
      return new ::grpc_impl::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  typedef Service StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_StartStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_StartStreaming() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler< ::AR51::Empty, ::AR51::TwoHandsInfoResponse>(std::bind(&WithSplitStreamingMethod_StartStreaming<BaseClass>::StreamedStartStreaming, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_StartStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::TwoHandsInfoResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStartStreaming(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::AR51::Empty,::AR51::TwoHandsInfoResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_StartStreaming<Service > SplitStreamedService;
  typedef WithSplitStreamingMethod_StartStreaming<Service > StreamedService;
};

}  // namespace AR51


#endif  // GRPC_dgs_2eproto__INCLUDED
