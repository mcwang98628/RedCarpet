// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cvs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cvs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_cvs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "AR51.Core.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_cvs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cvs_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[24]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_cvs_2eproto;
namespace AR51 {
class BoundInfo;
class BoundInfoDefaultTypeInternal;
extern BoundInfoDefaultTypeInternal _BoundInfo_default_instance_;
class CalibrationPointCloudMessage;
class CalibrationPointCloudMessageDefaultTypeInternal;
extern CalibrationPointCloudMessageDefaultTypeInternal _CalibrationPointCloudMessage_default_instance_;
class CalibrationStatus;
class CalibrationStatusDefaultTypeInternal;
extern CalibrationStatusDefaultTypeInternal _CalibrationStatus_default_instance_;
class CalibrationVisualizationMessage;
class CalibrationVisualizationMessageDefaultTypeInternal;
extern CalibrationVisualizationMessageDefaultTypeInternal _CalibrationVisualizationMessage_default_instance_;
class ControllerInfoRequest;
class ControllerInfoRequestDefaultTypeInternal;
extern ControllerInfoRequestDefaultTypeInternal _ControllerInfoRequest_default_instance_;
class CvsCameraFeedRequest;
class CvsCameraFeedRequestDefaultTypeInternal;
extern CvsCameraFeedRequestDefaultTypeInternal _CvsCameraFeedRequest_default_instance_;
class CvsCameraFeedResponse;
class CvsCameraFeedResponseDefaultTypeInternal;
extern CvsCameraFeedResponseDefaultTypeInternal _CvsCameraFeedResponse_default_instance_;
class CvsCameraGetRecordingReadyRequest;
class CvsCameraGetRecordingReadyRequestDefaultTypeInternal;
extern CvsCameraGetRecordingReadyRequestDefaultTypeInternal _CvsCameraGetRecordingReadyRequest_default_instance_;
class CvsCameraIdRequest;
class CvsCameraIdRequestDefaultTypeInternal;
extern CvsCameraIdRequestDefaultTypeInternal _CvsCameraIdRequest_default_instance_;
class CvsCameraInfo;
class CvsCameraInfoDefaultTypeInternal;
extern CvsCameraInfoDefaultTypeInternal _CvsCameraInfo_default_instance_;
class DeviceInfo;
class DeviceInfoDefaultTypeInternal;
extern DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
class GetAvailableCamerasResponse;
class GetAvailableCamerasResponseDefaultTypeInternal;
extern GetAvailableCamerasResponseDefaultTypeInternal _GetAvailableCamerasResponse_default_instance_;
class GetCvsCameraField;
class GetCvsCameraFieldDefaultTypeInternal;
extern GetCvsCameraFieldDefaultTypeInternal _GetCvsCameraField_default_instance_;
class HandsInfoRequest;
class HandsInfoRequestDefaultTypeInternal;
extern HandsInfoRequestDefaultTypeInternal _HandsInfoRequest_default_instance_;
class HelloReply;
class HelloReplyDefaultTypeInternal;
extern HelloReplyDefaultTypeInternal _HelloReply_default_instance_;
class HelloRequest;
class HelloRequestDefaultTypeInternal;
extern HelloRequestDefaultTypeInternal _HelloRequest_default_instance_;
class MarkerInfo;
class MarkerInfoDefaultTypeInternal;
extern MarkerInfoDefaultTypeInternal _MarkerInfo_default_instance_;
class MultiControllerInfoRequest;
class MultiControllerInfoRequestDefaultTypeInternal;
extern MultiControllerInfoRequestDefaultTypeInternal _MultiControllerInfoRequest_default_instance_;
class ObjectDetectionReply;
class ObjectDetectionReplyDefaultTypeInternal;
extern ObjectDetectionReplyDefaultTypeInternal _ObjectDetectionReply_default_instance_;
class SetCvsCameraField;
class SetCvsCameraFieldDefaultTypeInternal;
extern SetCvsCameraFieldDefaultTypeInternal _SetCvsCameraField_default_instance_;
class SkeletonReply;
class SkeletonReplyDefaultTypeInternal;
extern SkeletonReplyDefaultTypeInternal _SkeletonReply_default_instance_;
class TrackedMarker;
class TrackedMarkerDefaultTypeInternal;
extern TrackedMarkerDefaultTypeInternal _TrackedMarker_default_instance_;
class TrackedObject;
class TrackedObjectDefaultTypeInternal;
extern TrackedObjectDefaultTypeInternal _TrackedObject_default_instance_;
class TrackedObjectInfo;
class TrackedObjectInfoDefaultTypeInternal;
extern TrackedObjectInfoDefaultTypeInternal _TrackedObjectInfo_default_instance_;
}  // namespace AR51
PROTOBUF_NAMESPACE_OPEN
template<> ::AR51::BoundInfo* Arena::CreateMaybeMessage<::AR51::BoundInfo>(Arena*);
template<> ::AR51::CalibrationPointCloudMessage* Arena::CreateMaybeMessage<::AR51::CalibrationPointCloudMessage>(Arena*);
template<> ::AR51::CalibrationStatus* Arena::CreateMaybeMessage<::AR51::CalibrationStatus>(Arena*);
template<> ::AR51::CalibrationVisualizationMessage* Arena::CreateMaybeMessage<::AR51::CalibrationVisualizationMessage>(Arena*);
template<> ::AR51::ControllerInfoRequest* Arena::CreateMaybeMessage<::AR51::ControllerInfoRequest>(Arena*);
template<> ::AR51::CvsCameraFeedRequest* Arena::CreateMaybeMessage<::AR51::CvsCameraFeedRequest>(Arena*);
template<> ::AR51::CvsCameraFeedResponse* Arena::CreateMaybeMessage<::AR51::CvsCameraFeedResponse>(Arena*);
template<> ::AR51::CvsCameraGetRecordingReadyRequest* Arena::CreateMaybeMessage<::AR51::CvsCameraGetRecordingReadyRequest>(Arena*);
template<> ::AR51::CvsCameraIdRequest* Arena::CreateMaybeMessage<::AR51::CvsCameraIdRequest>(Arena*);
template<> ::AR51::CvsCameraInfo* Arena::CreateMaybeMessage<::AR51::CvsCameraInfo>(Arena*);
template<> ::AR51::DeviceInfo* Arena::CreateMaybeMessage<::AR51::DeviceInfo>(Arena*);
template<> ::AR51::GetAvailableCamerasResponse* Arena::CreateMaybeMessage<::AR51::GetAvailableCamerasResponse>(Arena*);
template<> ::AR51::GetCvsCameraField* Arena::CreateMaybeMessage<::AR51::GetCvsCameraField>(Arena*);
template<> ::AR51::HandsInfoRequest* Arena::CreateMaybeMessage<::AR51::HandsInfoRequest>(Arena*);
template<> ::AR51::HelloReply* Arena::CreateMaybeMessage<::AR51::HelloReply>(Arena*);
template<> ::AR51::HelloRequest* Arena::CreateMaybeMessage<::AR51::HelloRequest>(Arena*);
template<> ::AR51::MarkerInfo* Arena::CreateMaybeMessage<::AR51::MarkerInfo>(Arena*);
template<> ::AR51::MultiControllerInfoRequest* Arena::CreateMaybeMessage<::AR51::MultiControllerInfoRequest>(Arena*);
template<> ::AR51::ObjectDetectionReply* Arena::CreateMaybeMessage<::AR51::ObjectDetectionReply>(Arena*);
template<> ::AR51::SetCvsCameraField* Arena::CreateMaybeMessage<::AR51::SetCvsCameraField>(Arena*);
template<> ::AR51::SkeletonReply* Arena::CreateMaybeMessage<::AR51::SkeletonReply>(Arena*);
template<> ::AR51::TrackedMarker* Arena::CreateMaybeMessage<::AR51::TrackedMarker>(Arena*);
template<> ::AR51::TrackedObject* Arena::CreateMaybeMessage<::AR51::TrackedObject>(Arena*);
template<> ::AR51::TrackedObjectInfo* Arena::CreateMaybeMessage<::AR51::TrackedObjectInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace AR51 {

enum ControllerButton : int {
  ButtonX = 0,
  ButtonY = 1,
  ButtonA = 2,
  ButtonB = 3,
  Trigger = 4,
  ControllerButton_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ControllerButton_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ControllerButton_IsValid(int value);
constexpr ControllerButton ControllerButton_MIN = ButtonX;
constexpr ControllerButton ControllerButton_MAX = Trigger;
constexpr int ControllerButton_ARRAYSIZE = ControllerButton_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ControllerButton_descriptor();
template<typename T>
inline const std::string& ControllerButton_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ControllerButton>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ControllerButton_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ControllerButton_descriptor(), enum_t_value);
}
inline bool ControllerButton_Parse(
    const std::string& name, ControllerButton* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ControllerButton>(
    ControllerButton_descriptor(), name, value);
}
enum ControllerButtonStatus : int {
  Up = 0,
  Down = 1,
  Pressed = 2,
  ControllerButtonStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ControllerButtonStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ControllerButtonStatus_IsValid(int value);
constexpr ControllerButtonStatus ControllerButtonStatus_MIN = Up;
constexpr ControllerButtonStatus ControllerButtonStatus_MAX = Pressed;
constexpr int ControllerButtonStatus_ARRAYSIZE = ControllerButtonStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ControllerButtonStatus_descriptor();
template<typename T>
inline const std::string& ControllerButtonStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ControllerButtonStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ControllerButtonStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ControllerButtonStatus_descriptor(), enum_t_value);
}
inline bool ControllerButtonStatus_Parse(
    const std::string& name, ControllerButtonStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ControllerButtonStatus>(
    ControllerButtonStatus_descriptor(), name, value);
}
enum CalibrationModes : int {
  CalibrationModeIdle = 0,
  CalibrationModeCamera = 1,
  CalibrationModeDevice = 2,
  CalibrationModes_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CalibrationModes_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CalibrationModes_IsValid(int value);
constexpr CalibrationModes CalibrationModes_MIN = CalibrationModeIdle;
constexpr CalibrationModes CalibrationModes_MAX = CalibrationModeDevice;
constexpr int CalibrationModes_ARRAYSIZE = CalibrationModes_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CalibrationModes_descriptor();
template<typename T>
inline const std::string& CalibrationModes_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CalibrationModes>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CalibrationModes_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CalibrationModes_descriptor(), enum_t_value);
}
inline bool CalibrationModes_Parse(
    const std::string& name, CalibrationModes* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CalibrationModes>(
    CalibrationModes_descriptor(), name, value);
}
// ===================================================================

class HelloRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.HelloRequest) */ {
 public:
  HelloRequest();
  virtual ~HelloRequest();

  HelloRequest(const HelloRequest& from);
  HelloRequest(HelloRequest&& from) noexcept
    : HelloRequest() {
    *this = ::std::move(from);
  }

  inline HelloRequest& operator=(const HelloRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloRequest& operator=(HelloRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HelloRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelloRequest* internal_default_instance() {
    return reinterpret_cast<const HelloRequest*>(
               &_HelloRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(HelloRequest* other);
  friend void swap(HelloRequest& a, HelloRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HelloRequest* New() const final {
    return CreateMaybeMessage<HelloRequest>(nullptr);
  }

  HelloRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HelloRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HelloRequest& from);
  void MergeFrom(const HelloRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.HelloRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // @@protoc_insertion_point(class_scope:AR51.HelloRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class HelloReply :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.HelloReply) */ {
 public:
  HelloReply();
  virtual ~HelloReply();

  HelloReply(const HelloReply& from);
  HelloReply(HelloReply&& from) noexcept
    : HelloReply() {
    *this = ::std::move(from);
  }

  inline HelloReply& operator=(const HelloReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloReply& operator=(HelloReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HelloReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelloReply* internal_default_instance() {
    return reinterpret_cast<const HelloReply*>(
               &_HelloReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(HelloReply* other);
  friend void swap(HelloReply& a, HelloReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HelloReply* New() const final {
    return CreateMaybeMessage<HelloReply>(nullptr);
  }

  HelloReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HelloReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HelloReply& from);
  void MergeFrom(const HelloReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.HelloReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);

  // @@protoc_insertion_point(class_scope:AR51.HelloReply)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class HandsInfoRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.HandsInfoRequest) */ {
 public:
  HandsInfoRequest();
  virtual ~HandsInfoRequest();

  HandsInfoRequest(const HandsInfoRequest& from);
  HandsInfoRequest(HandsInfoRequest&& from) noexcept
    : HandsInfoRequest() {
    *this = ::std::move(from);
  }

  inline HandsInfoRequest& operator=(const HandsInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandsInfoRequest& operator=(HandsInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HandsInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HandsInfoRequest* internal_default_instance() {
    return reinterpret_cast<const HandsInfoRequest*>(
               &_HandsInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(HandsInfoRequest* other);
  friend void swap(HandsInfoRequest& a, HandsInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HandsInfoRequest* New() const final {
    return CreateMaybeMessage<HandsInfoRequest>(nullptr);
  }

  HandsInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HandsInfoRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HandsInfoRequest& from);
  void MergeFrom(const HandsInfoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandsInfoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.HandsInfoRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string SkeletonId = 1;
  void clear_skeletonid();
  static const int kSkeletonIdFieldNumber = 1;
  const std::string& skeletonid() const;
  void set_skeletonid(const std::string& value);
  void set_skeletonid(std::string&& value);
  void set_skeletonid(const char* value);
  void set_skeletonid(const char* value, size_t size);
  std::string* mutable_skeletonid();
  std::string* release_skeletonid();
  void set_allocated_skeletonid(std::string* skeletonid);

  // bytes LeftHandRotation = 4;
  void clear_lefthandrotation();
  static const int kLeftHandRotationFieldNumber = 4;
  const std::string& lefthandrotation() const;
  void set_lefthandrotation(const std::string& value);
  void set_lefthandrotation(std::string&& value);
  void set_lefthandrotation(const char* value);
  void set_lefthandrotation(const void* value, size_t size);
  std::string* mutable_lefthandrotation();
  std::string* release_lefthandrotation();
  void set_allocated_lefthandrotation(std::string* lefthandrotation);

  // bytes RightHandRotation = 5;
  void clear_righthandrotation();
  static const int kRightHandRotationFieldNumber = 5;
  const std::string& righthandrotation() const;
  void set_righthandrotation(const std::string& value);
  void set_righthandrotation(std::string&& value);
  void set_righthandrotation(const char* value);
  void set_righthandrotation(const void* value, size_t size);
  std::string* mutable_righthandrotation();
  std::string* release_righthandrotation();
  void set_allocated_righthandrotation(std::string* righthandrotation);

  // bytes LeftHandPositions = 7;
  void clear_lefthandpositions();
  static const int kLeftHandPositionsFieldNumber = 7;
  const std::string& lefthandpositions() const;
  void set_lefthandpositions(const std::string& value);
  void set_lefthandpositions(std::string&& value);
  void set_lefthandpositions(const char* value);
  void set_lefthandpositions(const void* value, size_t size);
  std::string* mutable_lefthandpositions();
  std::string* release_lefthandpositions();
  void set_allocated_lefthandpositions(std::string* lefthandpositions);

  // bytes RightHandPositions = 8;
  void clear_righthandpositions();
  static const int kRightHandPositionsFieldNumber = 8;
  const std::string& righthandpositions() const;
  void set_righthandpositions(const std::string& value);
  void set_righthandpositions(std::string&& value);
  void set_righthandpositions(const char* value);
  void set_righthandpositions(const void* value, size_t size);
  std::string* mutable_righthandpositions();
  std::string* release_righthandpositions();
  void set_allocated_righthandpositions(std::string* righthandpositions);

  // string DeviceId = 9;
  void clear_deviceid();
  static const int kDeviceIdFieldNumber = 9;
  const std::string& deviceid() const;
  void set_deviceid(const std::string& value);
  void set_deviceid(std::string&& value);
  void set_deviceid(const char* value);
  void set_deviceid(const char* value, size_t size);
  std::string* mutable_deviceid();
  std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);

  // string CharacterPrefab = 10;
  void clear_characterprefab();
  static const int kCharacterPrefabFieldNumber = 10;
  const std::string& characterprefab() const;
  void set_characterprefab(const std::string& value);
  void set_characterprefab(std::string&& value);
  void set_characterprefab(const char* value);
  void set_characterprefab(const char* value, size_t size);
  std::string* mutable_characterprefab();
  std::string* release_characterprefab();
  void set_allocated_characterprefab(std::string* characterprefab);

  // .AR51.Vector3 LeftWristPosition = 2;
  bool has_leftwristposition() const;
  void clear_leftwristposition();
  static const int kLeftWristPositionFieldNumber = 2;
  const ::AR51::Vector3& leftwristposition() const;
  ::AR51::Vector3* release_leftwristposition();
  ::AR51::Vector3* mutable_leftwristposition();
  void set_allocated_leftwristposition(::AR51::Vector3* leftwristposition);

  // .AR51.Vector3 RightWristPosition = 3;
  bool has_rightwristposition() const;
  void clear_rightwristposition();
  static const int kRightWristPositionFieldNumber = 3;
  const ::AR51::Vector3& rightwristposition() const;
  ::AR51::Vector3* release_rightwristposition();
  ::AR51::Vector3* mutable_rightwristposition();
  void set_allocated_rightwristposition(::AR51::Vector3* rightwristposition);

  // .AR51.Quaternion HeadLocalRotation = 6;
  bool has_headlocalrotation() const;
  void clear_headlocalrotation();
  static const int kHeadLocalRotationFieldNumber = 6;
  const ::AR51::Quaternion& headlocalrotation() const;
  ::AR51::Quaternion* release_headlocalrotation();
  ::AR51::Quaternion* mutable_headlocalrotation();
  void set_allocated_headlocalrotation(::AR51::Quaternion* headlocalrotation);

  // @@protoc_insertion_point(class_scope:AR51.HandsInfoRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr skeletonid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lefthandrotation_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr righthandrotation_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lefthandpositions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr righthandpositions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr characterprefab_;
  ::AR51::Vector3* leftwristposition_;
  ::AR51::Vector3* rightwristposition_;
  ::AR51::Quaternion* headlocalrotation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class ControllerInfoRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.ControllerInfoRequest) */ {
 public:
  ControllerInfoRequest();
  virtual ~ControllerInfoRequest();

  ControllerInfoRequest(const ControllerInfoRequest& from);
  ControllerInfoRequest(ControllerInfoRequest&& from) noexcept
    : ControllerInfoRequest() {
    *this = ::std::move(from);
  }

  inline ControllerInfoRequest& operator=(const ControllerInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerInfoRequest& operator=(ControllerInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControllerInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerInfoRequest* internal_default_instance() {
    return reinterpret_cast<const ControllerInfoRequest*>(
               &_ControllerInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ControllerInfoRequest* other);
  friend void swap(ControllerInfoRequest& a, ControllerInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerInfoRequest* New() const final {
    return CreateMaybeMessage<ControllerInfoRequest>(nullptr);
  }

  ControllerInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerInfoRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControllerInfoRequest& from);
  void MergeFrom(const ControllerInfoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerInfoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.ControllerInfoRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AR51.ControllerButton Buttons = 4;
  int buttons_size() const;
  void clear_buttons();
  static const int kButtonsFieldNumber = 4;
  ::AR51::ControllerButton buttons(int index) const;
  void set_buttons(int index, ::AR51::ControllerButton value);
  void add_buttons(::AR51::ControllerButton value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& buttons() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_buttons();

  // repeated .AR51.ControllerButtonStatus ButtonStatus = 5;
  int buttonstatus_size() const;
  void clear_buttonstatus();
  static const int kButtonStatusFieldNumber = 5;
  ::AR51::ControllerButtonStatus buttonstatus(int index) const;
  void set_buttonstatus(int index, ::AR51::ControllerButtonStatus value);
  void add_buttonstatus(::AR51::ControllerButtonStatus value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& buttonstatus() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_buttonstatus();

  // bytes LocalToWorldLH = 2;
  void clear_localtoworldlh();
  static const int kLocalToWorldLHFieldNumber = 2;
  const std::string& localtoworldlh() const;
  void set_localtoworldlh(const std::string& value);
  void set_localtoworldlh(std::string&& value);
  void set_localtoworldlh(const char* value);
  void set_localtoworldlh(const void* value, size_t size);
  std::string* mutable_localtoworldlh();
  std::string* release_localtoworldlh();
  void set_allocated_localtoworldlh(std::string* localtoworldlh);

  // bytes LocalToAnchorLH = 3;
  void clear_localtoanchorlh();
  static const int kLocalToAnchorLHFieldNumber = 3;
  const std::string& localtoanchorlh() const;
  void set_localtoanchorlh(const std::string& value);
  void set_localtoanchorlh(std::string&& value);
  void set_localtoanchorlh(const char* value);
  void set_localtoanchorlh(const void* value, size_t size);
  std::string* mutable_localtoanchorlh();
  std::string* release_localtoanchorlh();
  void set_allocated_localtoanchorlh(std::string* localtoanchorlh);

  // bool IsDetected = 1;
  void clear_isdetected();
  static const int kIsDetectedFieldNumber = 1;
  bool isdetected() const;
  void set_isdetected(bool value);

  // @@protoc_insertion_point(class_scope:AR51.ControllerInfoRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> buttons_;
  mutable std::atomic<int> _buttons_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> buttonstatus_;
  mutable std::atomic<int> _buttonstatus_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr localtoworldlh_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr localtoanchorlh_;
  bool isdetected_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class MultiControllerInfoRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.MultiControllerInfoRequest) */ {
 public:
  MultiControllerInfoRequest();
  virtual ~MultiControllerInfoRequest();

  MultiControllerInfoRequest(const MultiControllerInfoRequest& from);
  MultiControllerInfoRequest(MultiControllerInfoRequest&& from) noexcept
    : MultiControllerInfoRequest() {
    *this = ::std::move(from);
  }

  inline MultiControllerInfoRequest& operator=(const MultiControllerInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiControllerInfoRequest& operator=(MultiControllerInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MultiControllerInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiControllerInfoRequest* internal_default_instance() {
    return reinterpret_cast<const MultiControllerInfoRequest*>(
               &_MultiControllerInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(MultiControllerInfoRequest* other);
  friend void swap(MultiControllerInfoRequest& a, MultiControllerInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiControllerInfoRequest* New() const final {
    return CreateMaybeMessage<MultiControllerInfoRequest>(nullptr);
  }

  MultiControllerInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiControllerInfoRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MultiControllerInfoRequest& from);
  void MergeFrom(const MultiControllerInfoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiControllerInfoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.MultiControllerInfoRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string SkeletonId = 1;
  void clear_skeletonid();
  static const int kSkeletonIdFieldNumber = 1;
  const std::string& skeletonid() const;
  void set_skeletonid(const std::string& value);
  void set_skeletonid(std::string&& value);
  void set_skeletonid(const char* value);
  void set_skeletonid(const char* value, size_t size);
  std::string* mutable_skeletonid();
  std::string* release_skeletonid();
  void set_allocated_skeletonid(std::string* skeletonid);

  // .AR51.ControllerInfoRequest LeftController = 2;
  bool has_leftcontroller() const;
  void clear_leftcontroller();
  static const int kLeftControllerFieldNumber = 2;
  const ::AR51::ControllerInfoRequest& leftcontroller() const;
  ::AR51::ControllerInfoRequest* release_leftcontroller();
  ::AR51::ControllerInfoRequest* mutable_leftcontroller();
  void set_allocated_leftcontroller(::AR51::ControllerInfoRequest* leftcontroller);

  // .AR51.ControllerInfoRequest RightController = 3;
  bool has_rightcontroller() const;
  void clear_rightcontroller();
  static const int kRightControllerFieldNumber = 3;
  const ::AR51::ControllerInfoRequest& rightcontroller() const;
  ::AR51::ControllerInfoRequest* release_rightcontroller();
  ::AR51::ControllerInfoRequest* mutable_rightcontroller();
  void set_allocated_rightcontroller(::AR51::ControllerInfoRequest* rightcontroller);

  // @@protoc_insertion_point(class_scope:AR51.MultiControllerInfoRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr skeletonid_;
  ::AR51::ControllerInfoRequest* leftcontroller_;
  ::AR51::ControllerInfoRequest* rightcontroller_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class SkeletonReply :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.SkeletonReply) */ {
 public:
  SkeletonReply();
  virtual ~SkeletonReply();

  SkeletonReply(const SkeletonReply& from);
  SkeletonReply(SkeletonReply&& from) noexcept
    : SkeletonReply() {
    *this = ::std::move(from);
  }

  inline SkeletonReply& operator=(const SkeletonReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SkeletonReply& operator=(SkeletonReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SkeletonReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SkeletonReply* internal_default_instance() {
    return reinterpret_cast<const SkeletonReply*>(
               &_SkeletonReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(SkeletonReply* other);
  friend void swap(SkeletonReply& a, SkeletonReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SkeletonReply* New() const final {
    return CreateMaybeMessage<SkeletonReply>(nullptr);
  }

  SkeletonReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SkeletonReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SkeletonReply& from);
  void MergeFrom(const SkeletonReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SkeletonReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.SkeletonReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);

  // string AnchorId = 2;
  void clear_anchorid();
  static const int kAnchorIdFieldNumber = 2;
  const std::string& anchorid() const;
  void set_anchorid(const std::string& value);
  void set_anchorid(std::string&& value);
  void set_anchorid(const char* value);
  void set_anchorid(const char* value, size_t size);
  std::string* mutable_anchorid();
  std::string* release_anchorid();
  void set_allocated_anchorid(std::string* anchorid);

  // bytes Positions = 3;
  void clear_positions();
  static const int kPositionsFieldNumber = 3;
  const std::string& positions() const;
  void set_positions(const std::string& value);
  void set_positions(std::string&& value);
  void set_positions(const char* value);
  void set_positions(const void* value, size_t size);
  std::string* mutable_positions();
  std::string* release_positions();
  void set_allocated_positions(std::string* positions);

  // bytes LeftHandRotation = 4;
  void clear_lefthandrotation();
  static const int kLeftHandRotationFieldNumber = 4;
  const std::string& lefthandrotation() const;
  void set_lefthandrotation(const std::string& value);
  void set_lefthandrotation(std::string&& value);
  void set_lefthandrotation(const char* value);
  void set_lefthandrotation(const void* value, size_t size);
  std::string* mutable_lefthandrotation();
  std::string* release_lefthandrotation();
  void set_allocated_lefthandrotation(std::string* lefthandrotation);

  // bytes RightHandRotation = 5;
  void clear_righthandrotation();
  static const int kRightHandRotationFieldNumber = 5;
  const std::string& righthandrotation() const;
  void set_righthandrotation(const std::string& value);
  void set_righthandrotation(std::string&& value);
  void set_righthandrotation(const char* value);
  void set_righthandrotation(const void* value, size_t size);
  std::string* mutable_righthandrotation();
  std::string* release_righthandrotation();
  void set_allocated_righthandrotation(std::string* righthandrotation);

  // bytes LeftHandPositions = 11;
  void clear_lefthandpositions();
  static const int kLeftHandPositionsFieldNumber = 11;
  const std::string& lefthandpositions() const;
  void set_lefthandpositions(const std::string& value);
  void set_lefthandpositions(std::string&& value);
  void set_lefthandpositions(const char* value);
  void set_lefthandpositions(const void* value, size_t size);
  std::string* mutable_lefthandpositions();
  std::string* release_lefthandpositions();
  void set_allocated_lefthandpositions(std::string* lefthandpositions);

  // bytes RightHandPositions = 12;
  void clear_righthandpositions();
  static const int kRightHandPositionsFieldNumber = 12;
  const std::string& righthandpositions() const;
  void set_righthandpositions(const std::string& value);
  void set_righthandpositions(std::string&& value);
  void set_righthandpositions(const char* value);
  void set_righthandpositions(const void* value, size_t size);
  std::string* mutable_righthandpositions();
  std::string* release_righthandpositions();
  void set_allocated_righthandpositions(std::string* righthandpositions);

  // bytes Confidence = 14;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 14;
  const std::string& confidence() const;
  void set_confidence(const std::string& value);
  void set_confidence(std::string&& value);
  void set_confidence(const char* value);
  void set_confidence(const void* value, size_t size);
  std::string* mutable_confidence();
  std::string* release_confidence();
  void set_allocated_confidence(std::string* confidence);

  // string DeviceId = 16;
  void clear_deviceid();
  static const int kDeviceIdFieldNumber = 16;
  const std::string& deviceid() const;
  void set_deviceid(const std::string& value);
  void set_deviceid(std::string&& value);
  void set_deviceid(const char* value);
  void set_deviceid(const char* value, size_t size);
  std::string* mutable_deviceid();
  std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);

  // string CharacterPrefab = 17;
  void clear_characterprefab();
  static const int kCharacterPrefabFieldNumber = 17;
  const std::string& characterprefab() const;
  void set_characterprefab(const std::string& value);
  void set_characterprefab(std::string&& value);
  void set_characterprefab(const char* value);
  void set_characterprefab(const char* value, size_t size);
  std::string* mutable_characterprefab();
  std::string* release_characterprefab();
  void set_allocated_characterprefab(std::string* characterprefab);

  // .AR51.Quaternion HeadLocalRotation = 7;
  bool has_headlocalrotation() const;
  void clear_headlocalrotation();
  static const int kHeadLocalRotationFieldNumber = 7;
  const ::AR51::Quaternion& headlocalrotation() const;
  ::AR51::Quaternion* release_headlocalrotation();
  ::AR51::Quaternion* mutable_headlocalrotation();
  void set_allocated_headlocalrotation(::AR51::Quaternion* headlocalrotation);

  // .AR51.Vector3 LeftWristPosition = 9;
  bool has_leftwristposition() const;
  void clear_leftwristposition();
  static const int kLeftWristPositionFieldNumber = 9;
  const ::AR51::Vector3& leftwristposition() const;
  ::AR51::Vector3* release_leftwristposition();
  ::AR51::Vector3* mutable_leftwristposition();
  void set_allocated_leftwristposition(::AR51::Vector3* leftwristposition);

  // .AR51.Vector3 RightWristPosition = 10;
  bool has_rightwristposition() const;
  void clear_rightwristposition();
  static const int kRightWristPositionFieldNumber = 10;
  const ::AR51::Vector3& rightwristposition() const;
  ::AR51::Vector3* release_rightwristposition();
  ::AR51::Vector3* mutable_rightwristposition();
  void set_allocated_rightwristposition(::AR51::Vector3* rightwristposition);

  // .AR51.MultiControllerInfoRequest MultiControllerInfo = 15;
  bool has_multicontrollerinfo() const;
  void clear_multicontrollerinfo();
  static const int kMultiControllerInfoFieldNumber = 15;
  const ::AR51::MultiControllerInfoRequest& multicontrollerinfo() const;
  ::AR51::MultiControllerInfoRequest* release_multicontrollerinfo();
  ::AR51::MultiControllerInfoRequest* mutable_multicontrollerinfo();
  void set_allocated_multicontrollerinfo(::AR51::MultiControllerInfoRequest* multicontrollerinfo);

  // double CaptureTime = 13;
  void clear_capturetime();
  static const int kCaptureTimeFieldNumber = 13;
  double capturetime() const;
  void set_capturetime(double value);

  // bool HasHeadLocalRotation = 6;
  void clear_hasheadlocalrotation();
  static const int kHasHeadLocalRotationFieldNumber = 6;
  bool hasheadlocalrotation() const;
  void set_hasheadlocalrotation(bool value);

  // bool HasWristPositions = 8;
  void clear_haswristpositions();
  static const int kHasWristPositionsFieldNumber = 8;
  bool haswristpositions() const;
  void set_haswristpositions(bool value);

  // @@protoc_insertion_point(class_scope:AR51.SkeletonReply)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr anchorid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr positions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lefthandrotation_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr righthandrotation_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lefthandpositions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr righthandpositions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr confidence_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr characterprefab_;
  ::AR51::Quaternion* headlocalrotation_;
  ::AR51::Vector3* leftwristposition_;
  ::AR51::Vector3* rightwristposition_;
  ::AR51::MultiControllerInfoRequest* multicontrollerinfo_;
  double capturetime_;
  bool hasheadlocalrotation_;
  bool haswristpositions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class BoundInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.BoundInfo) */ {
 public:
  BoundInfo();
  virtual ~BoundInfo();

  BoundInfo(const BoundInfo& from);
  BoundInfo(BoundInfo&& from) noexcept
    : BoundInfo() {
    *this = ::std::move(from);
  }

  inline BoundInfo& operator=(const BoundInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoundInfo& operator=(BoundInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BoundInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoundInfo* internal_default_instance() {
    return reinterpret_cast<const BoundInfo*>(
               &_BoundInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(BoundInfo* other);
  friend void swap(BoundInfo& a, BoundInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoundInfo* New() const final {
    return CreateMaybeMessage<BoundInfo>(nullptr);
  }

  BoundInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BoundInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BoundInfo& from);
  void MergeFrom(const BoundInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoundInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.BoundInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .AR51.Vector3 Center = 1;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 1;
  const ::AR51::Vector3& center() const;
  ::AR51::Vector3* release_center();
  ::AR51::Vector3* mutable_center();
  void set_allocated_center(::AR51::Vector3* center);

  // .AR51.Vector3 Extents = 2;
  bool has_extents() const;
  void clear_extents();
  static const int kExtentsFieldNumber = 2;
  const ::AR51::Vector3& extents() const;
  ::AR51::Vector3* release_extents();
  ::AR51::Vector3* mutable_extents();
  void set_allocated_extents(::AR51::Vector3* extents);

  // @@protoc_insertion_point(class_scope:AR51.BoundInfo)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::AR51::Vector3* center_;
  ::AR51::Vector3* extents_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class DeviceInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.DeviceInfo) */ {
 public:
  DeviceInfo();
  virtual ~DeviceInfo();

  DeviceInfo(const DeviceInfo& from);
  DeviceInfo(DeviceInfo&& from) noexcept
    : DeviceInfo() {
    *this = ::std::move(from);
  }

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInfo& operator=(DeviceInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeviceInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceInfo*>(
               &_DeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(DeviceInfo* other);
  friend void swap(DeviceInfo& a, DeviceInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceInfo* New() const final {
    return CreateMaybeMessage<DeviceInfo>(nullptr);
  }

  DeviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeviceInfo& from);
  void MergeFrom(const DeviceInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.DeviceInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string IpAddress = 2;
  void clear_ipaddress();
  static const int kIpAddressFieldNumber = 2;
  const std::string& ipaddress() const;
  void set_ipaddress(const std::string& value);
  void set_ipaddress(std::string&& value);
  void set_ipaddress(const char* value);
  void set_ipaddress(const char* value, size_t size);
  std::string* mutable_ipaddress();
  std::string* release_ipaddress();
  void set_allocated_ipaddress(std::string* ipaddress);

  // @@protoc_insertion_point(class_scope:AR51.DeviceInfo)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipaddress_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class CalibrationStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.CalibrationStatus) */ {
 public:
  CalibrationStatus();
  virtual ~CalibrationStatus();

  CalibrationStatus(const CalibrationStatus& from);
  CalibrationStatus(CalibrationStatus&& from) noexcept
    : CalibrationStatus() {
    *this = ::std::move(from);
  }

  inline CalibrationStatus& operator=(const CalibrationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CalibrationStatus& operator=(CalibrationStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CalibrationStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CalibrationStatus* internal_default_instance() {
    return reinterpret_cast<const CalibrationStatus*>(
               &_CalibrationStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CalibrationStatus* other);
  friend void swap(CalibrationStatus& a, CalibrationStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CalibrationStatus* New() const final {
    return CreateMaybeMessage<CalibrationStatus>(nullptr);
  }

  CalibrationStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CalibrationStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CalibrationStatus& from);
  void MergeFrom(const CalibrationStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CalibrationStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.CalibrationStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Result = 4;
  void clear_result();
  static const int kResultFieldNumber = 4;
  const std::string& result() const;
  void set_result(const std::string& value);
  void set_result(std::string&& value);
  void set_result(const char* value);
  void set_result(const char* value, size_t size);
  std::string* mutable_result();
  std::string* release_result();
  void set_allocated_result(std::string* result);

  // string AnchorId = 5;
  void clear_anchorid();
  static const int kAnchorIdFieldNumber = 5;
  const std::string& anchorid() const;
  void set_anchorid(const std::string& value);
  void set_anchorid(std::string&& value);
  void set_anchorid(const char* value);
  void set_anchorid(const char* value, size_t size);
  std::string* mutable_anchorid();
  std::string* release_anchorid();
  void set_allocated_anchorid(std::string* anchorid);

  // double Progress = 1;
  void clear_progress();
  static const int kProgressFieldNumber = 1;
  double progress() const;
  void set_progress(double value);

  // double Quality = 2;
  void clear_quality();
  static const int kQualityFieldNumber = 2;
  double quality() const;
  void set_quality(double value);

  // double ReprojectionError = 3;
  void clear_reprojectionerror();
  static const int kReprojectionErrorFieldNumber = 3;
  double reprojectionerror() const;
  void set_reprojectionerror(double value);

  // int32 AnchorByteSize = 6;
  void clear_anchorbytesize();
  static const int kAnchorByteSizeFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::int32 anchorbytesize() const;
  void set_anchorbytesize(::PROTOBUF_NAMESPACE_ID::int32 value);

  // .AR51.CalibrationModes Mode = 7;
  void clear_mode();
  static const int kModeFieldNumber = 7;
  ::AR51::CalibrationModes mode() const;
  void set_mode(::AR51::CalibrationModes value);

  // @@protoc_insertion_point(class_scope:AR51.CalibrationStatus)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr anchorid_;
  double progress_;
  double quality_;
  double reprojectionerror_;
  ::PROTOBUF_NAMESPACE_ID::int32 anchorbytesize_;
  int mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class CalibrationPointCloudMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.CalibrationPointCloudMessage) */ {
 public:
  CalibrationPointCloudMessage();
  virtual ~CalibrationPointCloudMessage();

  CalibrationPointCloudMessage(const CalibrationPointCloudMessage& from);
  CalibrationPointCloudMessage(CalibrationPointCloudMessage&& from) noexcept
    : CalibrationPointCloudMessage() {
    *this = ::std::move(from);
  }

  inline CalibrationPointCloudMessage& operator=(const CalibrationPointCloudMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CalibrationPointCloudMessage& operator=(CalibrationPointCloudMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CalibrationPointCloudMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CalibrationPointCloudMessage* internal_default_instance() {
    return reinterpret_cast<const CalibrationPointCloudMessage*>(
               &_CalibrationPointCloudMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(CalibrationPointCloudMessage* other);
  friend void swap(CalibrationPointCloudMessage& a, CalibrationPointCloudMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CalibrationPointCloudMessage* New() const final {
    return CreateMaybeMessage<CalibrationPointCloudMessage>(nullptr);
  }

  CalibrationPointCloudMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CalibrationPointCloudMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CalibrationPointCloudMessage& from);
  void MergeFrom(const CalibrationPointCloudMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CalibrationPointCloudMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.CalibrationPointCloudMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // bytes Points = 7;
  void clear_points();
  static const int kPointsFieldNumber = 7;
  const std::string& points() const;
  void set_points(const std::string& value);
  void set_points(std::string&& value);
  void set_points(const char* value);
  void set_points(const void* value, size_t size);
  std::string* mutable_points();
  std::string* release_points();
  void set_allocated_points(std::string* points);

  // .AR51.Color StartColor = 3;
  bool has_startcolor() const;
  void clear_startcolor();
  static const int kStartColorFieldNumber = 3;
  const ::AR51::Color& startcolor() const;
  ::AR51::Color* release_startcolor();
  ::AR51::Color* mutable_startcolor();
  void set_allocated_startcolor(::AR51::Color* startcolor);

  // .AR51.Color EndColor = 4;
  bool has_endcolor() const;
  void clear_endcolor();
  static const int kEndColorFieldNumber = 4;
  const ::AR51::Color& endcolor() const;
  ::AR51::Color* release_endcolor();
  ::AR51::Color* mutable_endcolor();
  void set_allocated_endcolor(::AR51::Color* endcolor);

  // double StartSize = 5;
  void clear_startsize();
  static const int kStartSizeFieldNumber = 5;
  double startsize() const;
  void set_startsize(double value);

  // double EndSize = 6;
  void clear_endsize();
  static const int kEndSizeFieldNumber = 6;
  double endsize() const;
  void set_endsize(double value);

  // int32 Count = 2;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:AR51.CalibrationPointCloudMessage)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr points_;
  ::AR51::Color* startcolor_;
  ::AR51::Color* endcolor_;
  double startsize_;
  double endsize_;
  ::PROTOBUF_NAMESPACE_ID::int32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class CalibrationVisualizationMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.CalibrationVisualizationMessage) */ {
 public:
  CalibrationVisualizationMessage();
  virtual ~CalibrationVisualizationMessage();

  CalibrationVisualizationMessage(const CalibrationVisualizationMessage& from);
  CalibrationVisualizationMessage(CalibrationVisualizationMessage&& from) noexcept
    : CalibrationVisualizationMessage() {
    *this = ::std::move(from);
  }

  inline CalibrationVisualizationMessage& operator=(const CalibrationVisualizationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CalibrationVisualizationMessage& operator=(CalibrationVisualizationMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CalibrationVisualizationMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CalibrationVisualizationMessage* internal_default_instance() {
    return reinterpret_cast<const CalibrationVisualizationMessage*>(
               &_CalibrationVisualizationMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CalibrationVisualizationMessage* other);
  friend void swap(CalibrationVisualizationMessage& a, CalibrationVisualizationMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CalibrationVisualizationMessage* New() const final {
    return CreateMaybeMessage<CalibrationVisualizationMessage>(nullptr);
  }

  CalibrationVisualizationMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CalibrationVisualizationMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CalibrationVisualizationMessage& from);
  void MergeFrom(const CalibrationVisualizationMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CalibrationVisualizationMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.CalibrationVisualizationMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AR51.CalibrationPointCloudMessage Points = 7;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 7;
  ::AR51::CalibrationPointCloudMessage* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::CalibrationPointCloudMessage >*
      mutable_points();
  const ::AR51::CalibrationPointCloudMessage& points(int index) const;
  ::AR51::CalibrationPointCloudMessage* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::CalibrationPointCloudMessage >&
      points() const;

  // string Title = 5;
  void clear_title();
  static const int kTitleFieldNumber = 5;
  const std::string& title() const;
  void set_title(const std::string& value);
  void set_title(std::string&& value);
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  std::string* mutable_title();
  std::string* release_title();
  void set_allocated_title(std::string* title);

  // string Message = 6;
  void clear_message();
  static const int kMessageFieldNumber = 6;
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);

  // double Progress = 2;
  void clear_progress();
  static const int kProgressFieldNumber = 2;
  double progress() const;
  void set_progress(double value);

  // double Quality = 3;
  void clear_quality();
  static const int kQualityFieldNumber = 3;
  double quality() const;
  void set_quality(double value);

  // double ReprojectionError = 4;
  void clear_reprojectionerror();
  static const int kReprojectionErrorFieldNumber = 4;
  double reprojectionerror() const;
  void set_reprojectionerror(double value);

  // .AR51.CalibrationModes Mode = 1;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  ::AR51::CalibrationModes mode() const;
  void set_mode(::AR51::CalibrationModes value);

  // @@protoc_insertion_point(class_scope:AR51.CalibrationVisualizationMessage)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::CalibrationPointCloudMessage > points_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  double progress_;
  double quality_;
  double reprojectionerror_;
  int mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class SetCvsCameraField :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.SetCvsCameraField) */ {
 public:
  SetCvsCameraField();
  virtual ~SetCvsCameraField();

  SetCvsCameraField(const SetCvsCameraField& from);
  SetCvsCameraField(SetCvsCameraField&& from) noexcept
    : SetCvsCameraField() {
    *this = ::std::move(from);
  }

  inline SetCvsCameraField& operator=(const SetCvsCameraField& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetCvsCameraField& operator=(SetCvsCameraField&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetCvsCameraField& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetCvsCameraField* internal_default_instance() {
    return reinterpret_cast<const SetCvsCameraField*>(
               &_SetCvsCameraField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SetCvsCameraField* other);
  friend void swap(SetCvsCameraField& a, SetCvsCameraField& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetCvsCameraField* New() const final {
    return CreateMaybeMessage<SetCvsCameraField>(nullptr);
  }

  SetCvsCameraField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetCvsCameraField>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetCvsCameraField& from);
  void MergeFrom(const SetCvsCameraField& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetCvsCameraField* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.SetCvsCameraField";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);

  // string FieldName = 2;
  void clear_fieldname();
  static const int kFieldNameFieldNumber = 2;
  const std::string& fieldname() const;
  void set_fieldname(const std::string& value);
  void set_fieldname(std::string&& value);
  void set_fieldname(const char* value);
  void set_fieldname(const char* value, size_t size);
  std::string* mutable_fieldname();
  std::string* release_fieldname();
  void set_allocated_fieldname(std::string* fieldname);

  // double Value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  double value() const;
  void set_value(double value);

  // @@protoc_insertion_point(class_scope:AR51.SetCvsCameraField)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fieldname_;
  double value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class GetCvsCameraField :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.GetCvsCameraField) */ {
 public:
  GetCvsCameraField();
  virtual ~GetCvsCameraField();

  GetCvsCameraField(const GetCvsCameraField& from);
  GetCvsCameraField(GetCvsCameraField&& from) noexcept
    : GetCvsCameraField() {
    *this = ::std::move(from);
  }

  inline GetCvsCameraField& operator=(const GetCvsCameraField& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCvsCameraField& operator=(GetCvsCameraField&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetCvsCameraField& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetCvsCameraField* internal_default_instance() {
    return reinterpret_cast<const GetCvsCameraField*>(
               &_GetCvsCameraField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(GetCvsCameraField* other);
  friend void swap(GetCvsCameraField& a, GetCvsCameraField& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetCvsCameraField* New() const final {
    return CreateMaybeMessage<GetCvsCameraField>(nullptr);
  }

  GetCvsCameraField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetCvsCameraField>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetCvsCameraField& from);
  void MergeFrom(const GetCvsCameraField& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCvsCameraField* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.GetCvsCameraField";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);

  // string FieldName = 2;
  void clear_fieldname();
  static const int kFieldNameFieldNumber = 2;
  const std::string& fieldname() const;
  void set_fieldname(const std::string& value);
  void set_fieldname(std::string&& value);
  void set_fieldname(const char* value);
  void set_fieldname(const char* value, size_t size);
  std::string* mutable_fieldname();
  std::string* release_fieldname();
  void set_allocated_fieldname(std::string* fieldname);

  // @@protoc_insertion_point(class_scope:AR51.GetCvsCameraField)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fieldname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class CvsCameraInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.CvsCameraInfo) */ {
 public:
  CvsCameraInfo();
  virtual ~CvsCameraInfo();

  CvsCameraInfo(const CvsCameraInfo& from);
  CvsCameraInfo(CvsCameraInfo&& from) noexcept
    : CvsCameraInfo() {
    *this = ::std::move(from);
  }

  inline CvsCameraInfo& operator=(const CvsCameraInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CvsCameraInfo& operator=(CvsCameraInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CvsCameraInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CvsCameraInfo* internal_default_instance() {
    return reinterpret_cast<const CvsCameraInfo*>(
               &_CvsCameraInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(CvsCameraInfo* other);
  friend void swap(CvsCameraInfo& a, CvsCameraInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CvsCameraInfo* New() const final {
    return CreateMaybeMessage<CvsCameraInfo>(nullptr);
  }

  CvsCameraInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CvsCameraInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CvsCameraInfo& from);
  void MergeFrom(const CvsCameraInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CvsCameraInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.CvsCameraInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AR51.SetCvsCameraField Fields = 8;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 8;
  ::AR51::SetCvsCameraField* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::SetCvsCameraField >*
      mutable_fields();
  const ::AR51::SetCvsCameraField& fields(int index) const;
  ::AR51::SetCvsCameraField* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::SetCvsCameraField >&
      fields() const;

  // string Id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);

  // bytes Intrisic = 2;
  void clear_intrisic();
  static const int kIntrisicFieldNumber = 2;
  const std::string& intrisic() const;
  void set_intrisic(const std::string& value);
  void set_intrisic(std::string&& value);
  void set_intrisic(const char* value);
  void set_intrisic(const void* value, size_t size);
  std::string* mutable_intrisic();
  std::string* release_intrisic();
  void set_allocated_intrisic(std::string* intrisic);

  // bytes Extrensic = 3;
  void clear_extrensic();
  static const int kExtrensicFieldNumber = 3;
  const std::string& extrensic() const;
  void set_extrensic(const std::string& value);
  void set_extrensic(std::string&& value);
  void set_extrensic(const char* value);
  void set_extrensic(const void* value, size_t size);
  std::string* mutable_extrensic();
  std::string* release_extrensic();
  void set_allocated_extrensic(std::string* extrensic);

  // string RemoteEndpoint = 10;
  void clear_remoteendpoint();
  static const int kRemoteEndpointFieldNumber = 10;
  const std::string& remoteendpoint() const;
  void set_remoteendpoint(const std::string& value);
  void set_remoteendpoint(std::string&& value);
  void set_remoteendpoint(const char* value);
  void set_remoteendpoint(const char* value, size_t size);
  std::string* mutable_remoteendpoint();
  std::string* release_remoteendpoint();
  void set_allocated_remoteendpoint(std::string* remoteendpoint);

  // string CameraType = 11;
  void clear_cameratype();
  static const int kCameraTypeFieldNumber = 11;
  const std::string& cameratype() const;
  void set_cameratype(const std::string& value);
  void set_cameratype(std::string&& value);
  void set_cameratype(const char* value);
  void set_cameratype(const char* value, size_t size);
  std::string* mutable_cameratype();
  std::string* release_cameratype();
  void set_allocated_cameratype(std::string* cameratype);

  // int32 Width = 4;
  void clear_width();
  static const int kWidthFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 Height = 5;
  void clear_height();
  static const int kHeightFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 FrameRate = 6;
  void clear_framerate();
  static const int kFrameRateFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::int32 framerate() const;
  void set_framerate(::PROTOBUF_NAMESPACE_ID::int32 value);

  // bool IsConnected = 7;
  void clear_isconnected();
  static const int kIsConnectedFieldNumber = 7;
  bool isconnected() const;
  void set_isconnected(bool value);

  // bool IsRemote = 9;
  void clear_isremote();
  static const int kIsRemoteFieldNumber = 9;
  bool isremote() const;
  void set_isremote(bool value);

  // @@protoc_insertion_point(class_scope:AR51.CvsCameraInfo)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::SetCvsCameraField > fields_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr intrisic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extrensic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remoteendpoint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cameratype_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  ::PROTOBUF_NAMESPACE_ID::int32 framerate_;
  bool isconnected_;
  bool isremote_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class GetAvailableCamerasResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.GetAvailableCamerasResponse) */ {
 public:
  GetAvailableCamerasResponse();
  virtual ~GetAvailableCamerasResponse();

  GetAvailableCamerasResponse(const GetAvailableCamerasResponse& from);
  GetAvailableCamerasResponse(GetAvailableCamerasResponse&& from) noexcept
    : GetAvailableCamerasResponse() {
    *this = ::std::move(from);
  }

  inline GetAvailableCamerasResponse& operator=(const GetAvailableCamerasResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAvailableCamerasResponse& operator=(GetAvailableCamerasResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetAvailableCamerasResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAvailableCamerasResponse* internal_default_instance() {
    return reinterpret_cast<const GetAvailableCamerasResponse*>(
               &_GetAvailableCamerasResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(GetAvailableCamerasResponse* other);
  friend void swap(GetAvailableCamerasResponse& a, GetAvailableCamerasResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAvailableCamerasResponse* New() const final {
    return CreateMaybeMessage<GetAvailableCamerasResponse>(nullptr);
  }

  GetAvailableCamerasResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAvailableCamerasResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetAvailableCamerasResponse& from);
  void MergeFrom(const GetAvailableCamerasResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAvailableCamerasResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.GetAvailableCamerasResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AR51.CvsCameraInfo CameraInfos = 1;
  int camerainfos_size() const;
  void clear_camerainfos();
  static const int kCameraInfosFieldNumber = 1;
  ::AR51::CvsCameraInfo* mutable_camerainfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::CvsCameraInfo >*
      mutable_camerainfos();
  const ::AR51::CvsCameraInfo& camerainfos(int index) const;
  ::AR51::CvsCameraInfo* add_camerainfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::CvsCameraInfo >&
      camerainfos() const;

  // @@protoc_insertion_point(class_scope:AR51.GetAvailableCamerasResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::CvsCameraInfo > camerainfos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class CvsCameraFeedRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.CvsCameraFeedRequest) */ {
 public:
  CvsCameraFeedRequest();
  virtual ~CvsCameraFeedRequest();

  CvsCameraFeedRequest(const CvsCameraFeedRequest& from);
  CvsCameraFeedRequest(CvsCameraFeedRequest&& from) noexcept
    : CvsCameraFeedRequest() {
    *this = ::std::move(from);
  }

  inline CvsCameraFeedRequest& operator=(const CvsCameraFeedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CvsCameraFeedRequest& operator=(CvsCameraFeedRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CvsCameraFeedRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CvsCameraFeedRequest* internal_default_instance() {
    return reinterpret_cast<const CvsCameraFeedRequest*>(
               &_CvsCameraFeedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(CvsCameraFeedRequest* other);
  friend void swap(CvsCameraFeedRequest& a, CvsCameraFeedRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CvsCameraFeedRequest* New() const final {
    return CreateMaybeMessage<CvsCameraFeedRequest>(nullptr);
  }

  CvsCameraFeedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CvsCameraFeedRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CvsCameraFeedRequest& from);
  void MergeFrom(const CvsCameraFeedRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CvsCameraFeedRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.CvsCameraFeedRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string CameraId = 1;
  void clear_cameraid();
  static const int kCameraIdFieldNumber = 1;
  const std::string& cameraid() const;
  void set_cameraid(const std::string& value);
  void set_cameraid(std::string&& value);
  void set_cameraid(const char* value);
  void set_cameraid(const char* value, size_t size);
  std::string* mutable_cameraid();
  std::string* release_cameraid();
  void set_allocated_cameraid(std::string* cameraid);

  // int32 Width = 2;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 Height = 3;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 FrameRate = 4;
  void clear_framerate();
  static const int kFrameRateFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::int32 framerate() const;
  void set_framerate(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 JpgQuality = 5;
  void clear_jpgquality();
  static const int kJpgQualityFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::int32 jpgquality() const;
  void set_jpgquality(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:AR51.CvsCameraFeedRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cameraid_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  ::PROTOBUF_NAMESPACE_ID::int32 framerate_;
  ::PROTOBUF_NAMESPACE_ID::int32 jpgquality_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class CvsCameraGetRecordingReadyRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.CvsCameraGetRecordingReadyRequest) */ {
 public:
  CvsCameraGetRecordingReadyRequest();
  virtual ~CvsCameraGetRecordingReadyRequest();

  CvsCameraGetRecordingReadyRequest(const CvsCameraGetRecordingReadyRequest& from);
  CvsCameraGetRecordingReadyRequest(CvsCameraGetRecordingReadyRequest&& from) noexcept
    : CvsCameraGetRecordingReadyRequest() {
    *this = ::std::move(from);
  }

  inline CvsCameraGetRecordingReadyRequest& operator=(const CvsCameraGetRecordingReadyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CvsCameraGetRecordingReadyRequest& operator=(CvsCameraGetRecordingReadyRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CvsCameraGetRecordingReadyRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CvsCameraGetRecordingReadyRequest* internal_default_instance() {
    return reinterpret_cast<const CvsCameraGetRecordingReadyRequest*>(
               &_CvsCameraGetRecordingReadyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(CvsCameraGetRecordingReadyRequest* other);
  friend void swap(CvsCameraGetRecordingReadyRequest& a, CvsCameraGetRecordingReadyRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CvsCameraGetRecordingReadyRequest* New() const final {
    return CreateMaybeMessage<CvsCameraGetRecordingReadyRequest>(nullptr);
  }

  CvsCameraGetRecordingReadyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CvsCameraGetRecordingReadyRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CvsCameraGetRecordingReadyRequest& from);
  void MergeFrom(const CvsCameraGetRecordingReadyRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CvsCameraGetRecordingReadyRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.CvsCameraGetRecordingReadyRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string CameraId = 1;
  void clear_cameraid();
  static const int kCameraIdFieldNumber = 1;
  const std::string& cameraid() const;
  void set_cameraid(const std::string& value);
  void set_cameraid(std::string&& value);
  void set_cameraid(const char* value);
  void set_cameraid(const char* value, size_t size);
  std::string* mutable_cameraid();
  std::string* release_cameraid();
  void set_allocated_cameraid(std::string* cameraid);

  // string FileName = 2;
  void clear_filename();
  static const int kFileNameFieldNumber = 2;
  const std::string& filename() const;
  void set_filename(const std::string& value);
  void set_filename(std::string&& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  std::string* mutable_filename();
  std::string* release_filename();
  void set_allocated_filename(std::string* filename);

  // @@protoc_insertion_point(class_scope:AR51.CvsCameraGetRecordingReadyRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cameraid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class CvsCameraIdRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.CvsCameraIdRequest) */ {
 public:
  CvsCameraIdRequest();
  virtual ~CvsCameraIdRequest();

  CvsCameraIdRequest(const CvsCameraIdRequest& from);
  CvsCameraIdRequest(CvsCameraIdRequest&& from) noexcept
    : CvsCameraIdRequest() {
    *this = ::std::move(from);
  }

  inline CvsCameraIdRequest& operator=(const CvsCameraIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CvsCameraIdRequest& operator=(CvsCameraIdRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CvsCameraIdRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CvsCameraIdRequest* internal_default_instance() {
    return reinterpret_cast<const CvsCameraIdRequest*>(
               &_CvsCameraIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(CvsCameraIdRequest* other);
  friend void swap(CvsCameraIdRequest& a, CvsCameraIdRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CvsCameraIdRequest* New() const final {
    return CreateMaybeMessage<CvsCameraIdRequest>(nullptr);
  }

  CvsCameraIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CvsCameraIdRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CvsCameraIdRequest& from);
  void MergeFrom(const CvsCameraIdRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CvsCameraIdRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.CvsCameraIdRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string CameraId = 1;
  void clear_cameraid();
  static const int kCameraIdFieldNumber = 1;
  const std::string& cameraid() const;
  void set_cameraid(const std::string& value);
  void set_cameraid(std::string&& value);
  void set_cameraid(const char* value);
  void set_cameraid(const char* value, size_t size);
  std::string* mutable_cameraid();
  std::string* release_cameraid();
  void set_allocated_cameraid(std::string* cameraid);

  // @@protoc_insertion_point(class_scope:AR51.CvsCameraIdRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cameraid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class CvsCameraFeedResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.CvsCameraFeedResponse) */ {
 public:
  CvsCameraFeedResponse();
  virtual ~CvsCameraFeedResponse();

  CvsCameraFeedResponse(const CvsCameraFeedResponse& from);
  CvsCameraFeedResponse(CvsCameraFeedResponse&& from) noexcept
    : CvsCameraFeedResponse() {
    *this = ::std::move(from);
  }

  inline CvsCameraFeedResponse& operator=(const CvsCameraFeedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CvsCameraFeedResponse& operator=(CvsCameraFeedResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CvsCameraFeedResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CvsCameraFeedResponse* internal_default_instance() {
    return reinterpret_cast<const CvsCameraFeedResponse*>(
               &_CvsCameraFeedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(CvsCameraFeedResponse* other);
  friend void swap(CvsCameraFeedResponse& a, CvsCameraFeedResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CvsCameraFeedResponse* New() const final {
    return CreateMaybeMessage<CvsCameraFeedResponse>(nullptr);
  }

  CvsCameraFeedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CvsCameraFeedResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CvsCameraFeedResponse& from);
  void MergeFrom(const CvsCameraFeedResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CvsCameraFeedResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.CvsCameraFeedResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes Jpg = 1;
  void clear_jpg();
  static const int kJpgFieldNumber = 1;
  const std::string& jpg() const;
  void set_jpg(const std::string& value);
  void set_jpg(std::string&& value);
  void set_jpg(const char* value);
  void set_jpg(const void* value, size_t size);
  std::string* mutable_jpg();
  std::string* release_jpg();
  void set_allocated_jpg(std::string* jpg);

  // float ActualFPS = 2;
  void clear_actualfps();
  static const int kActualFPSFieldNumber = 2;
  float actualfps() const;
  void set_actualfps(float value);

  // @@protoc_insertion_point(class_scope:AR51.CvsCameraFeedResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jpg_;
  float actualfps_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class MarkerInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.MarkerInfo) */ {
 public:
  MarkerInfo();
  virtual ~MarkerInfo();

  MarkerInfo(const MarkerInfo& from);
  MarkerInfo(MarkerInfo&& from) noexcept
    : MarkerInfo() {
    *this = ::std::move(from);
  }

  inline MarkerInfo& operator=(const MarkerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkerInfo& operator=(MarkerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MarkerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarkerInfo* internal_default_instance() {
    return reinterpret_cast<const MarkerInfo*>(
               &_MarkerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(MarkerInfo* other);
  friend void swap(MarkerInfo& a, MarkerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarkerInfo* New() const final {
    return CreateMaybeMessage<MarkerInfo>(nullptr);
  }

  MarkerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MarkerInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MarkerInfo& from);
  void MergeFrom(const MarkerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarkerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.MarkerInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);

  // .AR51.Vector3 Position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  const ::AR51::Vector3& position() const;
  ::AR51::Vector3* release_position();
  ::AR51::Vector3* mutable_position();
  void set_allocated_position(::AR51::Vector3* position);

  // @@protoc_insertion_point(class_scope:AR51.MarkerInfo)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::AR51::Vector3* position_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class TrackedObjectInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.TrackedObjectInfo) */ {
 public:
  TrackedObjectInfo();
  virtual ~TrackedObjectInfo();

  TrackedObjectInfo(const TrackedObjectInfo& from);
  TrackedObjectInfo(TrackedObjectInfo&& from) noexcept
    : TrackedObjectInfo() {
    *this = ::std::move(from);
  }

  inline TrackedObjectInfo& operator=(const TrackedObjectInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackedObjectInfo& operator=(TrackedObjectInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrackedObjectInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrackedObjectInfo* internal_default_instance() {
    return reinterpret_cast<const TrackedObjectInfo*>(
               &_TrackedObjectInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(TrackedObjectInfo* other);
  friend void swap(TrackedObjectInfo& a, TrackedObjectInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrackedObjectInfo* New() const final {
    return CreateMaybeMessage<TrackedObjectInfo>(nullptr);
  }

  TrackedObjectInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrackedObjectInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrackedObjectInfo& from);
  void MergeFrom(const TrackedObjectInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackedObjectInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.TrackedObjectInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AR51.MarkerInfo Markers = 2;
  int markers_size() const;
  void clear_markers();
  static const int kMarkersFieldNumber = 2;
  ::AR51::MarkerInfo* mutable_markers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::MarkerInfo >*
      mutable_markers();
  const ::AR51::MarkerInfo& markers(int index) const;
  ::AR51::MarkerInfo* add_markers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::MarkerInfo >&
      markers() const;

  // string Name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // @@protoc_insertion_point(class_scope:AR51.TrackedObjectInfo)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::MarkerInfo > markers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class TrackedMarker :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.TrackedMarker) */ {
 public:
  TrackedMarker();
  virtual ~TrackedMarker();

  TrackedMarker(const TrackedMarker& from);
  TrackedMarker(TrackedMarker&& from) noexcept
    : TrackedMarker() {
    *this = ::std::move(from);
  }

  inline TrackedMarker& operator=(const TrackedMarker& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackedMarker& operator=(TrackedMarker&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrackedMarker& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrackedMarker* internal_default_instance() {
    return reinterpret_cast<const TrackedMarker*>(
               &_TrackedMarker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(TrackedMarker* other);
  friend void swap(TrackedMarker& a, TrackedMarker& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrackedMarker* New() const final {
    return CreateMaybeMessage<TrackedMarker>(nullptr);
  }

  TrackedMarker* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrackedMarker>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrackedMarker& from);
  void MergeFrom(const TrackedMarker& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackedMarker* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.TrackedMarker";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AR51.Vector3 Rays = 5;
  int rays_size() const;
  void clear_rays();
  static const int kRaysFieldNumber = 5;
  ::AR51::Vector3* mutable_rays(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::Vector3 >*
      mutable_rays();
  const ::AR51::Vector3& rays(int index) const;
  ::AR51::Vector3* add_rays();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::Vector3 >&
      rays() const;

  // string Id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);

  // string Type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);

  // .AR51.Vector3 Position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  const ::AR51::Vector3& position() const;
  ::AR51::Vector3* release_position();
  ::AR51::Vector3* mutable_position();
  void set_allocated_position(::AR51::Vector3* position);

  // float Radius = 4;
  void clear_radius();
  static const int kRadiusFieldNumber = 4;
  float radius() const;
  void set_radius(float value);

  // @@protoc_insertion_point(class_scope:AR51.TrackedMarker)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::Vector3 > rays_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::AR51::Vector3* position_;
  float radius_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class TrackedObject :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.TrackedObject) */ {
 public:
  TrackedObject();
  virtual ~TrackedObject();

  TrackedObject(const TrackedObject& from);
  TrackedObject(TrackedObject&& from) noexcept
    : TrackedObject() {
    *this = ::std::move(from);
  }

  inline TrackedObject& operator=(const TrackedObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackedObject& operator=(TrackedObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrackedObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrackedObject* internal_default_instance() {
    return reinterpret_cast<const TrackedObject*>(
               &_TrackedObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(TrackedObject* other);
  friend void swap(TrackedObject& a, TrackedObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrackedObject* New() const final {
    return CreateMaybeMessage<TrackedObject>(nullptr);
  }

  TrackedObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrackedObject>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrackedObject& from);
  void MergeFrom(const TrackedObject& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackedObject* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.TrackedObject";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string MarkerIds = 5;
  int markerids_size() const;
  void clear_markerids();
  static const int kMarkerIdsFieldNumber = 5;
  const std::string& markerids(int index) const;
  std::string* mutable_markerids(int index);
  void set_markerids(int index, const std::string& value);
  void set_markerids(int index, std::string&& value);
  void set_markerids(int index, const char* value);
  void set_markerids(int index, const char* value, size_t size);
  std::string* add_markerids();
  void add_markerids(const std::string& value);
  void add_markerids(std::string&& value);
  void add_markerids(const char* value);
  void add_markerids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& markerids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_markerids();

  // string Id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);

  // string Name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // .AR51.Vector3 Position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  const ::AR51::Vector3& position() const;
  ::AR51::Vector3* release_position();
  ::AR51::Vector3* mutable_position();
  void set_allocated_position(::AR51::Vector3* position);

  // .AR51.Quaternion Rotation = 4;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 4;
  const ::AR51::Quaternion& rotation() const;
  ::AR51::Quaternion* release_rotation();
  ::AR51::Quaternion* mutable_rotation();
  void set_allocated_rotation(::AR51::Quaternion* rotation);

  // @@protoc_insertion_point(class_scope:AR51.TrackedObject)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> markerids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::AR51::Vector3* position_;
  ::AR51::Quaternion* rotation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// -------------------------------------------------------------------

class ObjectDetectionReply :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AR51.ObjectDetectionReply) */ {
 public:
  ObjectDetectionReply();
  virtual ~ObjectDetectionReply();

  ObjectDetectionReply(const ObjectDetectionReply& from);
  ObjectDetectionReply(ObjectDetectionReply&& from) noexcept
    : ObjectDetectionReply() {
    *this = ::std::move(from);
  }

  inline ObjectDetectionReply& operator=(const ObjectDetectionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectDetectionReply& operator=(ObjectDetectionReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectDetectionReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectDetectionReply* internal_default_instance() {
    return reinterpret_cast<const ObjectDetectionReply*>(
               &_ObjectDetectionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(ObjectDetectionReply* other);
  friend void swap(ObjectDetectionReply& a, ObjectDetectionReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectDetectionReply* New() const final {
    return CreateMaybeMessage<ObjectDetectionReply>(nullptr);
  }

  ObjectDetectionReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectDetectionReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectDetectionReply& from);
  void MergeFrom(const ObjectDetectionReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectDetectionReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AR51.ObjectDetectionReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cvs_2eproto);
    return ::descriptor_table_cvs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AR51.TrackedMarker Markers = 1;
  int markers_size() const;
  void clear_markers();
  static const int kMarkersFieldNumber = 1;
  ::AR51::TrackedMarker* mutable_markers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::TrackedMarker >*
      mutable_markers();
  const ::AR51::TrackedMarker& markers(int index) const;
  ::AR51::TrackedMarker* add_markers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::TrackedMarker >&
      markers() const;

  // repeated .AR51.TrackedObject Items = 2;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 2;
  ::AR51::TrackedObject* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::TrackedObject >*
      mutable_items();
  const ::AR51::TrackedObject& items(int index) const;
  ::AR51::TrackedObject* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::TrackedObject >&
      items() const;

  // repeated string Cameras = 3;
  int cameras_size() const;
  void clear_cameras();
  static const int kCamerasFieldNumber = 3;
  const std::string& cameras(int index) const;
  std::string* mutable_cameras(int index);
  void set_cameras(int index, const std::string& value);
  void set_cameras(int index, std::string&& value);
  void set_cameras(int index, const char* value);
  void set_cameras(int index, const char* value, size_t size);
  std::string* add_cameras();
  void add_cameras(const std::string& value);
  void add_cameras(std::string&& value);
  void add_cameras(const char* value);
  void add_cameras(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& cameras() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_cameras();

  // @@protoc_insertion_point(class_scope:AR51.ObjectDetectionReply)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::TrackedMarker > markers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::TrackedObject > items_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> cameras_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cvs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HelloRequest

// string name = 1;
inline void HelloRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& HelloRequest::name() const {
  // @@protoc_insertion_point(field_get:AR51.HelloRequest.name)
  return name_.GetNoArena();
}
inline void HelloRequest::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.HelloRequest.name)
}
inline void HelloRequest::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.HelloRequest.name)
}
inline void HelloRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.HelloRequest.name)
}
inline void HelloRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.HelloRequest.name)
}
inline std::string* HelloRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:AR51.HelloRequest.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HelloRequest::release_name() {
  // @@protoc_insertion_point(field_release:AR51.HelloRequest.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HelloRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:AR51.HelloRequest.name)
}

// -------------------------------------------------------------------

// HelloReply

// string message = 1;
inline void HelloReply::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& HelloReply::message() const {
  // @@protoc_insertion_point(field_get:AR51.HelloReply.message)
  return message_.GetNoArena();
}
inline void HelloReply::set_message(const std::string& value) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.HelloReply.message)
}
inline void HelloReply::set_message(std::string&& value) {
  
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.HelloReply.message)
}
inline void HelloReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.HelloReply.message)
}
inline void HelloReply::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.HelloReply.message)
}
inline std::string* HelloReply::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:AR51.HelloReply.message)
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HelloReply::release_message() {
  // @@protoc_insertion_point(field_release:AR51.HelloReply.message)
  
  return message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HelloReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:AR51.HelloReply.message)
}

// -------------------------------------------------------------------

// HandsInfoRequest

// string SkeletonId = 1;
inline void HandsInfoRequest::clear_skeletonid() {
  skeletonid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& HandsInfoRequest::skeletonid() const {
  // @@protoc_insertion_point(field_get:AR51.HandsInfoRequest.SkeletonId)
  return skeletonid_.GetNoArena();
}
inline void HandsInfoRequest::set_skeletonid(const std::string& value) {
  
  skeletonid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.HandsInfoRequest.SkeletonId)
}
inline void HandsInfoRequest::set_skeletonid(std::string&& value) {
  
  skeletonid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.HandsInfoRequest.SkeletonId)
}
inline void HandsInfoRequest::set_skeletonid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  skeletonid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.HandsInfoRequest.SkeletonId)
}
inline void HandsInfoRequest::set_skeletonid(const char* value, size_t size) {
  
  skeletonid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.HandsInfoRequest.SkeletonId)
}
inline std::string* HandsInfoRequest::mutable_skeletonid() {
  
  // @@protoc_insertion_point(field_mutable:AR51.HandsInfoRequest.SkeletonId)
  return skeletonid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HandsInfoRequest::release_skeletonid() {
  // @@protoc_insertion_point(field_release:AR51.HandsInfoRequest.SkeletonId)
  
  return skeletonid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HandsInfoRequest::set_allocated_skeletonid(std::string* skeletonid) {
  if (skeletonid != nullptr) {
    
  } else {
    
  }
  skeletonid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), skeletonid);
  // @@protoc_insertion_point(field_set_allocated:AR51.HandsInfoRequest.SkeletonId)
}

// .AR51.Vector3 LeftWristPosition = 2;
inline bool HandsInfoRequest::has_leftwristposition() const {
  return this != internal_default_instance() && leftwristposition_ != nullptr;
}
inline const ::AR51::Vector3& HandsInfoRequest::leftwristposition() const {
  const ::AR51::Vector3* p = leftwristposition_;
  // @@protoc_insertion_point(field_get:AR51.HandsInfoRequest.LeftWristPosition)
  return p != nullptr ? *p : *reinterpret_cast<const ::AR51::Vector3*>(
      &::AR51::_Vector3_default_instance_);
}
inline ::AR51::Vector3* HandsInfoRequest::release_leftwristposition() {
  // @@protoc_insertion_point(field_release:AR51.HandsInfoRequest.LeftWristPosition)
  
  ::AR51::Vector3* temp = leftwristposition_;
  leftwristposition_ = nullptr;
  return temp;
}
inline ::AR51::Vector3* HandsInfoRequest::mutable_leftwristposition() {
  
  if (leftwristposition_ == nullptr) {
    auto* p = CreateMaybeMessage<::AR51::Vector3>(GetArenaNoVirtual());
    leftwristposition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AR51.HandsInfoRequest.LeftWristPosition)
  return leftwristposition_;
}
inline void HandsInfoRequest::set_allocated_leftwristposition(::AR51::Vector3* leftwristposition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(leftwristposition_);
  }
  if (leftwristposition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      leftwristposition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leftwristposition, submessage_arena);
    }
    
  } else {
    
  }
  leftwristposition_ = leftwristposition;
  // @@protoc_insertion_point(field_set_allocated:AR51.HandsInfoRequest.LeftWristPosition)
}

// .AR51.Vector3 RightWristPosition = 3;
inline bool HandsInfoRequest::has_rightwristposition() const {
  return this != internal_default_instance() && rightwristposition_ != nullptr;
}
inline const ::AR51::Vector3& HandsInfoRequest::rightwristposition() const {
  const ::AR51::Vector3* p = rightwristposition_;
  // @@protoc_insertion_point(field_get:AR51.HandsInfoRequest.RightWristPosition)
  return p != nullptr ? *p : *reinterpret_cast<const ::AR51::Vector3*>(
      &::AR51::_Vector3_default_instance_);
}
inline ::AR51::Vector3* HandsInfoRequest::release_rightwristposition() {
  // @@protoc_insertion_point(field_release:AR51.HandsInfoRequest.RightWristPosition)
  
  ::AR51::Vector3* temp = rightwristposition_;
  rightwristposition_ = nullptr;
  return temp;
}
inline ::AR51::Vector3* HandsInfoRequest::mutable_rightwristposition() {
  
  if (rightwristposition_ == nullptr) {
    auto* p = CreateMaybeMessage<::AR51::Vector3>(GetArenaNoVirtual());
    rightwristposition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AR51.HandsInfoRequest.RightWristPosition)
  return rightwristposition_;
}
inline void HandsInfoRequest::set_allocated_rightwristposition(::AR51::Vector3* rightwristposition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(rightwristposition_);
  }
  if (rightwristposition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rightwristposition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rightwristposition, submessage_arena);
    }
    
  } else {
    
  }
  rightwristposition_ = rightwristposition;
  // @@protoc_insertion_point(field_set_allocated:AR51.HandsInfoRequest.RightWristPosition)
}

// bytes LeftHandRotation = 4;
inline void HandsInfoRequest::clear_lefthandrotation() {
  lefthandrotation_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& HandsInfoRequest::lefthandrotation() const {
  // @@protoc_insertion_point(field_get:AR51.HandsInfoRequest.LeftHandRotation)
  return lefthandrotation_.GetNoArena();
}
inline void HandsInfoRequest::set_lefthandrotation(const std::string& value) {
  
  lefthandrotation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.HandsInfoRequest.LeftHandRotation)
}
inline void HandsInfoRequest::set_lefthandrotation(std::string&& value) {
  
  lefthandrotation_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.HandsInfoRequest.LeftHandRotation)
}
inline void HandsInfoRequest::set_lefthandrotation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  lefthandrotation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.HandsInfoRequest.LeftHandRotation)
}
inline void HandsInfoRequest::set_lefthandrotation(const void* value, size_t size) {
  
  lefthandrotation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.HandsInfoRequest.LeftHandRotation)
}
inline std::string* HandsInfoRequest::mutable_lefthandrotation() {
  
  // @@protoc_insertion_point(field_mutable:AR51.HandsInfoRequest.LeftHandRotation)
  return lefthandrotation_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HandsInfoRequest::release_lefthandrotation() {
  // @@protoc_insertion_point(field_release:AR51.HandsInfoRequest.LeftHandRotation)
  
  return lefthandrotation_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HandsInfoRequest::set_allocated_lefthandrotation(std::string* lefthandrotation) {
  if (lefthandrotation != nullptr) {
    
  } else {
    
  }
  lefthandrotation_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lefthandrotation);
  // @@protoc_insertion_point(field_set_allocated:AR51.HandsInfoRequest.LeftHandRotation)
}

// bytes RightHandRotation = 5;
inline void HandsInfoRequest::clear_righthandrotation() {
  righthandrotation_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& HandsInfoRequest::righthandrotation() const {
  // @@protoc_insertion_point(field_get:AR51.HandsInfoRequest.RightHandRotation)
  return righthandrotation_.GetNoArena();
}
inline void HandsInfoRequest::set_righthandrotation(const std::string& value) {
  
  righthandrotation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.HandsInfoRequest.RightHandRotation)
}
inline void HandsInfoRequest::set_righthandrotation(std::string&& value) {
  
  righthandrotation_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.HandsInfoRequest.RightHandRotation)
}
inline void HandsInfoRequest::set_righthandrotation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  righthandrotation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.HandsInfoRequest.RightHandRotation)
}
inline void HandsInfoRequest::set_righthandrotation(const void* value, size_t size) {
  
  righthandrotation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.HandsInfoRequest.RightHandRotation)
}
inline std::string* HandsInfoRequest::mutable_righthandrotation() {
  
  // @@protoc_insertion_point(field_mutable:AR51.HandsInfoRequest.RightHandRotation)
  return righthandrotation_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HandsInfoRequest::release_righthandrotation() {
  // @@protoc_insertion_point(field_release:AR51.HandsInfoRequest.RightHandRotation)
  
  return righthandrotation_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HandsInfoRequest::set_allocated_righthandrotation(std::string* righthandrotation) {
  if (righthandrotation != nullptr) {
    
  } else {
    
  }
  righthandrotation_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), righthandrotation);
  // @@protoc_insertion_point(field_set_allocated:AR51.HandsInfoRequest.RightHandRotation)
}

// .AR51.Quaternion HeadLocalRotation = 6;
inline bool HandsInfoRequest::has_headlocalrotation() const {
  return this != internal_default_instance() && headlocalrotation_ != nullptr;
}
inline const ::AR51::Quaternion& HandsInfoRequest::headlocalrotation() const {
  const ::AR51::Quaternion* p = headlocalrotation_;
  // @@protoc_insertion_point(field_get:AR51.HandsInfoRequest.HeadLocalRotation)
  return p != nullptr ? *p : *reinterpret_cast<const ::AR51::Quaternion*>(
      &::AR51::_Quaternion_default_instance_);
}
inline ::AR51::Quaternion* HandsInfoRequest::release_headlocalrotation() {
  // @@protoc_insertion_point(field_release:AR51.HandsInfoRequest.HeadLocalRotation)
  
  ::AR51::Quaternion* temp = headlocalrotation_;
  headlocalrotation_ = nullptr;
  return temp;
}
inline ::AR51::Quaternion* HandsInfoRequest::mutable_headlocalrotation() {
  
  if (headlocalrotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::AR51::Quaternion>(GetArenaNoVirtual());
    headlocalrotation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AR51.HandsInfoRequest.HeadLocalRotation)
  return headlocalrotation_;
}
inline void HandsInfoRequest::set_allocated_headlocalrotation(::AR51::Quaternion* headlocalrotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(headlocalrotation_);
  }
  if (headlocalrotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      headlocalrotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, headlocalrotation, submessage_arena);
    }
    
  } else {
    
  }
  headlocalrotation_ = headlocalrotation;
  // @@protoc_insertion_point(field_set_allocated:AR51.HandsInfoRequest.HeadLocalRotation)
}

// bytes LeftHandPositions = 7;
inline void HandsInfoRequest::clear_lefthandpositions() {
  lefthandpositions_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& HandsInfoRequest::lefthandpositions() const {
  // @@protoc_insertion_point(field_get:AR51.HandsInfoRequest.LeftHandPositions)
  return lefthandpositions_.GetNoArena();
}
inline void HandsInfoRequest::set_lefthandpositions(const std::string& value) {
  
  lefthandpositions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.HandsInfoRequest.LeftHandPositions)
}
inline void HandsInfoRequest::set_lefthandpositions(std::string&& value) {
  
  lefthandpositions_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.HandsInfoRequest.LeftHandPositions)
}
inline void HandsInfoRequest::set_lefthandpositions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  lefthandpositions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.HandsInfoRequest.LeftHandPositions)
}
inline void HandsInfoRequest::set_lefthandpositions(const void* value, size_t size) {
  
  lefthandpositions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.HandsInfoRequest.LeftHandPositions)
}
inline std::string* HandsInfoRequest::mutable_lefthandpositions() {
  
  // @@protoc_insertion_point(field_mutable:AR51.HandsInfoRequest.LeftHandPositions)
  return lefthandpositions_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HandsInfoRequest::release_lefthandpositions() {
  // @@protoc_insertion_point(field_release:AR51.HandsInfoRequest.LeftHandPositions)
  
  return lefthandpositions_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HandsInfoRequest::set_allocated_lefthandpositions(std::string* lefthandpositions) {
  if (lefthandpositions != nullptr) {
    
  } else {
    
  }
  lefthandpositions_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lefthandpositions);
  // @@protoc_insertion_point(field_set_allocated:AR51.HandsInfoRequest.LeftHandPositions)
}

// bytes RightHandPositions = 8;
inline void HandsInfoRequest::clear_righthandpositions() {
  righthandpositions_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& HandsInfoRequest::righthandpositions() const {
  // @@protoc_insertion_point(field_get:AR51.HandsInfoRequest.RightHandPositions)
  return righthandpositions_.GetNoArena();
}
inline void HandsInfoRequest::set_righthandpositions(const std::string& value) {
  
  righthandpositions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.HandsInfoRequest.RightHandPositions)
}
inline void HandsInfoRequest::set_righthandpositions(std::string&& value) {
  
  righthandpositions_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.HandsInfoRequest.RightHandPositions)
}
inline void HandsInfoRequest::set_righthandpositions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  righthandpositions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.HandsInfoRequest.RightHandPositions)
}
inline void HandsInfoRequest::set_righthandpositions(const void* value, size_t size) {
  
  righthandpositions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.HandsInfoRequest.RightHandPositions)
}
inline std::string* HandsInfoRequest::mutable_righthandpositions() {
  
  // @@protoc_insertion_point(field_mutable:AR51.HandsInfoRequest.RightHandPositions)
  return righthandpositions_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HandsInfoRequest::release_righthandpositions() {
  // @@protoc_insertion_point(field_release:AR51.HandsInfoRequest.RightHandPositions)
  
  return righthandpositions_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HandsInfoRequest::set_allocated_righthandpositions(std::string* righthandpositions) {
  if (righthandpositions != nullptr) {
    
  } else {
    
  }
  righthandpositions_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), righthandpositions);
  // @@protoc_insertion_point(field_set_allocated:AR51.HandsInfoRequest.RightHandPositions)
}

// string DeviceId = 9;
inline void HandsInfoRequest::clear_deviceid() {
  deviceid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& HandsInfoRequest::deviceid() const {
  // @@protoc_insertion_point(field_get:AR51.HandsInfoRequest.DeviceId)
  return deviceid_.GetNoArena();
}
inline void HandsInfoRequest::set_deviceid(const std::string& value) {
  
  deviceid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.HandsInfoRequest.DeviceId)
}
inline void HandsInfoRequest::set_deviceid(std::string&& value) {
  
  deviceid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.HandsInfoRequest.DeviceId)
}
inline void HandsInfoRequest::set_deviceid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  deviceid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.HandsInfoRequest.DeviceId)
}
inline void HandsInfoRequest::set_deviceid(const char* value, size_t size) {
  
  deviceid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.HandsInfoRequest.DeviceId)
}
inline std::string* HandsInfoRequest::mutable_deviceid() {
  
  // @@protoc_insertion_point(field_mutable:AR51.HandsInfoRequest.DeviceId)
  return deviceid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HandsInfoRequest::release_deviceid() {
  // @@protoc_insertion_point(field_release:AR51.HandsInfoRequest.DeviceId)
  
  return deviceid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HandsInfoRequest::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  deviceid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), deviceid);
  // @@protoc_insertion_point(field_set_allocated:AR51.HandsInfoRequest.DeviceId)
}

// string CharacterPrefab = 10;
inline void HandsInfoRequest::clear_characterprefab() {
  characterprefab_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& HandsInfoRequest::characterprefab() const {
  // @@protoc_insertion_point(field_get:AR51.HandsInfoRequest.CharacterPrefab)
  return characterprefab_.GetNoArena();
}
inline void HandsInfoRequest::set_characterprefab(const std::string& value) {
  
  characterprefab_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.HandsInfoRequest.CharacterPrefab)
}
inline void HandsInfoRequest::set_characterprefab(std::string&& value) {
  
  characterprefab_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.HandsInfoRequest.CharacterPrefab)
}
inline void HandsInfoRequest::set_characterprefab(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  characterprefab_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.HandsInfoRequest.CharacterPrefab)
}
inline void HandsInfoRequest::set_characterprefab(const char* value, size_t size) {
  
  characterprefab_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.HandsInfoRequest.CharacterPrefab)
}
inline std::string* HandsInfoRequest::mutable_characterprefab() {
  
  // @@protoc_insertion_point(field_mutable:AR51.HandsInfoRequest.CharacterPrefab)
  return characterprefab_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HandsInfoRequest::release_characterprefab() {
  // @@protoc_insertion_point(field_release:AR51.HandsInfoRequest.CharacterPrefab)
  
  return characterprefab_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HandsInfoRequest::set_allocated_characterprefab(std::string* characterprefab) {
  if (characterprefab != nullptr) {
    
  } else {
    
  }
  characterprefab_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), characterprefab);
  // @@protoc_insertion_point(field_set_allocated:AR51.HandsInfoRequest.CharacterPrefab)
}

// -------------------------------------------------------------------

// ControllerInfoRequest

// bool IsDetected = 1;
inline void ControllerInfoRequest::clear_isdetected() {
  isdetected_ = false;
}
inline bool ControllerInfoRequest::isdetected() const {
  // @@protoc_insertion_point(field_get:AR51.ControllerInfoRequest.IsDetected)
  return isdetected_;
}
inline void ControllerInfoRequest::set_isdetected(bool value) {
  
  isdetected_ = value;
  // @@protoc_insertion_point(field_set:AR51.ControllerInfoRequest.IsDetected)
}

// bytes LocalToWorldLH = 2;
inline void ControllerInfoRequest::clear_localtoworldlh() {
  localtoworldlh_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ControllerInfoRequest::localtoworldlh() const {
  // @@protoc_insertion_point(field_get:AR51.ControllerInfoRequest.LocalToWorldLH)
  return localtoworldlh_.GetNoArena();
}
inline void ControllerInfoRequest::set_localtoworldlh(const std::string& value) {
  
  localtoworldlh_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.ControllerInfoRequest.LocalToWorldLH)
}
inline void ControllerInfoRequest::set_localtoworldlh(std::string&& value) {
  
  localtoworldlh_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.ControllerInfoRequest.LocalToWorldLH)
}
inline void ControllerInfoRequest::set_localtoworldlh(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  localtoworldlh_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.ControllerInfoRequest.LocalToWorldLH)
}
inline void ControllerInfoRequest::set_localtoworldlh(const void* value, size_t size) {
  
  localtoworldlh_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.ControllerInfoRequest.LocalToWorldLH)
}
inline std::string* ControllerInfoRequest::mutable_localtoworldlh() {
  
  // @@protoc_insertion_point(field_mutable:AR51.ControllerInfoRequest.LocalToWorldLH)
  return localtoworldlh_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ControllerInfoRequest::release_localtoworldlh() {
  // @@protoc_insertion_point(field_release:AR51.ControllerInfoRequest.LocalToWorldLH)
  
  return localtoworldlh_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ControllerInfoRequest::set_allocated_localtoworldlh(std::string* localtoworldlh) {
  if (localtoworldlh != nullptr) {
    
  } else {
    
  }
  localtoworldlh_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), localtoworldlh);
  // @@protoc_insertion_point(field_set_allocated:AR51.ControllerInfoRequest.LocalToWorldLH)
}

// bytes LocalToAnchorLH = 3;
inline void ControllerInfoRequest::clear_localtoanchorlh() {
  localtoanchorlh_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ControllerInfoRequest::localtoanchorlh() const {
  // @@protoc_insertion_point(field_get:AR51.ControllerInfoRequest.LocalToAnchorLH)
  return localtoanchorlh_.GetNoArena();
}
inline void ControllerInfoRequest::set_localtoanchorlh(const std::string& value) {
  
  localtoanchorlh_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.ControllerInfoRequest.LocalToAnchorLH)
}
inline void ControllerInfoRequest::set_localtoanchorlh(std::string&& value) {
  
  localtoanchorlh_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.ControllerInfoRequest.LocalToAnchorLH)
}
inline void ControllerInfoRequest::set_localtoanchorlh(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  localtoanchorlh_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.ControllerInfoRequest.LocalToAnchorLH)
}
inline void ControllerInfoRequest::set_localtoanchorlh(const void* value, size_t size) {
  
  localtoanchorlh_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.ControllerInfoRequest.LocalToAnchorLH)
}
inline std::string* ControllerInfoRequest::mutable_localtoanchorlh() {
  
  // @@protoc_insertion_point(field_mutable:AR51.ControllerInfoRequest.LocalToAnchorLH)
  return localtoanchorlh_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ControllerInfoRequest::release_localtoanchorlh() {
  // @@protoc_insertion_point(field_release:AR51.ControllerInfoRequest.LocalToAnchorLH)
  
  return localtoanchorlh_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ControllerInfoRequest::set_allocated_localtoanchorlh(std::string* localtoanchorlh) {
  if (localtoanchorlh != nullptr) {
    
  } else {
    
  }
  localtoanchorlh_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), localtoanchorlh);
  // @@protoc_insertion_point(field_set_allocated:AR51.ControllerInfoRequest.LocalToAnchorLH)
}

// repeated .AR51.ControllerButton Buttons = 4;
inline int ControllerInfoRequest::buttons_size() const {
  return buttons_.size();
}
inline void ControllerInfoRequest::clear_buttons() {
  buttons_.Clear();
}
inline ::AR51::ControllerButton ControllerInfoRequest::buttons(int index) const {
  // @@protoc_insertion_point(field_get:AR51.ControllerInfoRequest.Buttons)
  return static_cast< ::AR51::ControllerButton >(buttons_.Get(index));
}
inline void ControllerInfoRequest::set_buttons(int index, ::AR51::ControllerButton value) {
  buttons_.Set(index, value);
  // @@protoc_insertion_point(field_set:AR51.ControllerInfoRequest.Buttons)
}
inline void ControllerInfoRequest::add_buttons(::AR51::ControllerButton value) {
  buttons_.Add(value);
  // @@protoc_insertion_point(field_add:AR51.ControllerInfoRequest.Buttons)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ControllerInfoRequest::buttons() const {
  // @@protoc_insertion_point(field_list:AR51.ControllerInfoRequest.Buttons)
  return buttons_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ControllerInfoRequest::mutable_buttons() {
  // @@protoc_insertion_point(field_mutable_list:AR51.ControllerInfoRequest.Buttons)
  return &buttons_;
}

// repeated .AR51.ControllerButtonStatus ButtonStatus = 5;
inline int ControllerInfoRequest::buttonstatus_size() const {
  return buttonstatus_.size();
}
inline void ControllerInfoRequest::clear_buttonstatus() {
  buttonstatus_.Clear();
}
inline ::AR51::ControllerButtonStatus ControllerInfoRequest::buttonstatus(int index) const {
  // @@protoc_insertion_point(field_get:AR51.ControllerInfoRequest.ButtonStatus)
  return static_cast< ::AR51::ControllerButtonStatus >(buttonstatus_.Get(index));
}
inline void ControllerInfoRequest::set_buttonstatus(int index, ::AR51::ControllerButtonStatus value) {
  buttonstatus_.Set(index, value);
  // @@protoc_insertion_point(field_set:AR51.ControllerInfoRequest.ButtonStatus)
}
inline void ControllerInfoRequest::add_buttonstatus(::AR51::ControllerButtonStatus value) {
  buttonstatus_.Add(value);
  // @@protoc_insertion_point(field_add:AR51.ControllerInfoRequest.ButtonStatus)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ControllerInfoRequest::buttonstatus() const {
  // @@protoc_insertion_point(field_list:AR51.ControllerInfoRequest.ButtonStatus)
  return buttonstatus_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ControllerInfoRequest::mutable_buttonstatus() {
  // @@protoc_insertion_point(field_mutable_list:AR51.ControllerInfoRequest.ButtonStatus)
  return &buttonstatus_;
}

// -------------------------------------------------------------------

// MultiControllerInfoRequest

// string SkeletonId = 1;
inline void MultiControllerInfoRequest::clear_skeletonid() {
  skeletonid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MultiControllerInfoRequest::skeletonid() const {
  // @@protoc_insertion_point(field_get:AR51.MultiControllerInfoRequest.SkeletonId)
  return skeletonid_.GetNoArena();
}
inline void MultiControllerInfoRequest::set_skeletonid(const std::string& value) {
  
  skeletonid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.MultiControllerInfoRequest.SkeletonId)
}
inline void MultiControllerInfoRequest::set_skeletonid(std::string&& value) {
  
  skeletonid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.MultiControllerInfoRequest.SkeletonId)
}
inline void MultiControllerInfoRequest::set_skeletonid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  skeletonid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.MultiControllerInfoRequest.SkeletonId)
}
inline void MultiControllerInfoRequest::set_skeletonid(const char* value, size_t size) {
  
  skeletonid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.MultiControllerInfoRequest.SkeletonId)
}
inline std::string* MultiControllerInfoRequest::mutable_skeletonid() {
  
  // @@protoc_insertion_point(field_mutable:AR51.MultiControllerInfoRequest.SkeletonId)
  return skeletonid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MultiControllerInfoRequest::release_skeletonid() {
  // @@protoc_insertion_point(field_release:AR51.MultiControllerInfoRequest.SkeletonId)
  
  return skeletonid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MultiControllerInfoRequest::set_allocated_skeletonid(std::string* skeletonid) {
  if (skeletonid != nullptr) {
    
  } else {
    
  }
  skeletonid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), skeletonid);
  // @@protoc_insertion_point(field_set_allocated:AR51.MultiControllerInfoRequest.SkeletonId)
}

// .AR51.ControllerInfoRequest LeftController = 2;
inline bool MultiControllerInfoRequest::has_leftcontroller() const {
  return this != internal_default_instance() && leftcontroller_ != nullptr;
}
inline void MultiControllerInfoRequest::clear_leftcontroller() {
  if (GetArenaNoVirtual() == nullptr && leftcontroller_ != nullptr) {
    delete leftcontroller_;
  }
  leftcontroller_ = nullptr;
}
inline const ::AR51::ControllerInfoRequest& MultiControllerInfoRequest::leftcontroller() const {
  const ::AR51::ControllerInfoRequest* p = leftcontroller_;
  // @@protoc_insertion_point(field_get:AR51.MultiControllerInfoRequest.LeftController)
  return p != nullptr ? *p : *reinterpret_cast<const ::AR51::ControllerInfoRequest*>(
      &::AR51::_ControllerInfoRequest_default_instance_);
}
inline ::AR51::ControllerInfoRequest* MultiControllerInfoRequest::release_leftcontroller() {
  // @@protoc_insertion_point(field_release:AR51.MultiControllerInfoRequest.LeftController)
  
  ::AR51::ControllerInfoRequest* temp = leftcontroller_;
  leftcontroller_ = nullptr;
  return temp;
}
inline ::AR51::ControllerInfoRequest* MultiControllerInfoRequest::mutable_leftcontroller() {
  
  if (leftcontroller_ == nullptr) {
    auto* p = CreateMaybeMessage<::AR51::ControllerInfoRequest>(GetArenaNoVirtual());
    leftcontroller_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AR51.MultiControllerInfoRequest.LeftController)
  return leftcontroller_;
}
inline void MultiControllerInfoRequest::set_allocated_leftcontroller(::AR51::ControllerInfoRequest* leftcontroller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete leftcontroller_;
  }
  if (leftcontroller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      leftcontroller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leftcontroller, submessage_arena);
    }
    
  } else {
    
  }
  leftcontroller_ = leftcontroller;
  // @@protoc_insertion_point(field_set_allocated:AR51.MultiControllerInfoRequest.LeftController)
}

// .AR51.ControllerInfoRequest RightController = 3;
inline bool MultiControllerInfoRequest::has_rightcontroller() const {
  return this != internal_default_instance() && rightcontroller_ != nullptr;
}
inline void MultiControllerInfoRequest::clear_rightcontroller() {
  if (GetArenaNoVirtual() == nullptr && rightcontroller_ != nullptr) {
    delete rightcontroller_;
  }
  rightcontroller_ = nullptr;
}
inline const ::AR51::ControllerInfoRequest& MultiControllerInfoRequest::rightcontroller() const {
  const ::AR51::ControllerInfoRequest* p = rightcontroller_;
  // @@protoc_insertion_point(field_get:AR51.MultiControllerInfoRequest.RightController)
  return p != nullptr ? *p : *reinterpret_cast<const ::AR51::ControllerInfoRequest*>(
      &::AR51::_ControllerInfoRequest_default_instance_);
}
inline ::AR51::ControllerInfoRequest* MultiControllerInfoRequest::release_rightcontroller() {
  // @@protoc_insertion_point(field_release:AR51.MultiControllerInfoRequest.RightController)
  
  ::AR51::ControllerInfoRequest* temp = rightcontroller_;
  rightcontroller_ = nullptr;
  return temp;
}
inline ::AR51::ControllerInfoRequest* MultiControllerInfoRequest::mutable_rightcontroller() {
  
  if (rightcontroller_ == nullptr) {
    auto* p = CreateMaybeMessage<::AR51::ControllerInfoRequest>(GetArenaNoVirtual());
    rightcontroller_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AR51.MultiControllerInfoRequest.RightController)
  return rightcontroller_;
}
inline void MultiControllerInfoRequest::set_allocated_rightcontroller(::AR51::ControllerInfoRequest* rightcontroller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rightcontroller_;
  }
  if (rightcontroller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rightcontroller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rightcontroller, submessage_arena);
    }
    
  } else {
    
  }
  rightcontroller_ = rightcontroller;
  // @@protoc_insertion_point(field_set_allocated:AR51.MultiControllerInfoRequest.RightController)
}

// -------------------------------------------------------------------

// SkeletonReply

// string Id = 1;
inline void SkeletonReply::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SkeletonReply::id() const {
  // @@protoc_insertion_point(field_get:AR51.SkeletonReply.Id)
  return id_.GetNoArena();
}
inline void SkeletonReply::set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.SkeletonReply.Id)
}
inline void SkeletonReply::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.SkeletonReply.Id)
}
inline void SkeletonReply::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.SkeletonReply.Id)
}
inline void SkeletonReply::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.SkeletonReply.Id)
}
inline std::string* SkeletonReply::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:AR51.SkeletonReply.Id)
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SkeletonReply::release_id() {
  // @@protoc_insertion_point(field_release:AR51.SkeletonReply.Id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SkeletonReply::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:AR51.SkeletonReply.Id)
}

// string AnchorId = 2;
inline void SkeletonReply::clear_anchorid() {
  anchorid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SkeletonReply::anchorid() const {
  // @@protoc_insertion_point(field_get:AR51.SkeletonReply.AnchorId)
  return anchorid_.GetNoArena();
}
inline void SkeletonReply::set_anchorid(const std::string& value) {
  
  anchorid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.SkeletonReply.AnchorId)
}
inline void SkeletonReply::set_anchorid(std::string&& value) {
  
  anchorid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.SkeletonReply.AnchorId)
}
inline void SkeletonReply::set_anchorid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  anchorid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.SkeletonReply.AnchorId)
}
inline void SkeletonReply::set_anchorid(const char* value, size_t size) {
  
  anchorid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.SkeletonReply.AnchorId)
}
inline std::string* SkeletonReply::mutable_anchorid() {
  
  // @@protoc_insertion_point(field_mutable:AR51.SkeletonReply.AnchorId)
  return anchorid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SkeletonReply::release_anchorid() {
  // @@protoc_insertion_point(field_release:AR51.SkeletonReply.AnchorId)
  
  return anchorid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SkeletonReply::set_allocated_anchorid(std::string* anchorid) {
  if (anchorid != nullptr) {
    
  } else {
    
  }
  anchorid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), anchorid);
  // @@protoc_insertion_point(field_set_allocated:AR51.SkeletonReply.AnchorId)
}

// bytes Positions = 3;
inline void SkeletonReply::clear_positions() {
  positions_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SkeletonReply::positions() const {
  // @@protoc_insertion_point(field_get:AR51.SkeletonReply.Positions)
  return positions_.GetNoArena();
}
inline void SkeletonReply::set_positions(const std::string& value) {
  
  positions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.SkeletonReply.Positions)
}
inline void SkeletonReply::set_positions(std::string&& value) {
  
  positions_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.SkeletonReply.Positions)
}
inline void SkeletonReply::set_positions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  positions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.SkeletonReply.Positions)
}
inline void SkeletonReply::set_positions(const void* value, size_t size) {
  
  positions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.SkeletonReply.Positions)
}
inline std::string* SkeletonReply::mutable_positions() {
  
  // @@protoc_insertion_point(field_mutable:AR51.SkeletonReply.Positions)
  return positions_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SkeletonReply::release_positions() {
  // @@protoc_insertion_point(field_release:AR51.SkeletonReply.Positions)
  
  return positions_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SkeletonReply::set_allocated_positions(std::string* positions) {
  if (positions != nullptr) {
    
  } else {
    
  }
  positions_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), positions);
  // @@protoc_insertion_point(field_set_allocated:AR51.SkeletonReply.Positions)
}

// bytes LeftHandRotation = 4;
inline void SkeletonReply::clear_lefthandrotation() {
  lefthandrotation_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SkeletonReply::lefthandrotation() const {
  // @@protoc_insertion_point(field_get:AR51.SkeletonReply.LeftHandRotation)
  return lefthandrotation_.GetNoArena();
}
inline void SkeletonReply::set_lefthandrotation(const std::string& value) {
  
  lefthandrotation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.SkeletonReply.LeftHandRotation)
}
inline void SkeletonReply::set_lefthandrotation(std::string&& value) {
  
  lefthandrotation_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.SkeletonReply.LeftHandRotation)
}
inline void SkeletonReply::set_lefthandrotation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  lefthandrotation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.SkeletonReply.LeftHandRotation)
}
inline void SkeletonReply::set_lefthandrotation(const void* value, size_t size) {
  
  lefthandrotation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.SkeletonReply.LeftHandRotation)
}
inline std::string* SkeletonReply::mutable_lefthandrotation() {
  
  // @@protoc_insertion_point(field_mutable:AR51.SkeletonReply.LeftHandRotation)
  return lefthandrotation_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SkeletonReply::release_lefthandrotation() {
  // @@protoc_insertion_point(field_release:AR51.SkeletonReply.LeftHandRotation)
  
  return lefthandrotation_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SkeletonReply::set_allocated_lefthandrotation(std::string* lefthandrotation) {
  if (lefthandrotation != nullptr) {
    
  } else {
    
  }
  lefthandrotation_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lefthandrotation);
  // @@protoc_insertion_point(field_set_allocated:AR51.SkeletonReply.LeftHandRotation)
}

// bytes RightHandRotation = 5;
inline void SkeletonReply::clear_righthandrotation() {
  righthandrotation_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SkeletonReply::righthandrotation() const {
  // @@protoc_insertion_point(field_get:AR51.SkeletonReply.RightHandRotation)
  return righthandrotation_.GetNoArena();
}
inline void SkeletonReply::set_righthandrotation(const std::string& value) {
  
  righthandrotation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.SkeletonReply.RightHandRotation)
}
inline void SkeletonReply::set_righthandrotation(std::string&& value) {
  
  righthandrotation_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.SkeletonReply.RightHandRotation)
}
inline void SkeletonReply::set_righthandrotation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  righthandrotation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.SkeletonReply.RightHandRotation)
}
inline void SkeletonReply::set_righthandrotation(const void* value, size_t size) {
  
  righthandrotation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.SkeletonReply.RightHandRotation)
}
inline std::string* SkeletonReply::mutable_righthandrotation() {
  
  // @@protoc_insertion_point(field_mutable:AR51.SkeletonReply.RightHandRotation)
  return righthandrotation_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SkeletonReply::release_righthandrotation() {
  // @@protoc_insertion_point(field_release:AR51.SkeletonReply.RightHandRotation)
  
  return righthandrotation_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SkeletonReply::set_allocated_righthandrotation(std::string* righthandrotation) {
  if (righthandrotation != nullptr) {
    
  } else {
    
  }
  righthandrotation_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), righthandrotation);
  // @@protoc_insertion_point(field_set_allocated:AR51.SkeletonReply.RightHandRotation)
}

// bool HasHeadLocalRotation = 6;
inline void SkeletonReply::clear_hasheadlocalrotation() {
  hasheadlocalrotation_ = false;
}
inline bool SkeletonReply::hasheadlocalrotation() const {
  // @@protoc_insertion_point(field_get:AR51.SkeletonReply.HasHeadLocalRotation)
  return hasheadlocalrotation_;
}
inline void SkeletonReply::set_hasheadlocalrotation(bool value) {
  
  hasheadlocalrotation_ = value;
  // @@protoc_insertion_point(field_set:AR51.SkeletonReply.HasHeadLocalRotation)
}

// .AR51.Quaternion HeadLocalRotation = 7;
inline bool SkeletonReply::has_headlocalrotation() const {
  return this != internal_default_instance() && headlocalrotation_ != nullptr;
}
inline const ::AR51::Quaternion& SkeletonReply::headlocalrotation() const {
  const ::AR51::Quaternion* p = headlocalrotation_;
  // @@protoc_insertion_point(field_get:AR51.SkeletonReply.HeadLocalRotation)
  return p != nullptr ? *p : *reinterpret_cast<const ::AR51::Quaternion*>(
      &::AR51::_Quaternion_default_instance_);
}
inline ::AR51::Quaternion* SkeletonReply::release_headlocalrotation() {
  // @@protoc_insertion_point(field_release:AR51.SkeletonReply.HeadLocalRotation)
  
  ::AR51::Quaternion* temp = headlocalrotation_;
  headlocalrotation_ = nullptr;
  return temp;
}
inline ::AR51::Quaternion* SkeletonReply::mutable_headlocalrotation() {
  
  if (headlocalrotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::AR51::Quaternion>(GetArenaNoVirtual());
    headlocalrotation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AR51.SkeletonReply.HeadLocalRotation)
  return headlocalrotation_;
}
inline void SkeletonReply::set_allocated_headlocalrotation(::AR51::Quaternion* headlocalrotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(headlocalrotation_);
  }
  if (headlocalrotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      headlocalrotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, headlocalrotation, submessage_arena);
    }
    
  } else {
    
  }
  headlocalrotation_ = headlocalrotation;
  // @@protoc_insertion_point(field_set_allocated:AR51.SkeletonReply.HeadLocalRotation)
}

// bool HasWristPositions = 8;
inline void SkeletonReply::clear_haswristpositions() {
  haswristpositions_ = false;
}
inline bool SkeletonReply::haswristpositions() const {
  // @@protoc_insertion_point(field_get:AR51.SkeletonReply.HasWristPositions)
  return haswristpositions_;
}
inline void SkeletonReply::set_haswristpositions(bool value) {
  
  haswristpositions_ = value;
  // @@protoc_insertion_point(field_set:AR51.SkeletonReply.HasWristPositions)
}

// .AR51.Vector3 LeftWristPosition = 9;
inline bool SkeletonReply::has_leftwristposition() const {
  return this != internal_default_instance() && leftwristposition_ != nullptr;
}
inline const ::AR51::Vector3& SkeletonReply::leftwristposition() const {
  const ::AR51::Vector3* p = leftwristposition_;
  // @@protoc_insertion_point(field_get:AR51.SkeletonReply.LeftWristPosition)
  return p != nullptr ? *p : *reinterpret_cast<const ::AR51::Vector3*>(
      &::AR51::_Vector3_default_instance_);
}
inline ::AR51::Vector3* SkeletonReply::release_leftwristposition() {
  // @@protoc_insertion_point(field_release:AR51.SkeletonReply.LeftWristPosition)
  
  ::AR51::Vector3* temp = leftwristposition_;
  leftwristposition_ = nullptr;
  return temp;
}
inline ::AR51::Vector3* SkeletonReply::mutable_leftwristposition() {
  
  if (leftwristposition_ == nullptr) {
    auto* p = CreateMaybeMessage<::AR51::Vector3>(GetArenaNoVirtual());
    leftwristposition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AR51.SkeletonReply.LeftWristPosition)
  return leftwristposition_;
}
inline void SkeletonReply::set_allocated_leftwristposition(::AR51::Vector3* leftwristposition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(leftwristposition_);
  }
  if (leftwristposition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      leftwristposition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leftwristposition, submessage_arena);
    }
    
  } else {
    
  }
  leftwristposition_ = leftwristposition;
  // @@protoc_insertion_point(field_set_allocated:AR51.SkeletonReply.LeftWristPosition)
}

// .AR51.Vector3 RightWristPosition = 10;
inline bool SkeletonReply::has_rightwristposition() const {
  return this != internal_default_instance() && rightwristposition_ != nullptr;
}
inline const ::AR51::Vector3& SkeletonReply::rightwristposition() const {
  const ::AR51::Vector3* p = rightwristposition_;
  // @@protoc_insertion_point(field_get:AR51.SkeletonReply.RightWristPosition)
  return p != nullptr ? *p : *reinterpret_cast<const ::AR51::Vector3*>(
      &::AR51::_Vector3_default_instance_);
}
inline ::AR51::Vector3* SkeletonReply::release_rightwristposition() {
  // @@protoc_insertion_point(field_release:AR51.SkeletonReply.RightWristPosition)
  
  ::AR51::Vector3* temp = rightwristposition_;
  rightwristposition_ = nullptr;
  return temp;
}
inline ::AR51::Vector3* SkeletonReply::mutable_rightwristposition() {
  
  if (rightwristposition_ == nullptr) {
    auto* p = CreateMaybeMessage<::AR51::Vector3>(GetArenaNoVirtual());
    rightwristposition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AR51.SkeletonReply.RightWristPosition)
  return rightwristposition_;
}
inline void SkeletonReply::set_allocated_rightwristposition(::AR51::Vector3* rightwristposition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(rightwristposition_);
  }
  if (rightwristposition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rightwristposition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rightwristposition, submessage_arena);
    }
    
  } else {
    
  }
  rightwristposition_ = rightwristposition;
  // @@protoc_insertion_point(field_set_allocated:AR51.SkeletonReply.RightWristPosition)
}

// bytes LeftHandPositions = 11;
inline void SkeletonReply::clear_lefthandpositions() {
  lefthandpositions_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SkeletonReply::lefthandpositions() const {
  // @@protoc_insertion_point(field_get:AR51.SkeletonReply.LeftHandPositions)
  return lefthandpositions_.GetNoArena();
}
inline void SkeletonReply::set_lefthandpositions(const std::string& value) {
  
  lefthandpositions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.SkeletonReply.LeftHandPositions)
}
inline void SkeletonReply::set_lefthandpositions(std::string&& value) {
  
  lefthandpositions_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.SkeletonReply.LeftHandPositions)
}
inline void SkeletonReply::set_lefthandpositions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  lefthandpositions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.SkeletonReply.LeftHandPositions)
}
inline void SkeletonReply::set_lefthandpositions(const void* value, size_t size) {
  
  lefthandpositions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.SkeletonReply.LeftHandPositions)
}
inline std::string* SkeletonReply::mutable_lefthandpositions() {
  
  // @@protoc_insertion_point(field_mutable:AR51.SkeletonReply.LeftHandPositions)
  return lefthandpositions_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SkeletonReply::release_lefthandpositions() {
  // @@protoc_insertion_point(field_release:AR51.SkeletonReply.LeftHandPositions)
  
  return lefthandpositions_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SkeletonReply::set_allocated_lefthandpositions(std::string* lefthandpositions) {
  if (lefthandpositions != nullptr) {
    
  } else {
    
  }
  lefthandpositions_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lefthandpositions);
  // @@protoc_insertion_point(field_set_allocated:AR51.SkeletonReply.LeftHandPositions)
}

// bytes RightHandPositions = 12;
inline void SkeletonReply::clear_righthandpositions() {
  righthandpositions_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SkeletonReply::righthandpositions() const {
  // @@protoc_insertion_point(field_get:AR51.SkeletonReply.RightHandPositions)
  return righthandpositions_.GetNoArena();
}
inline void SkeletonReply::set_righthandpositions(const std::string& value) {
  
  righthandpositions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.SkeletonReply.RightHandPositions)
}
inline void SkeletonReply::set_righthandpositions(std::string&& value) {
  
  righthandpositions_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.SkeletonReply.RightHandPositions)
}
inline void SkeletonReply::set_righthandpositions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  righthandpositions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.SkeletonReply.RightHandPositions)
}
inline void SkeletonReply::set_righthandpositions(const void* value, size_t size) {
  
  righthandpositions_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.SkeletonReply.RightHandPositions)
}
inline std::string* SkeletonReply::mutable_righthandpositions() {
  
  // @@protoc_insertion_point(field_mutable:AR51.SkeletonReply.RightHandPositions)
  return righthandpositions_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SkeletonReply::release_righthandpositions() {
  // @@protoc_insertion_point(field_release:AR51.SkeletonReply.RightHandPositions)
  
  return righthandpositions_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SkeletonReply::set_allocated_righthandpositions(std::string* righthandpositions) {
  if (righthandpositions != nullptr) {
    
  } else {
    
  }
  righthandpositions_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), righthandpositions);
  // @@protoc_insertion_point(field_set_allocated:AR51.SkeletonReply.RightHandPositions)
}

// double CaptureTime = 13;
inline void SkeletonReply::clear_capturetime() {
  capturetime_ = 0;
}
inline double SkeletonReply::capturetime() const {
  // @@protoc_insertion_point(field_get:AR51.SkeletonReply.CaptureTime)
  return capturetime_;
}
inline void SkeletonReply::set_capturetime(double value) {
  
  capturetime_ = value;
  // @@protoc_insertion_point(field_set:AR51.SkeletonReply.CaptureTime)
}

// bytes Confidence = 14;
inline void SkeletonReply::clear_confidence() {
  confidence_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SkeletonReply::confidence() const {
  // @@protoc_insertion_point(field_get:AR51.SkeletonReply.Confidence)
  return confidence_.GetNoArena();
}
inline void SkeletonReply::set_confidence(const std::string& value) {
  
  confidence_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.SkeletonReply.Confidence)
}
inline void SkeletonReply::set_confidence(std::string&& value) {
  
  confidence_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.SkeletonReply.Confidence)
}
inline void SkeletonReply::set_confidence(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  confidence_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.SkeletonReply.Confidence)
}
inline void SkeletonReply::set_confidence(const void* value, size_t size) {
  
  confidence_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.SkeletonReply.Confidence)
}
inline std::string* SkeletonReply::mutable_confidence() {
  
  // @@protoc_insertion_point(field_mutable:AR51.SkeletonReply.Confidence)
  return confidence_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SkeletonReply::release_confidence() {
  // @@protoc_insertion_point(field_release:AR51.SkeletonReply.Confidence)
  
  return confidence_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SkeletonReply::set_allocated_confidence(std::string* confidence) {
  if (confidence != nullptr) {
    
  } else {
    
  }
  confidence_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), confidence);
  // @@protoc_insertion_point(field_set_allocated:AR51.SkeletonReply.Confidence)
}

// .AR51.MultiControllerInfoRequest MultiControllerInfo = 15;
inline bool SkeletonReply::has_multicontrollerinfo() const {
  return this != internal_default_instance() && multicontrollerinfo_ != nullptr;
}
inline void SkeletonReply::clear_multicontrollerinfo() {
  if (GetArenaNoVirtual() == nullptr && multicontrollerinfo_ != nullptr) {
    delete multicontrollerinfo_;
  }
  multicontrollerinfo_ = nullptr;
}
inline const ::AR51::MultiControllerInfoRequest& SkeletonReply::multicontrollerinfo() const {
  const ::AR51::MultiControllerInfoRequest* p = multicontrollerinfo_;
  // @@protoc_insertion_point(field_get:AR51.SkeletonReply.MultiControllerInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::AR51::MultiControllerInfoRequest*>(
      &::AR51::_MultiControllerInfoRequest_default_instance_);
}
inline ::AR51::MultiControllerInfoRequest* SkeletonReply::release_multicontrollerinfo() {
  // @@protoc_insertion_point(field_release:AR51.SkeletonReply.MultiControllerInfo)
  
  ::AR51::MultiControllerInfoRequest* temp = multicontrollerinfo_;
  multicontrollerinfo_ = nullptr;
  return temp;
}
inline ::AR51::MultiControllerInfoRequest* SkeletonReply::mutable_multicontrollerinfo() {
  
  if (multicontrollerinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::AR51::MultiControllerInfoRequest>(GetArenaNoVirtual());
    multicontrollerinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AR51.SkeletonReply.MultiControllerInfo)
  return multicontrollerinfo_;
}
inline void SkeletonReply::set_allocated_multicontrollerinfo(::AR51::MultiControllerInfoRequest* multicontrollerinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete multicontrollerinfo_;
  }
  if (multicontrollerinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      multicontrollerinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multicontrollerinfo, submessage_arena);
    }
    
  } else {
    
  }
  multicontrollerinfo_ = multicontrollerinfo;
  // @@protoc_insertion_point(field_set_allocated:AR51.SkeletonReply.MultiControllerInfo)
}

// string DeviceId = 16;
inline void SkeletonReply::clear_deviceid() {
  deviceid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SkeletonReply::deviceid() const {
  // @@protoc_insertion_point(field_get:AR51.SkeletonReply.DeviceId)
  return deviceid_.GetNoArena();
}
inline void SkeletonReply::set_deviceid(const std::string& value) {
  
  deviceid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.SkeletonReply.DeviceId)
}
inline void SkeletonReply::set_deviceid(std::string&& value) {
  
  deviceid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.SkeletonReply.DeviceId)
}
inline void SkeletonReply::set_deviceid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  deviceid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.SkeletonReply.DeviceId)
}
inline void SkeletonReply::set_deviceid(const char* value, size_t size) {
  
  deviceid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.SkeletonReply.DeviceId)
}
inline std::string* SkeletonReply::mutable_deviceid() {
  
  // @@protoc_insertion_point(field_mutable:AR51.SkeletonReply.DeviceId)
  return deviceid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SkeletonReply::release_deviceid() {
  // @@protoc_insertion_point(field_release:AR51.SkeletonReply.DeviceId)
  
  return deviceid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SkeletonReply::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  deviceid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), deviceid);
  // @@protoc_insertion_point(field_set_allocated:AR51.SkeletonReply.DeviceId)
}

// string CharacterPrefab = 17;
inline void SkeletonReply::clear_characterprefab() {
  characterprefab_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SkeletonReply::characterprefab() const {
  // @@protoc_insertion_point(field_get:AR51.SkeletonReply.CharacterPrefab)
  return characterprefab_.GetNoArena();
}
inline void SkeletonReply::set_characterprefab(const std::string& value) {
  
  characterprefab_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.SkeletonReply.CharacterPrefab)
}
inline void SkeletonReply::set_characterprefab(std::string&& value) {
  
  characterprefab_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.SkeletonReply.CharacterPrefab)
}
inline void SkeletonReply::set_characterprefab(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  characterprefab_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.SkeletonReply.CharacterPrefab)
}
inline void SkeletonReply::set_characterprefab(const char* value, size_t size) {
  
  characterprefab_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.SkeletonReply.CharacterPrefab)
}
inline std::string* SkeletonReply::mutable_characterprefab() {
  
  // @@protoc_insertion_point(field_mutable:AR51.SkeletonReply.CharacterPrefab)
  return characterprefab_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SkeletonReply::release_characterprefab() {
  // @@protoc_insertion_point(field_release:AR51.SkeletonReply.CharacterPrefab)
  
  return characterprefab_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SkeletonReply::set_allocated_characterprefab(std::string* characterprefab) {
  if (characterprefab != nullptr) {
    
  } else {
    
  }
  characterprefab_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), characterprefab);
  // @@protoc_insertion_point(field_set_allocated:AR51.SkeletonReply.CharacterPrefab)
}

// -------------------------------------------------------------------

// BoundInfo

// .AR51.Vector3 Center = 1;
inline bool BoundInfo::has_center() const {
  return this != internal_default_instance() && center_ != nullptr;
}
inline const ::AR51::Vector3& BoundInfo::center() const {
  const ::AR51::Vector3* p = center_;
  // @@protoc_insertion_point(field_get:AR51.BoundInfo.Center)
  return p != nullptr ? *p : *reinterpret_cast<const ::AR51::Vector3*>(
      &::AR51::_Vector3_default_instance_);
}
inline ::AR51::Vector3* BoundInfo::release_center() {
  // @@protoc_insertion_point(field_release:AR51.BoundInfo.Center)
  
  ::AR51::Vector3* temp = center_;
  center_ = nullptr;
  return temp;
}
inline ::AR51::Vector3* BoundInfo::mutable_center() {
  
  if (center_ == nullptr) {
    auto* p = CreateMaybeMessage<::AR51::Vector3>(GetArenaNoVirtual());
    center_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AR51.BoundInfo.Center)
  return center_;
}
inline void BoundInfo::set_allocated_center(::AR51::Vector3* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_);
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    
  } else {
    
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:AR51.BoundInfo.Center)
}

// .AR51.Vector3 Extents = 2;
inline bool BoundInfo::has_extents() const {
  return this != internal_default_instance() && extents_ != nullptr;
}
inline const ::AR51::Vector3& BoundInfo::extents() const {
  const ::AR51::Vector3* p = extents_;
  // @@protoc_insertion_point(field_get:AR51.BoundInfo.Extents)
  return p != nullptr ? *p : *reinterpret_cast<const ::AR51::Vector3*>(
      &::AR51::_Vector3_default_instance_);
}
inline ::AR51::Vector3* BoundInfo::release_extents() {
  // @@protoc_insertion_point(field_release:AR51.BoundInfo.Extents)
  
  ::AR51::Vector3* temp = extents_;
  extents_ = nullptr;
  return temp;
}
inline ::AR51::Vector3* BoundInfo::mutable_extents() {
  
  if (extents_ == nullptr) {
    auto* p = CreateMaybeMessage<::AR51::Vector3>(GetArenaNoVirtual());
    extents_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AR51.BoundInfo.Extents)
  return extents_;
}
inline void BoundInfo::set_allocated_extents(::AR51::Vector3* extents) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(extents_);
  }
  if (extents) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      extents = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extents, submessage_arena);
    }
    
  } else {
    
  }
  extents_ = extents;
  // @@protoc_insertion_point(field_set_allocated:AR51.BoundInfo.Extents)
}

// -------------------------------------------------------------------

// DeviceInfo

// string Name = 1;
inline void DeviceInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DeviceInfo::name() const {
  // @@protoc_insertion_point(field_get:AR51.DeviceInfo.Name)
  return name_.GetNoArena();
}
inline void DeviceInfo::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.DeviceInfo.Name)
}
inline void DeviceInfo::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.DeviceInfo.Name)
}
inline void DeviceInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.DeviceInfo.Name)
}
inline void DeviceInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.DeviceInfo.Name)
}
inline std::string* DeviceInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:AR51.DeviceInfo.Name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceInfo::release_name() {
  // @@protoc_insertion_point(field_release:AR51.DeviceInfo.Name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:AR51.DeviceInfo.Name)
}

// string IpAddress = 2;
inline void DeviceInfo::clear_ipaddress() {
  ipaddress_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DeviceInfo::ipaddress() const {
  // @@protoc_insertion_point(field_get:AR51.DeviceInfo.IpAddress)
  return ipaddress_.GetNoArena();
}
inline void DeviceInfo::set_ipaddress(const std::string& value) {
  
  ipaddress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.DeviceInfo.IpAddress)
}
inline void DeviceInfo::set_ipaddress(std::string&& value) {
  
  ipaddress_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.DeviceInfo.IpAddress)
}
inline void DeviceInfo::set_ipaddress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ipaddress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.DeviceInfo.IpAddress)
}
inline void DeviceInfo::set_ipaddress(const char* value, size_t size) {
  
  ipaddress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.DeviceInfo.IpAddress)
}
inline std::string* DeviceInfo::mutable_ipaddress() {
  
  // @@protoc_insertion_point(field_mutable:AR51.DeviceInfo.IpAddress)
  return ipaddress_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceInfo::release_ipaddress() {
  // @@protoc_insertion_point(field_release:AR51.DeviceInfo.IpAddress)
  
  return ipaddress_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_ipaddress(std::string* ipaddress) {
  if (ipaddress != nullptr) {
    
  } else {
    
  }
  ipaddress_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ipaddress);
  // @@protoc_insertion_point(field_set_allocated:AR51.DeviceInfo.IpAddress)
}

// -------------------------------------------------------------------

// CalibrationStatus

// double Progress = 1;
inline void CalibrationStatus::clear_progress() {
  progress_ = 0;
}
inline double CalibrationStatus::progress() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationStatus.Progress)
  return progress_;
}
inline void CalibrationStatus::set_progress(double value) {
  
  progress_ = value;
  // @@protoc_insertion_point(field_set:AR51.CalibrationStatus.Progress)
}

// double Quality = 2;
inline void CalibrationStatus::clear_quality() {
  quality_ = 0;
}
inline double CalibrationStatus::quality() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationStatus.Quality)
  return quality_;
}
inline void CalibrationStatus::set_quality(double value) {
  
  quality_ = value;
  // @@protoc_insertion_point(field_set:AR51.CalibrationStatus.Quality)
}

// double ReprojectionError = 3;
inline void CalibrationStatus::clear_reprojectionerror() {
  reprojectionerror_ = 0;
}
inline double CalibrationStatus::reprojectionerror() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationStatus.ReprojectionError)
  return reprojectionerror_;
}
inline void CalibrationStatus::set_reprojectionerror(double value) {
  
  reprojectionerror_ = value;
  // @@protoc_insertion_point(field_set:AR51.CalibrationStatus.ReprojectionError)
}

// string Result = 4;
inline void CalibrationStatus::clear_result() {
  result_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CalibrationStatus::result() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationStatus.Result)
  return result_.GetNoArena();
}
inline void CalibrationStatus::set_result(const std::string& value) {
  
  result_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.CalibrationStatus.Result)
}
inline void CalibrationStatus::set_result(std::string&& value) {
  
  result_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.CalibrationStatus.Result)
}
inline void CalibrationStatus::set_result(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  result_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.CalibrationStatus.Result)
}
inline void CalibrationStatus::set_result(const char* value, size_t size) {
  
  result_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.CalibrationStatus.Result)
}
inline std::string* CalibrationStatus::mutable_result() {
  
  // @@protoc_insertion_point(field_mutable:AR51.CalibrationStatus.Result)
  return result_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CalibrationStatus::release_result() {
  // @@protoc_insertion_point(field_release:AR51.CalibrationStatus.Result)
  
  return result_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CalibrationStatus::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  result_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result);
  // @@protoc_insertion_point(field_set_allocated:AR51.CalibrationStatus.Result)
}

// string AnchorId = 5;
inline void CalibrationStatus::clear_anchorid() {
  anchorid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CalibrationStatus::anchorid() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationStatus.AnchorId)
  return anchorid_.GetNoArena();
}
inline void CalibrationStatus::set_anchorid(const std::string& value) {
  
  anchorid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.CalibrationStatus.AnchorId)
}
inline void CalibrationStatus::set_anchorid(std::string&& value) {
  
  anchorid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.CalibrationStatus.AnchorId)
}
inline void CalibrationStatus::set_anchorid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  anchorid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.CalibrationStatus.AnchorId)
}
inline void CalibrationStatus::set_anchorid(const char* value, size_t size) {
  
  anchorid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.CalibrationStatus.AnchorId)
}
inline std::string* CalibrationStatus::mutable_anchorid() {
  
  // @@protoc_insertion_point(field_mutable:AR51.CalibrationStatus.AnchorId)
  return anchorid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CalibrationStatus::release_anchorid() {
  // @@protoc_insertion_point(field_release:AR51.CalibrationStatus.AnchorId)
  
  return anchorid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CalibrationStatus::set_allocated_anchorid(std::string* anchorid) {
  if (anchorid != nullptr) {
    
  } else {
    
  }
  anchorid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), anchorid);
  // @@protoc_insertion_point(field_set_allocated:AR51.CalibrationStatus.AnchorId)
}

// int32 AnchorByteSize = 6;
inline void CalibrationStatus::clear_anchorbytesize() {
  anchorbytesize_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CalibrationStatus::anchorbytesize() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationStatus.AnchorByteSize)
  return anchorbytesize_;
}
inline void CalibrationStatus::set_anchorbytesize(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  anchorbytesize_ = value;
  // @@protoc_insertion_point(field_set:AR51.CalibrationStatus.AnchorByteSize)
}

// .AR51.CalibrationModes Mode = 7;
inline void CalibrationStatus::clear_mode() {
  mode_ = 0;
}
inline ::AR51::CalibrationModes CalibrationStatus::mode() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationStatus.Mode)
  return static_cast< ::AR51::CalibrationModes >(mode_);
}
inline void CalibrationStatus::set_mode(::AR51::CalibrationModes value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:AR51.CalibrationStatus.Mode)
}

// -------------------------------------------------------------------

// CalibrationPointCloudMessage

// string Name = 1;
inline void CalibrationPointCloudMessage::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CalibrationPointCloudMessage::name() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationPointCloudMessage.Name)
  return name_.GetNoArena();
}
inline void CalibrationPointCloudMessage::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.CalibrationPointCloudMessage.Name)
}
inline void CalibrationPointCloudMessage::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.CalibrationPointCloudMessage.Name)
}
inline void CalibrationPointCloudMessage::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.CalibrationPointCloudMessage.Name)
}
inline void CalibrationPointCloudMessage::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.CalibrationPointCloudMessage.Name)
}
inline std::string* CalibrationPointCloudMessage::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:AR51.CalibrationPointCloudMessage.Name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CalibrationPointCloudMessage::release_name() {
  // @@protoc_insertion_point(field_release:AR51.CalibrationPointCloudMessage.Name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CalibrationPointCloudMessage::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:AR51.CalibrationPointCloudMessage.Name)
}

// int32 Count = 2;
inline void CalibrationPointCloudMessage::clear_count() {
  count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CalibrationPointCloudMessage::count() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationPointCloudMessage.Count)
  return count_;
}
inline void CalibrationPointCloudMessage::set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:AR51.CalibrationPointCloudMessage.Count)
}

// .AR51.Color StartColor = 3;
inline bool CalibrationPointCloudMessage::has_startcolor() const {
  return this != internal_default_instance() && startcolor_ != nullptr;
}
inline const ::AR51::Color& CalibrationPointCloudMessage::startcolor() const {
  const ::AR51::Color* p = startcolor_;
  // @@protoc_insertion_point(field_get:AR51.CalibrationPointCloudMessage.StartColor)
  return p != nullptr ? *p : *reinterpret_cast<const ::AR51::Color*>(
      &::AR51::_Color_default_instance_);
}
inline ::AR51::Color* CalibrationPointCloudMessage::release_startcolor() {
  // @@protoc_insertion_point(field_release:AR51.CalibrationPointCloudMessage.StartColor)
  
  ::AR51::Color* temp = startcolor_;
  startcolor_ = nullptr;
  return temp;
}
inline ::AR51::Color* CalibrationPointCloudMessage::mutable_startcolor() {
  
  if (startcolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::AR51::Color>(GetArenaNoVirtual());
    startcolor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AR51.CalibrationPointCloudMessage.StartColor)
  return startcolor_;
}
inline void CalibrationPointCloudMessage::set_allocated_startcolor(::AR51::Color* startcolor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(startcolor_);
  }
  if (startcolor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      startcolor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, startcolor, submessage_arena);
    }
    
  } else {
    
  }
  startcolor_ = startcolor;
  // @@protoc_insertion_point(field_set_allocated:AR51.CalibrationPointCloudMessage.StartColor)
}

// .AR51.Color EndColor = 4;
inline bool CalibrationPointCloudMessage::has_endcolor() const {
  return this != internal_default_instance() && endcolor_ != nullptr;
}
inline const ::AR51::Color& CalibrationPointCloudMessage::endcolor() const {
  const ::AR51::Color* p = endcolor_;
  // @@protoc_insertion_point(field_get:AR51.CalibrationPointCloudMessage.EndColor)
  return p != nullptr ? *p : *reinterpret_cast<const ::AR51::Color*>(
      &::AR51::_Color_default_instance_);
}
inline ::AR51::Color* CalibrationPointCloudMessage::release_endcolor() {
  // @@protoc_insertion_point(field_release:AR51.CalibrationPointCloudMessage.EndColor)
  
  ::AR51::Color* temp = endcolor_;
  endcolor_ = nullptr;
  return temp;
}
inline ::AR51::Color* CalibrationPointCloudMessage::mutable_endcolor() {
  
  if (endcolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::AR51::Color>(GetArenaNoVirtual());
    endcolor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AR51.CalibrationPointCloudMessage.EndColor)
  return endcolor_;
}
inline void CalibrationPointCloudMessage::set_allocated_endcolor(::AR51::Color* endcolor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(endcolor_);
  }
  if (endcolor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      endcolor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endcolor, submessage_arena);
    }
    
  } else {
    
  }
  endcolor_ = endcolor;
  // @@protoc_insertion_point(field_set_allocated:AR51.CalibrationPointCloudMessage.EndColor)
}

// double StartSize = 5;
inline void CalibrationPointCloudMessage::clear_startsize() {
  startsize_ = 0;
}
inline double CalibrationPointCloudMessage::startsize() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationPointCloudMessage.StartSize)
  return startsize_;
}
inline void CalibrationPointCloudMessage::set_startsize(double value) {
  
  startsize_ = value;
  // @@protoc_insertion_point(field_set:AR51.CalibrationPointCloudMessage.StartSize)
}

// double EndSize = 6;
inline void CalibrationPointCloudMessage::clear_endsize() {
  endsize_ = 0;
}
inline double CalibrationPointCloudMessage::endsize() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationPointCloudMessage.EndSize)
  return endsize_;
}
inline void CalibrationPointCloudMessage::set_endsize(double value) {
  
  endsize_ = value;
  // @@protoc_insertion_point(field_set:AR51.CalibrationPointCloudMessage.EndSize)
}

// bytes Points = 7;
inline void CalibrationPointCloudMessage::clear_points() {
  points_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CalibrationPointCloudMessage::points() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationPointCloudMessage.Points)
  return points_.GetNoArena();
}
inline void CalibrationPointCloudMessage::set_points(const std::string& value) {
  
  points_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.CalibrationPointCloudMessage.Points)
}
inline void CalibrationPointCloudMessage::set_points(std::string&& value) {
  
  points_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.CalibrationPointCloudMessage.Points)
}
inline void CalibrationPointCloudMessage::set_points(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  points_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.CalibrationPointCloudMessage.Points)
}
inline void CalibrationPointCloudMessage::set_points(const void* value, size_t size) {
  
  points_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.CalibrationPointCloudMessage.Points)
}
inline std::string* CalibrationPointCloudMessage::mutable_points() {
  
  // @@protoc_insertion_point(field_mutable:AR51.CalibrationPointCloudMessage.Points)
  return points_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CalibrationPointCloudMessage::release_points() {
  // @@protoc_insertion_point(field_release:AR51.CalibrationPointCloudMessage.Points)
  
  return points_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CalibrationPointCloudMessage::set_allocated_points(std::string* points) {
  if (points != nullptr) {
    
  } else {
    
  }
  points_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), points);
  // @@protoc_insertion_point(field_set_allocated:AR51.CalibrationPointCloudMessage.Points)
}

// -------------------------------------------------------------------

// CalibrationVisualizationMessage

// .AR51.CalibrationModes Mode = 1;
inline void CalibrationVisualizationMessage::clear_mode() {
  mode_ = 0;
}
inline ::AR51::CalibrationModes CalibrationVisualizationMessage::mode() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationVisualizationMessage.Mode)
  return static_cast< ::AR51::CalibrationModes >(mode_);
}
inline void CalibrationVisualizationMessage::set_mode(::AR51::CalibrationModes value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:AR51.CalibrationVisualizationMessage.Mode)
}

// double Progress = 2;
inline void CalibrationVisualizationMessage::clear_progress() {
  progress_ = 0;
}
inline double CalibrationVisualizationMessage::progress() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationVisualizationMessage.Progress)
  return progress_;
}
inline void CalibrationVisualizationMessage::set_progress(double value) {
  
  progress_ = value;
  // @@protoc_insertion_point(field_set:AR51.CalibrationVisualizationMessage.Progress)
}

// double Quality = 3;
inline void CalibrationVisualizationMessage::clear_quality() {
  quality_ = 0;
}
inline double CalibrationVisualizationMessage::quality() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationVisualizationMessage.Quality)
  return quality_;
}
inline void CalibrationVisualizationMessage::set_quality(double value) {
  
  quality_ = value;
  // @@protoc_insertion_point(field_set:AR51.CalibrationVisualizationMessage.Quality)
}

// double ReprojectionError = 4;
inline void CalibrationVisualizationMessage::clear_reprojectionerror() {
  reprojectionerror_ = 0;
}
inline double CalibrationVisualizationMessage::reprojectionerror() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationVisualizationMessage.ReprojectionError)
  return reprojectionerror_;
}
inline void CalibrationVisualizationMessage::set_reprojectionerror(double value) {
  
  reprojectionerror_ = value;
  // @@protoc_insertion_point(field_set:AR51.CalibrationVisualizationMessage.ReprojectionError)
}

// string Title = 5;
inline void CalibrationVisualizationMessage::clear_title() {
  title_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CalibrationVisualizationMessage::title() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationVisualizationMessage.Title)
  return title_.GetNoArena();
}
inline void CalibrationVisualizationMessage::set_title(const std::string& value) {
  
  title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.CalibrationVisualizationMessage.Title)
}
inline void CalibrationVisualizationMessage::set_title(std::string&& value) {
  
  title_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.CalibrationVisualizationMessage.Title)
}
inline void CalibrationVisualizationMessage::set_title(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.CalibrationVisualizationMessage.Title)
}
inline void CalibrationVisualizationMessage::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.CalibrationVisualizationMessage.Title)
}
inline std::string* CalibrationVisualizationMessage::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:AR51.CalibrationVisualizationMessage.Title)
  return title_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CalibrationVisualizationMessage::release_title() {
  // @@protoc_insertion_point(field_release:AR51.CalibrationVisualizationMessage.Title)
  
  return title_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CalibrationVisualizationMessage::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:AR51.CalibrationVisualizationMessage.Title)
}

// string Message = 6;
inline void CalibrationVisualizationMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CalibrationVisualizationMessage::message() const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationVisualizationMessage.Message)
  return message_.GetNoArena();
}
inline void CalibrationVisualizationMessage::set_message(const std::string& value) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.CalibrationVisualizationMessage.Message)
}
inline void CalibrationVisualizationMessage::set_message(std::string&& value) {
  
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.CalibrationVisualizationMessage.Message)
}
inline void CalibrationVisualizationMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.CalibrationVisualizationMessage.Message)
}
inline void CalibrationVisualizationMessage::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.CalibrationVisualizationMessage.Message)
}
inline std::string* CalibrationVisualizationMessage::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:AR51.CalibrationVisualizationMessage.Message)
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CalibrationVisualizationMessage::release_message() {
  // @@protoc_insertion_point(field_release:AR51.CalibrationVisualizationMessage.Message)
  
  return message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CalibrationVisualizationMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:AR51.CalibrationVisualizationMessage.Message)
}

// repeated .AR51.CalibrationPointCloudMessage Points = 7;
inline int CalibrationVisualizationMessage::points_size() const {
  return points_.size();
}
inline void CalibrationVisualizationMessage::clear_points() {
  points_.Clear();
}
inline ::AR51::CalibrationPointCloudMessage* CalibrationVisualizationMessage::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:AR51.CalibrationVisualizationMessage.Points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::CalibrationPointCloudMessage >*
CalibrationVisualizationMessage::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:AR51.CalibrationVisualizationMessage.Points)
  return &points_;
}
inline const ::AR51::CalibrationPointCloudMessage& CalibrationVisualizationMessage::points(int index) const {
  // @@protoc_insertion_point(field_get:AR51.CalibrationVisualizationMessage.Points)
  return points_.Get(index);
}
inline ::AR51::CalibrationPointCloudMessage* CalibrationVisualizationMessage::add_points() {
  // @@protoc_insertion_point(field_add:AR51.CalibrationVisualizationMessage.Points)
  return points_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::CalibrationPointCloudMessage >&
CalibrationVisualizationMessage::points() const {
  // @@protoc_insertion_point(field_list:AR51.CalibrationVisualizationMessage.Points)
  return points_;
}

// -------------------------------------------------------------------

// SetCvsCameraField

// string Id = 1;
inline void SetCvsCameraField::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SetCvsCameraField::id() const {
  // @@protoc_insertion_point(field_get:AR51.SetCvsCameraField.Id)
  return id_.GetNoArena();
}
inline void SetCvsCameraField::set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.SetCvsCameraField.Id)
}
inline void SetCvsCameraField::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.SetCvsCameraField.Id)
}
inline void SetCvsCameraField::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.SetCvsCameraField.Id)
}
inline void SetCvsCameraField::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.SetCvsCameraField.Id)
}
inline std::string* SetCvsCameraField::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:AR51.SetCvsCameraField.Id)
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SetCvsCameraField::release_id() {
  // @@protoc_insertion_point(field_release:AR51.SetCvsCameraField.Id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SetCvsCameraField::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:AR51.SetCvsCameraField.Id)
}

// string FieldName = 2;
inline void SetCvsCameraField::clear_fieldname() {
  fieldname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SetCvsCameraField::fieldname() const {
  // @@protoc_insertion_point(field_get:AR51.SetCvsCameraField.FieldName)
  return fieldname_.GetNoArena();
}
inline void SetCvsCameraField::set_fieldname(const std::string& value) {
  
  fieldname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.SetCvsCameraField.FieldName)
}
inline void SetCvsCameraField::set_fieldname(std::string&& value) {
  
  fieldname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.SetCvsCameraField.FieldName)
}
inline void SetCvsCameraField::set_fieldname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  fieldname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.SetCvsCameraField.FieldName)
}
inline void SetCvsCameraField::set_fieldname(const char* value, size_t size) {
  
  fieldname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.SetCvsCameraField.FieldName)
}
inline std::string* SetCvsCameraField::mutable_fieldname() {
  
  // @@protoc_insertion_point(field_mutable:AR51.SetCvsCameraField.FieldName)
  return fieldname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SetCvsCameraField::release_fieldname() {
  // @@protoc_insertion_point(field_release:AR51.SetCvsCameraField.FieldName)
  
  return fieldname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SetCvsCameraField::set_allocated_fieldname(std::string* fieldname) {
  if (fieldname != nullptr) {
    
  } else {
    
  }
  fieldname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fieldname);
  // @@protoc_insertion_point(field_set_allocated:AR51.SetCvsCameraField.FieldName)
}

// double Value = 3;
inline void SetCvsCameraField::clear_value() {
  value_ = 0;
}
inline double SetCvsCameraField::value() const {
  // @@protoc_insertion_point(field_get:AR51.SetCvsCameraField.Value)
  return value_;
}
inline void SetCvsCameraField::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:AR51.SetCvsCameraField.Value)
}

// -------------------------------------------------------------------

// GetCvsCameraField

// string Id = 1;
inline void GetCvsCameraField::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetCvsCameraField::id() const {
  // @@protoc_insertion_point(field_get:AR51.GetCvsCameraField.Id)
  return id_.GetNoArena();
}
inline void GetCvsCameraField::set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.GetCvsCameraField.Id)
}
inline void GetCvsCameraField::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.GetCvsCameraField.Id)
}
inline void GetCvsCameraField::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.GetCvsCameraField.Id)
}
inline void GetCvsCameraField::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.GetCvsCameraField.Id)
}
inline std::string* GetCvsCameraField::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:AR51.GetCvsCameraField.Id)
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetCvsCameraField::release_id() {
  // @@protoc_insertion_point(field_release:AR51.GetCvsCameraField.Id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetCvsCameraField::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:AR51.GetCvsCameraField.Id)
}

// string FieldName = 2;
inline void GetCvsCameraField::clear_fieldname() {
  fieldname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetCvsCameraField::fieldname() const {
  // @@protoc_insertion_point(field_get:AR51.GetCvsCameraField.FieldName)
  return fieldname_.GetNoArena();
}
inline void GetCvsCameraField::set_fieldname(const std::string& value) {
  
  fieldname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.GetCvsCameraField.FieldName)
}
inline void GetCvsCameraField::set_fieldname(std::string&& value) {
  
  fieldname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.GetCvsCameraField.FieldName)
}
inline void GetCvsCameraField::set_fieldname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  fieldname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.GetCvsCameraField.FieldName)
}
inline void GetCvsCameraField::set_fieldname(const char* value, size_t size) {
  
  fieldname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.GetCvsCameraField.FieldName)
}
inline std::string* GetCvsCameraField::mutable_fieldname() {
  
  // @@protoc_insertion_point(field_mutable:AR51.GetCvsCameraField.FieldName)
  return fieldname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetCvsCameraField::release_fieldname() {
  // @@protoc_insertion_point(field_release:AR51.GetCvsCameraField.FieldName)
  
  return fieldname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetCvsCameraField::set_allocated_fieldname(std::string* fieldname) {
  if (fieldname != nullptr) {
    
  } else {
    
  }
  fieldname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fieldname);
  // @@protoc_insertion_point(field_set_allocated:AR51.GetCvsCameraField.FieldName)
}

// -------------------------------------------------------------------

// CvsCameraInfo

// string Id = 1;
inline void CvsCameraInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CvsCameraInfo::id() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraInfo.Id)
  return id_.GetNoArena();
}
inline void CvsCameraInfo::set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.CvsCameraInfo.Id)
}
inline void CvsCameraInfo::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.CvsCameraInfo.Id)
}
inline void CvsCameraInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.CvsCameraInfo.Id)
}
inline void CvsCameraInfo::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.CvsCameraInfo.Id)
}
inline std::string* CvsCameraInfo::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:AR51.CvsCameraInfo.Id)
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CvsCameraInfo::release_id() {
  // @@protoc_insertion_point(field_release:AR51.CvsCameraInfo.Id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CvsCameraInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:AR51.CvsCameraInfo.Id)
}

// bytes Intrisic = 2;
inline void CvsCameraInfo::clear_intrisic() {
  intrisic_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CvsCameraInfo::intrisic() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraInfo.Intrisic)
  return intrisic_.GetNoArena();
}
inline void CvsCameraInfo::set_intrisic(const std::string& value) {
  
  intrisic_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.CvsCameraInfo.Intrisic)
}
inline void CvsCameraInfo::set_intrisic(std::string&& value) {
  
  intrisic_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.CvsCameraInfo.Intrisic)
}
inline void CvsCameraInfo::set_intrisic(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  intrisic_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.CvsCameraInfo.Intrisic)
}
inline void CvsCameraInfo::set_intrisic(const void* value, size_t size) {
  
  intrisic_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.CvsCameraInfo.Intrisic)
}
inline std::string* CvsCameraInfo::mutable_intrisic() {
  
  // @@protoc_insertion_point(field_mutable:AR51.CvsCameraInfo.Intrisic)
  return intrisic_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CvsCameraInfo::release_intrisic() {
  // @@protoc_insertion_point(field_release:AR51.CvsCameraInfo.Intrisic)
  
  return intrisic_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CvsCameraInfo::set_allocated_intrisic(std::string* intrisic) {
  if (intrisic != nullptr) {
    
  } else {
    
  }
  intrisic_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), intrisic);
  // @@protoc_insertion_point(field_set_allocated:AR51.CvsCameraInfo.Intrisic)
}

// bytes Extrensic = 3;
inline void CvsCameraInfo::clear_extrensic() {
  extrensic_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CvsCameraInfo::extrensic() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraInfo.Extrensic)
  return extrensic_.GetNoArena();
}
inline void CvsCameraInfo::set_extrensic(const std::string& value) {
  
  extrensic_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.CvsCameraInfo.Extrensic)
}
inline void CvsCameraInfo::set_extrensic(std::string&& value) {
  
  extrensic_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.CvsCameraInfo.Extrensic)
}
inline void CvsCameraInfo::set_extrensic(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  extrensic_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.CvsCameraInfo.Extrensic)
}
inline void CvsCameraInfo::set_extrensic(const void* value, size_t size) {
  
  extrensic_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.CvsCameraInfo.Extrensic)
}
inline std::string* CvsCameraInfo::mutable_extrensic() {
  
  // @@protoc_insertion_point(field_mutable:AR51.CvsCameraInfo.Extrensic)
  return extrensic_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CvsCameraInfo::release_extrensic() {
  // @@protoc_insertion_point(field_release:AR51.CvsCameraInfo.Extrensic)
  
  return extrensic_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CvsCameraInfo::set_allocated_extrensic(std::string* extrensic) {
  if (extrensic != nullptr) {
    
  } else {
    
  }
  extrensic_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extrensic);
  // @@protoc_insertion_point(field_set_allocated:AR51.CvsCameraInfo.Extrensic)
}

// int32 Width = 4;
inline void CvsCameraInfo::clear_width() {
  width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CvsCameraInfo::width() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraInfo.Width)
  return width_;
}
inline void CvsCameraInfo::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:AR51.CvsCameraInfo.Width)
}

// int32 Height = 5;
inline void CvsCameraInfo::clear_height() {
  height_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CvsCameraInfo::height() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraInfo.Height)
  return height_;
}
inline void CvsCameraInfo::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:AR51.CvsCameraInfo.Height)
}

// int32 FrameRate = 6;
inline void CvsCameraInfo::clear_framerate() {
  framerate_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CvsCameraInfo::framerate() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraInfo.FrameRate)
  return framerate_;
}
inline void CvsCameraInfo::set_framerate(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  framerate_ = value;
  // @@protoc_insertion_point(field_set:AR51.CvsCameraInfo.FrameRate)
}

// bool IsConnected = 7;
inline void CvsCameraInfo::clear_isconnected() {
  isconnected_ = false;
}
inline bool CvsCameraInfo::isconnected() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraInfo.IsConnected)
  return isconnected_;
}
inline void CvsCameraInfo::set_isconnected(bool value) {
  
  isconnected_ = value;
  // @@protoc_insertion_point(field_set:AR51.CvsCameraInfo.IsConnected)
}

// repeated .AR51.SetCvsCameraField Fields = 8;
inline int CvsCameraInfo::fields_size() const {
  return fields_.size();
}
inline void CvsCameraInfo::clear_fields() {
  fields_.Clear();
}
inline ::AR51::SetCvsCameraField* CvsCameraInfo::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:AR51.CvsCameraInfo.Fields)
  return fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::SetCvsCameraField >*
CvsCameraInfo::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:AR51.CvsCameraInfo.Fields)
  return &fields_;
}
inline const ::AR51::SetCvsCameraField& CvsCameraInfo::fields(int index) const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraInfo.Fields)
  return fields_.Get(index);
}
inline ::AR51::SetCvsCameraField* CvsCameraInfo::add_fields() {
  // @@protoc_insertion_point(field_add:AR51.CvsCameraInfo.Fields)
  return fields_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::SetCvsCameraField >&
CvsCameraInfo::fields() const {
  // @@protoc_insertion_point(field_list:AR51.CvsCameraInfo.Fields)
  return fields_;
}

// bool IsRemote = 9;
inline void CvsCameraInfo::clear_isremote() {
  isremote_ = false;
}
inline bool CvsCameraInfo::isremote() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraInfo.IsRemote)
  return isremote_;
}
inline void CvsCameraInfo::set_isremote(bool value) {
  
  isremote_ = value;
  // @@protoc_insertion_point(field_set:AR51.CvsCameraInfo.IsRemote)
}

// string RemoteEndpoint = 10;
inline void CvsCameraInfo::clear_remoteendpoint() {
  remoteendpoint_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CvsCameraInfo::remoteendpoint() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraInfo.RemoteEndpoint)
  return remoteendpoint_.GetNoArena();
}
inline void CvsCameraInfo::set_remoteendpoint(const std::string& value) {
  
  remoteendpoint_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.CvsCameraInfo.RemoteEndpoint)
}
inline void CvsCameraInfo::set_remoteendpoint(std::string&& value) {
  
  remoteendpoint_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.CvsCameraInfo.RemoteEndpoint)
}
inline void CvsCameraInfo::set_remoteendpoint(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  remoteendpoint_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.CvsCameraInfo.RemoteEndpoint)
}
inline void CvsCameraInfo::set_remoteendpoint(const char* value, size_t size) {
  
  remoteendpoint_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.CvsCameraInfo.RemoteEndpoint)
}
inline std::string* CvsCameraInfo::mutable_remoteendpoint() {
  
  // @@protoc_insertion_point(field_mutable:AR51.CvsCameraInfo.RemoteEndpoint)
  return remoteendpoint_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CvsCameraInfo::release_remoteendpoint() {
  // @@protoc_insertion_point(field_release:AR51.CvsCameraInfo.RemoteEndpoint)
  
  return remoteendpoint_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CvsCameraInfo::set_allocated_remoteendpoint(std::string* remoteendpoint) {
  if (remoteendpoint != nullptr) {
    
  } else {
    
  }
  remoteendpoint_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remoteendpoint);
  // @@protoc_insertion_point(field_set_allocated:AR51.CvsCameraInfo.RemoteEndpoint)
}

// string CameraType = 11;
inline void CvsCameraInfo::clear_cameratype() {
  cameratype_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CvsCameraInfo::cameratype() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraInfo.CameraType)
  return cameratype_.GetNoArena();
}
inline void CvsCameraInfo::set_cameratype(const std::string& value) {
  
  cameratype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.CvsCameraInfo.CameraType)
}
inline void CvsCameraInfo::set_cameratype(std::string&& value) {
  
  cameratype_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.CvsCameraInfo.CameraType)
}
inline void CvsCameraInfo::set_cameratype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cameratype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.CvsCameraInfo.CameraType)
}
inline void CvsCameraInfo::set_cameratype(const char* value, size_t size) {
  
  cameratype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.CvsCameraInfo.CameraType)
}
inline std::string* CvsCameraInfo::mutable_cameratype() {
  
  // @@protoc_insertion_point(field_mutable:AR51.CvsCameraInfo.CameraType)
  return cameratype_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CvsCameraInfo::release_cameratype() {
  // @@protoc_insertion_point(field_release:AR51.CvsCameraInfo.CameraType)
  
  return cameratype_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CvsCameraInfo::set_allocated_cameratype(std::string* cameratype) {
  if (cameratype != nullptr) {
    
  } else {
    
  }
  cameratype_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cameratype);
  // @@protoc_insertion_point(field_set_allocated:AR51.CvsCameraInfo.CameraType)
}

// -------------------------------------------------------------------

// GetAvailableCamerasResponse

// repeated .AR51.CvsCameraInfo CameraInfos = 1;
inline int GetAvailableCamerasResponse::camerainfos_size() const {
  return camerainfos_.size();
}
inline void GetAvailableCamerasResponse::clear_camerainfos() {
  camerainfos_.Clear();
}
inline ::AR51::CvsCameraInfo* GetAvailableCamerasResponse::mutable_camerainfos(int index) {
  // @@protoc_insertion_point(field_mutable:AR51.GetAvailableCamerasResponse.CameraInfos)
  return camerainfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::CvsCameraInfo >*
GetAvailableCamerasResponse::mutable_camerainfos() {
  // @@protoc_insertion_point(field_mutable_list:AR51.GetAvailableCamerasResponse.CameraInfos)
  return &camerainfos_;
}
inline const ::AR51::CvsCameraInfo& GetAvailableCamerasResponse::camerainfos(int index) const {
  // @@protoc_insertion_point(field_get:AR51.GetAvailableCamerasResponse.CameraInfos)
  return camerainfos_.Get(index);
}
inline ::AR51::CvsCameraInfo* GetAvailableCamerasResponse::add_camerainfos() {
  // @@protoc_insertion_point(field_add:AR51.GetAvailableCamerasResponse.CameraInfos)
  return camerainfos_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::CvsCameraInfo >&
GetAvailableCamerasResponse::camerainfos() const {
  // @@protoc_insertion_point(field_list:AR51.GetAvailableCamerasResponse.CameraInfos)
  return camerainfos_;
}

// -------------------------------------------------------------------

// CvsCameraFeedRequest

// string CameraId = 1;
inline void CvsCameraFeedRequest::clear_cameraid() {
  cameraid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CvsCameraFeedRequest::cameraid() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraFeedRequest.CameraId)
  return cameraid_.GetNoArena();
}
inline void CvsCameraFeedRequest::set_cameraid(const std::string& value) {
  
  cameraid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.CvsCameraFeedRequest.CameraId)
}
inline void CvsCameraFeedRequest::set_cameraid(std::string&& value) {
  
  cameraid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.CvsCameraFeedRequest.CameraId)
}
inline void CvsCameraFeedRequest::set_cameraid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cameraid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.CvsCameraFeedRequest.CameraId)
}
inline void CvsCameraFeedRequest::set_cameraid(const char* value, size_t size) {
  
  cameraid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.CvsCameraFeedRequest.CameraId)
}
inline std::string* CvsCameraFeedRequest::mutable_cameraid() {
  
  // @@protoc_insertion_point(field_mutable:AR51.CvsCameraFeedRequest.CameraId)
  return cameraid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CvsCameraFeedRequest::release_cameraid() {
  // @@protoc_insertion_point(field_release:AR51.CvsCameraFeedRequest.CameraId)
  
  return cameraid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CvsCameraFeedRequest::set_allocated_cameraid(std::string* cameraid) {
  if (cameraid != nullptr) {
    
  } else {
    
  }
  cameraid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cameraid);
  // @@protoc_insertion_point(field_set_allocated:AR51.CvsCameraFeedRequest.CameraId)
}

// int32 Width = 2;
inline void CvsCameraFeedRequest::clear_width() {
  width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CvsCameraFeedRequest::width() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraFeedRequest.Width)
  return width_;
}
inline void CvsCameraFeedRequest::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:AR51.CvsCameraFeedRequest.Width)
}

// int32 Height = 3;
inline void CvsCameraFeedRequest::clear_height() {
  height_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CvsCameraFeedRequest::height() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraFeedRequest.Height)
  return height_;
}
inline void CvsCameraFeedRequest::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:AR51.CvsCameraFeedRequest.Height)
}

// int32 FrameRate = 4;
inline void CvsCameraFeedRequest::clear_framerate() {
  framerate_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CvsCameraFeedRequest::framerate() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraFeedRequest.FrameRate)
  return framerate_;
}
inline void CvsCameraFeedRequest::set_framerate(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  framerate_ = value;
  // @@protoc_insertion_point(field_set:AR51.CvsCameraFeedRequest.FrameRate)
}

// int32 JpgQuality = 5;
inline void CvsCameraFeedRequest::clear_jpgquality() {
  jpgquality_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CvsCameraFeedRequest::jpgquality() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraFeedRequest.JpgQuality)
  return jpgquality_;
}
inline void CvsCameraFeedRequest::set_jpgquality(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  jpgquality_ = value;
  // @@protoc_insertion_point(field_set:AR51.CvsCameraFeedRequest.JpgQuality)
}

// -------------------------------------------------------------------

// CvsCameraGetRecordingReadyRequest

// string CameraId = 1;
inline void CvsCameraGetRecordingReadyRequest::clear_cameraid() {
  cameraid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CvsCameraGetRecordingReadyRequest::cameraid() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraGetRecordingReadyRequest.CameraId)
  return cameraid_.GetNoArena();
}
inline void CvsCameraGetRecordingReadyRequest::set_cameraid(const std::string& value) {
  
  cameraid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.CvsCameraGetRecordingReadyRequest.CameraId)
}
inline void CvsCameraGetRecordingReadyRequest::set_cameraid(std::string&& value) {
  
  cameraid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.CvsCameraGetRecordingReadyRequest.CameraId)
}
inline void CvsCameraGetRecordingReadyRequest::set_cameraid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cameraid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.CvsCameraGetRecordingReadyRequest.CameraId)
}
inline void CvsCameraGetRecordingReadyRequest::set_cameraid(const char* value, size_t size) {
  
  cameraid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.CvsCameraGetRecordingReadyRequest.CameraId)
}
inline std::string* CvsCameraGetRecordingReadyRequest::mutable_cameraid() {
  
  // @@protoc_insertion_point(field_mutable:AR51.CvsCameraGetRecordingReadyRequest.CameraId)
  return cameraid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CvsCameraGetRecordingReadyRequest::release_cameraid() {
  // @@protoc_insertion_point(field_release:AR51.CvsCameraGetRecordingReadyRequest.CameraId)
  
  return cameraid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CvsCameraGetRecordingReadyRequest::set_allocated_cameraid(std::string* cameraid) {
  if (cameraid != nullptr) {
    
  } else {
    
  }
  cameraid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cameraid);
  // @@protoc_insertion_point(field_set_allocated:AR51.CvsCameraGetRecordingReadyRequest.CameraId)
}

// string FileName = 2;
inline void CvsCameraGetRecordingReadyRequest::clear_filename() {
  filename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CvsCameraGetRecordingReadyRequest::filename() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraGetRecordingReadyRequest.FileName)
  return filename_.GetNoArena();
}
inline void CvsCameraGetRecordingReadyRequest::set_filename(const std::string& value) {
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.CvsCameraGetRecordingReadyRequest.FileName)
}
inline void CvsCameraGetRecordingReadyRequest::set_filename(std::string&& value) {
  
  filename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.CvsCameraGetRecordingReadyRequest.FileName)
}
inline void CvsCameraGetRecordingReadyRequest::set_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.CvsCameraGetRecordingReadyRequest.FileName)
}
inline void CvsCameraGetRecordingReadyRequest::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.CvsCameraGetRecordingReadyRequest.FileName)
}
inline std::string* CvsCameraGetRecordingReadyRequest::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:AR51.CvsCameraGetRecordingReadyRequest.FileName)
  return filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CvsCameraGetRecordingReadyRequest::release_filename() {
  // @@protoc_insertion_point(field_release:AR51.CvsCameraGetRecordingReadyRequest.FileName)
  
  return filename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CvsCameraGetRecordingReadyRequest::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:AR51.CvsCameraGetRecordingReadyRequest.FileName)
}

// -------------------------------------------------------------------

// CvsCameraIdRequest

// string CameraId = 1;
inline void CvsCameraIdRequest::clear_cameraid() {
  cameraid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CvsCameraIdRequest::cameraid() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraIdRequest.CameraId)
  return cameraid_.GetNoArena();
}
inline void CvsCameraIdRequest::set_cameraid(const std::string& value) {
  
  cameraid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.CvsCameraIdRequest.CameraId)
}
inline void CvsCameraIdRequest::set_cameraid(std::string&& value) {
  
  cameraid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.CvsCameraIdRequest.CameraId)
}
inline void CvsCameraIdRequest::set_cameraid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cameraid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.CvsCameraIdRequest.CameraId)
}
inline void CvsCameraIdRequest::set_cameraid(const char* value, size_t size) {
  
  cameraid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.CvsCameraIdRequest.CameraId)
}
inline std::string* CvsCameraIdRequest::mutable_cameraid() {
  
  // @@protoc_insertion_point(field_mutable:AR51.CvsCameraIdRequest.CameraId)
  return cameraid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CvsCameraIdRequest::release_cameraid() {
  // @@protoc_insertion_point(field_release:AR51.CvsCameraIdRequest.CameraId)
  
  return cameraid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CvsCameraIdRequest::set_allocated_cameraid(std::string* cameraid) {
  if (cameraid != nullptr) {
    
  } else {
    
  }
  cameraid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cameraid);
  // @@protoc_insertion_point(field_set_allocated:AR51.CvsCameraIdRequest.CameraId)
}

// -------------------------------------------------------------------

// CvsCameraFeedResponse

// bytes Jpg = 1;
inline void CvsCameraFeedResponse::clear_jpg() {
  jpg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CvsCameraFeedResponse::jpg() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraFeedResponse.Jpg)
  return jpg_.GetNoArena();
}
inline void CvsCameraFeedResponse::set_jpg(const std::string& value) {
  
  jpg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.CvsCameraFeedResponse.Jpg)
}
inline void CvsCameraFeedResponse::set_jpg(std::string&& value) {
  
  jpg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.CvsCameraFeedResponse.Jpg)
}
inline void CvsCameraFeedResponse::set_jpg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  jpg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.CvsCameraFeedResponse.Jpg)
}
inline void CvsCameraFeedResponse::set_jpg(const void* value, size_t size) {
  
  jpg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.CvsCameraFeedResponse.Jpg)
}
inline std::string* CvsCameraFeedResponse::mutable_jpg() {
  
  // @@protoc_insertion_point(field_mutable:AR51.CvsCameraFeedResponse.Jpg)
  return jpg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CvsCameraFeedResponse::release_jpg() {
  // @@protoc_insertion_point(field_release:AR51.CvsCameraFeedResponse.Jpg)
  
  return jpg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CvsCameraFeedResponse::set_allocated_jpg(std::string* jpg) {
  if (jpg != nullptr) {
    
  } else {
    
  }
  jpg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), jpg);
  // @@protoc_insertion_point(field_set_allocated:AR51.CvsCameraFeedResponse.Jpg)
}

// float ActualFPS = 2;
inline void CvsCameraFeedResponse::clear_actualfps() {
  actualfps_ = 0;
}
inline float CvsCameraFeedResponse::actualfps() const {
  // @@protoc_insertion_point(field_get:AR51.CvsCameraFeedResponse.ActualFPS)
  return actualfps_;
}
inline void CvsCameraFeedResponse::set_actualfps(float value) {
  
  actualfps_ = value;
  // @@protoc_insertion_point(field_set:AR51.CvsCameraFeedResponse.ActualFPS)
}

// -------------------------------------------------------------------

// MarkerInfo

// string Type = 1;
inline void MarkerInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MarkerInfo::type() const {
  // @@protoc_insertion_point(field_get:AR51.MarkerInfo.Type)
  return type_.GetNoArena();
}
inline void MarkerInfo::set_type(const std::string& value) {
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.MarkerInfo.Type)
}
inline void MarkerInfo::set_type(std::string&& value) {
  
  type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.MarkerInfo.Type)
}
inline void MarkerInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.MarkerInfo.Type)
}
inline void MarkerInfo::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.MarkerInfo.Type)
}
inline std::string* MarkerInfo::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:AR51.MarkerInfo.Type)
  return type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MarkerInfo::release_type() {
  // @@protoc_insertion_point(field_release:AR51.MarkerInfo.Type)
  
  return type_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MarkerInfo::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:AR51.MarkerInfo.Type)
}

// .AR51.Vector3 Position = 2;
inline bool MarkerInfo::has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline const ::AR51::Vector3& MarkerInfo::position() const {
  const ::AR51::Vector3* p = position_;
  // @@protoc_insertion_point(field_get:AR51.MarkerInfo.Position)
  return p != nullptr ? *p : *reinterpret_cast<const ::AR51::Vector3*>(
      &::AR51::_Vector3_default_instance_);
}
inline ::AR51::Vector3* MarkerInfo::release_position() {
  // @@protoc_insertion_point(field_release:AR51.MarkerInfo.Position)
  
  ::AR51::Vector3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::AR51::Vector3* MarkerInfo::mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::AR51::Vector3>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AR51.MarkerInfo.Position)
  return position_;
}
inline void MarkerInfo::set_allocated_position(::AR51::Vector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:AR51.MarkerInfo.Position)
}

// -------------------------------------------------------------------

// TrackedObjectInfo

// string Name = 1;
inline void TrackedObjectInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TrackedObjectInfo::name() const {
  // @@protoc_insertion_point(field_get:AR51.TrackedObjectInfo.Name)
  return name_.GetNoArena();
}
inline void TrackedObjectInfo::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.TrackedObjectInfo.Name)
}
inline void TrackedObjectInfo::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.TrackedObjectInfo.Name)
}
inline void TrackedObjectInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.TrackedObjectInfo.Name)
}
inline void TrackedObjectInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.TrackedObjectInfo.Name)
}
inline std::string* TrackedObjectInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:AR51.TrackedObjectInfo.Name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TrackedObjectInfo::release_name() {
  // @@protoc_insertion_point(field_release:AR51.TrackedObjectInfo.Name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TrackedObjectInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:AR51.TrackedObjectInfo.Name)
}

// repeated .AR51.MarkerInfo Markers = 2;
inline int TrackedObjectInfo::markers_size() const {
  return markers_.size();
}
inline void TrackedObjectInfo::clear_markers() {
  markers_.Clear();
}
inline ::AR51::MarkerInfo* TrackedObjectInfo::mutable_markers(int index) {
  // @@protoc_insertion_point(field_mutable:AR51.TrackedObjectInfo.Markers)
  return markers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::MarkerInfo >*
TrackedObjectInfo::mutable_markers() {
  // @@protoc_insertion_point(field_mutable_list:AR51.TrackedObjectInfo.Markers)
  return &markers_;
}
inline const ::AR51::MarkerInfo& TrackedObjectInfo::markers(int index) const {
  // @@protoc_insertion_point(field_get:AR51.TrackedObjectInfo.Markers)
  return markers_.Get(index);
}
inline ::AR51::MarkerInfo* TrackedObjectInfo::add_markers() {
  // @@protoc_insertion_point(field_add:AR51.TrackedObjectInfo.Markers)
  return markers_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::MarkerInfo >&
TrackedObjectInfo::markers() const {
  // @@protoc_insertion_point(field_list:AR51.TrackedObjectInfo.Markers)
  return markers_;
}

// -------------------------------------------------------------------

// TrackedMarker

// string Id = 1;
inline void TrackedMarker::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TrackedMarker::id() const {
  // @@protoc_insertion_point(field_get:AR51.TrackedMarker.Id)
  return id_.GetNoArena();
}
inline void TrackedMarker::set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.TrackedMarker.Id)
}
inline void TrackedMarker::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.TrackedMarker.Id)
}
inline void TrackedMarker::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.TrackedMarker.Id)
}
inline void TrackedMarker::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.TrackedMarker.Id)
}
inline std::string* TrackedMarker::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:AR51.TrackedMarker.Id)
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TrackedMarker::release_id() {
  // @@protoc_insertion_point(field_release:AR51.TrackedMarker.Id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TrackedMarker::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:AR51.TrackedMarker.Id)
}

// string Type = 2;
inline void TrackedMarker::clear_type() {
  type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TrackedMarker::type() const {
  // @@protoc_insertion_point(field_get:AR51.TrackedMarker.Type)
  return type_.GetNoArena();
}
inline void TrackedMarker::set_type(const std::string& value) {
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.TrackedMarker.Type)
}
inline void TrackedMarker::set_type(std::string&& value) {
  
  type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.TrackedMarker.Type)
}
inline void TrackedMarker::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.TrackedMarker.Type)
}
inline void TrackedMarker::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.TrackedMarker.Type)
}
inline std::string* TrackedMarker::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:AR51.TrackedMarker.Type)
  return type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TrackedMarker::release_type() {
  // @@protoc_insertion_point(field_release:AR51.TrackedMarker.Type)
  
  return type_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TrackedMarker::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:AR51.TrackedMarker.Type)
}

// .AR51.Vector3 Position = 3;
inline bool TrackedMarker::has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline const ::AR51::Vector3& TrackedMarker::position() const {
  const ::AR51::Vector3* p = position_;
  // @@protoc_insertion_point(field_get:AR51.TrackedMarker.Position)
  return p != nullptr ? *p : *reinterpret_cast<const ::AR51::Vector3*>(
      &::AR51::_Vector3_default_instance_);
}
inline ::AR51::Vector3* TrackedMarker::release_position() {
  // @@protoc_insertion_point(field_release:AR51.TrackedMarker.Position)
  
  ::AR51::Vector3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::AR51::Vector3* TrackedMarker::mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::AR51::Vector3>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AR51.TrackedMarker.Position)
  return position_;
}
inline void TrackedMarker::set_allocated_position(::AR51::Vector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:AR51.TrackedMarker.Position)
}

// float Radius = 4;
inline void TrackedMarker::clear_radius() {
  radius_ = 0;
}
inline float TrackedMarker::radius() const {
  // @@protoc_insertion_point(field_get:AR51.TrackedMarker.Radius)
  return radius_;
}
inline void TrackedMarker::set_radius(float value) {
  
  radius_ = value;
  // @@protoc_insertion_point(field_set:AR51.TrackedMarker.Radius)
}

// repeated .AR51.Vector3 Rays = 5;
inline int TrackedMarker::rays_size() const {
  return rays_.size();
}
inline ::AR51::Vector3* TrackedMarker::mutable_rays(int index) {
  // @@protoc_insertion_point(field_mutable:AR51.TrackedMarker.Rays)
  return rays_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::Vector3 >*
TrackedMarker::mutable_rays() {
  // @@protoc_insertion_point(field_mutable_list:AR51.TrackedMarker.Rays)
  return &rays_;
}
inline const ::AR51::Vector3& TrackedMarker::rays(int index) const {
  // @@protoc_insertion_point(field_get:AR51.TrackedMarker.Rays)
  return rays_.Get(index);
}
inline ::AR51::Vector3* TrackedMarker::add_rays() {
  // @@protoc_insertion_point(field_add:AR51.TrackedMarker.Rays)
  return rays_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::Vector3 >&
TrackedMarker::rays() const {
  // @@protoc_insertion_point(field_list:AR51.TrackedMarker.Rays)
  return rays_;
}

// -------------------------------------------------------------------

// TrackedObject

// string Id = 1;
inline void TrackedObject::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TrackedObject::id() const {
  // @@protoc_insertion_point(field_get:AR51.TrackedObject.Id)
  return id_.GetNoArena();
}
inline void TrackedObject::set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.TrackedObject.Id)
}
inline void TrackedObject::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.TrackedObject.Id)
}
inline void TrackedObject::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.TrackedObject.Id)
}
inline void TrackedObject::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.TrackedObject.Id)
}
inline std::string* TrackedObject::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:AR51.TrackedObject.Id)
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TrackedObject::release_id() {
  // @@protoc_insertion_point(field_release:AR51.TrackedObject.Id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TrackedObject::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:AR51.TrackedObject.Id)
}

// string Name = 2;
inline void TrackedObject::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TrackedObject::name() const {
  // @@protoc_insertion_point(field_get:AR51.TrackedObject.Name)
  return name_.GetNoArena();
}
inline void TrackedObject::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AR51.TrackedObject.Name)
}
inline void TrackedObject::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AR51.TrackedObject.Name)
}
inline void TrackedObject::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AR51.TrackedObject.Name)
}
inline void TrackedObject::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AR51.TrackedObject.Name)
}
inline std::string* TrackedObject::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:AR51.TrackedObject.Name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TrackedObject::release_name() {
  // @@protoc_insertion_point(field_release:AR51.TrackedObject.Name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TrackedObject::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:AR51.TrackedObject.Name)
}

// .AR51.Vector3 Position = 3;
inline bool TrackedObject::has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline const ::AR51::Vector3& TrackedObject::position() const {
  const ::AR51::Vector3* p = position_;
  // @@protoc_insertion_point(field_get:AR51.TrackedObject.Position)
  return p != nullptr ? *p : *reinterpret_cast<const ::AR51::Vector3*>(
      &::AR51::_Vector3_default_instance_);
}
inline ::AR51::Vector3* TrackedObject::release_position() {
  // @@protoc_insertion_point(field_release:AR51.TrackedObject.Position)
  
  ::AR51::Vector3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::AR51::Vector3* TrackedObject::mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::AR51::Vector3>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AR51.TrackedObject.Position)
  return position_;
}
inline void TrackedObject::set_allocated_position(::AR51::Vector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:AR51.TrackedObject.Position)
}

// .AR51.Quaternion Rotation = 4;
inline bool TrackedObject::has_rotation() const {
  return this != internal_default_instance() && rotation_ != nullptr;
}
inline const ::AR51::Quaternion& TrackedObject::rotation() const {
  const ::AR51::Quaternion* p = rotation_;
  // @@protoc_insertion_point(field_get:AR51.TrackedObject.Rotation)
  return p != nullptr ? *p : *reinterpret_cast<const ::AR51::Quaternion*>(
      &::AR51::_Quaternion_default_instance_);
}
inline ::AR51::Quaternion* TrackedObject::release_rotation() {
  // @@protoc_insertion_point(field_release:AR51.TrackedObject.Rotation)
  
  ::AR51::Quaternion* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::AR51::Quaternion* TrackedObject::mutable_rotation() {
  
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::AR51::Quaternion>(GetArenaNoVirtual());
    rotation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AR51.TrackedObject.Rotation)
  return rotation_;
}
inline void TrackedObject::set_allocated_rotation(::AR51::Quaternion* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:AR51.TrackedObject.Rotation)
}

// repeated string MarkerIds = 5;
inline int TrackedObject::markerids_size() const {
  return markerids_.size();
}
inline void TrackedObject::clear_markerids() {
  markerids_.Clear();
}
inline const std::string& TrackedObject::markerids(int index) const {
  // @@protoc_insertion_point(field_get:AR51.TrackedObject.MarkerIds)
  return markerids_.Get(index);
}
inline std::string* TrackedObject::mutable_markerids(int index) {
  // @@protoc_insertion_point(field_mutable:AR51.TrackedObject.MarkerIds)
  return markerids_.Mutable(index);
}
inline void TrackedObject::set_markerids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:AR51.TrackedObject.MarkerIds)
  markerids_.Mutable(index)->assign(value);
}
inline void TrackedObject::set_markerids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:AR51.TrackedObject.MarkerIds)
  markerids_.Mutable(index)->assign(std::move(value));
}
inline void TrackedObject::set_markerids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  markerids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:AR51.TrackedObject.MarkerIds)
}
inline void TrackedObject::set_markerids(int index, const char* value, size_t size) {
  markerids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AR51.TrackedObject.MarkerIds)
}
inline std::string* TrackedObject::add_markerids() {
  // @@protoc_insertion_point(field_add_mutable:AR51.TrackedObject.MarkerIds)
  return markerids_.Add();
}
inline void TrackedObject::add_markerids(const std::string& value) {
  markerids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:AR51.TrackedObject.MarkerIds)
}
inline void TrackedObject::add_markerids(std::string&& value) {
  markerids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:AR51.TrackedObject.MarkerIds)
}
inline void TrackedObject::add_markerids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  markerids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:AR51.TrackedObject.MarkerIds)
}
inline void TrackedObject::add_markerids(const char* value, size_t size) {
  markerids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:AR51.TrackedObject.MarkerIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TrackedObject::markerids() const {
  // @@protoc_insertion_point(field_list:AR51.TrackedObject.MarkerIds)
  return markerids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TrackedObject::mutable_markerids() {
  // @@protoc_insertion_point(field_mutable_list:AR51.TrackedObject.MarkerIds)
  return &markerids_;
}

// -------------------------------------------------------------------

// ObjectDetectionReply

// repeated .AR51.TrackedMarker Markers = 1;
inline int ObjectDetectionReply::markers_size() const {
  return markers_.size();
}
inline void ObjectDetectionReply::clear_markers() {
  markers_.Clear();
}
inline ::AR51::TrackedMarker* ObjectDetectionReply::mutable_markers(int index) {
  // @@protoc_insertion_point(field_mutable:AR51.ObjectDetectionReply.Markers)
  return markers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::TrackedMarker >*
ObjectDetectionReply::mutable_markers() {
  // @@protoc_insertion_point(field_mutable_list:AR51.ObjectDetectionReply.Markers)
  return &markers_;
}
inline const ::AR51::TrackedMarker& ObjectDetectionReply::markers(int index) const {
  // @@protoc_insertion_point(field_get:AR51.ObjectDetectionReply.Markers)
  return markers_.Get(index);
}
inline ::AR51::TrackedMarker* ObjectDetectionReply::add_markers() {
  // @@protoc_insertion_point(field_add:AR51.ObjectDetectionReply.Markers)
  return markers_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::TrackedMarker >&
ObjectDetectionReply::markers() const {
  // @@protoc_insertion_point(field_list:AR51.ObjectDetectionReply.Markers)
  return markers_;
}

// repeated .AR51.TrackedObject Items = 2;
inline int ObjectDetectionReply::items_size() const {
  return items_.size();
}
inline void ObjectDetectionReply::clear_items() {
  items_.Clear();
}
inline ::AR51::TrackedObject* ObjectDetectionReply::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:AR51.ObjectDetectionReply.Items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::TrackedObject >*
ObjectDetectionReply::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:AR51.ObjectDetectionReply.Items)
  return &items_;
}
inline const ::AR51::TrackedObject& ObjectDetectionReply::items(int index) const {
  // @@protoc_insertion_point(field_get:AR51.ObjectDetectionReply.Items)
  return items_.Get(index);
}
inline ::AR51::TrackedObject* ObjectDetectionReply::add_items() {
  // @@protoc_insertion_point(field_add:AR51.ObjectDetectionReply.Items)
  return items_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AR51::TrackedObject >&
ObjectDetectionReply::items() const {
  // @@protoc_insertion_point(field_list:AR51.ObjectDetectionReply.Items)
  return items_;
}

// repeated string Cameras = 3;
inline int ObjectDetectionReply::cameras_size() const {
  return cameras_.size();
}
inline void ObjectDetectionReply::clear_cameras() {
  cameras_.Clear();
}
inline const std::string& ObjectDetectionReply::cameras(int index) const {
  // @@protoc_insertion_point(field_get:AR51.ObjectDetectionReply.Cameras)
  return cameras_.Get(index);
}
inline std::string* ObjectDetectionReply::mutable_cameras(int index) {
  // @@protoc_insertion_point(field_mutable:AR51.ObjectDetectionReply.Cameras)
  return cameras_.Mutable(index);
}
inline void ObjectDetectionReply::set_cameras(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:AR51.ObjectDetectionReply.Cameras)
  cameras_.Mutable(index)->assign(value);
}
inline void ObjectDetectionReply::set_cameras(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:AR51.ObjectDetectionReply.Cameras)
  cameras_.Mutable(index)->assign(std::move(value));
}
inline void ObjectDetectionReply::set_cameras(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  cameras_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:AR51.ObjectDetectionReply.Cameras)
}
inline void ObjectDetectionReply::set_cameras(int index, const char* value, size_t size) {
  cameras_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AR51.ObjectDetectionReply.Cameras)
}
inline std::string* ObjectDetectionReply::add_cameras() {
  // @@protoc_insertion_point(field_add_mutable:AR51.ObjectDetectionReply.Cameras)
  return cameras_.Add();
}
inline void ObjectDetectionReply::add_cameras(const std::string& value) {
  cameras_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:AR51.ObjectDetectionReply.Cameras)
}
inline void ObjectDetectionReply::add_cameras(std::string&& value) {
  cameras_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:AR51.ObjectDetectionReply.Cameras)
}
inline void ObjectDetectionReply::add_cameras(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  cameras_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:AR51.ObjectDetectionReply.Cameras)
}
inline void ObjectDetectionReply::add_cameras(const char* value, size_t size) {
  cameras_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:AR51.ObjectDetectionReply.Cameras)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ObjectDetectionReply::cameras() const {
  // @@protoc_insertion_point(field_list:AR51.ObjectDetectionReply.Cameras)
  return cameras_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ObjectDetectionReply::mutable_cameras() {
  // @@protoc_insertion_point(field_mutable_list:AR51.ObjectDetectionReply.Cameras)
  return &cameras_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace AR51

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::AR51::ControllerButton> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AR51::ControllerButton>() {
  return ::AR51::ControllerButton_descriptor();
}
template <> struct is_proto_enum< ::AR51::ControllerButtonStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AR51::ControllerButtonStatus>() {
  return ::AR51::ControllerButtonStatus_descriptor();
}
template <> struct is_proto_enum< ::AR51::CalibrationModes> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AR51::CalibrationModes>() {
  return ::AR51::CalibrationModes_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_cvs_2eproto
