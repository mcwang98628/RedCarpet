// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: dgs.proto

#include "dgs.pb.h"
#include "dgs.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace AR51 {

static const char* GameService_method_names[] = {
  "/AR51.GameService/EnterLobby",
  "/AR51.GameService/Start",
  "/AR51.GameService/Stop",
  "/AR51.GameService/ListenToEvents",
  "/AR51.GameService/GetState",
  "/AR51.GameService/Setup",
  "/AR51.GameService/CancelSetup",
  "/AR51.GameService/SetPlaceable",
  "/AR51.GameService/SetPlayerName",
  "/AR51.GameService/GetPlayerName",
};

std::unique_ptr< GameService::Stub> GameService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< GameService::Stub> stub(new GameService::Stub(channel));
  return stub;
}

GameService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_EnterLobby_(GameService_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Start_(GameService_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Stop_(GameService_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ListenToEvents_(GameService_method_names[3], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  , rpcmethod_GetState_(GameService_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Setup_(GameService_method_names[5], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_CancelSetup_(GameService_method_names[6], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetPlaceable_(GameService_method_names[7], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetPlayerName_(GameService_method_names[8], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetPlayerName_(GameService_method_names[9], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status GameService::Stub::EnterLobby(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_EnterLobby_, context, request, response);
}

void GameService::Stub::experimental_async::EnterLobby(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_EnterLobby_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::EnterLobby(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_EnterLobby_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::EnterLobby(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_EnterLobby_, context, request, response, reactor);
}

void GameService::Stub::experimental_async::EnterLobby(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_EnterLobby_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* GameService::Stub::AsyncEnterLobbyRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_EnterLobby_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* GameService::Stub::PrepareAsyncEnterLobbyRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_EnterLobby_, context, request, false);
}

::grpc::Status GameService::Stub::Start(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Start_, context, request, response);
}

void GameService::Stub::experimental_async::Start(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Start_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::Start(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Start_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::Start(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Start_, context, request, response, reactor);
}

void GameService::Stub::experimental_async::Start(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Start_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* GameService::Stub::AsyncStartRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Start_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* GameService::Stub::PrepareAsyncStartRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Start_, context, request, false);
}

::grpc::Status GameService::Stub::Stop(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Stop_, context, request, response);
}

void GameService::Stub::experimental_async::Stop(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Stop_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Stop_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::Stop(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Stop_, context, request, response, reactor);
}

void GameService::Stub::experimental_async::Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Stop_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* GameService::Stub::AsyncStopRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Stop_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* GameService::Stub::PrepareAsyncStopRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Stop_, context, request, false);
}

::grpc::ClientReader< ::AR51::GameStateReply>* GameService::Stub::ListenToEventsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::GameStateReply>::Create(channel_.get(), rpcmethod_ListenToEvents_, context, request);
}

void GameService::Stub::experimental_async::ListenToEvents(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::GameStateReply>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::GameStateReply>::Create(stub_->channel_.get(), stub_->rpcmethod_ListenToEvents_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::GameStateReply>* GameService::Stub::AsyncListenToEventsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::GameStateReply>::Create(channel_.get(), cq, rpcmethod_ListenToEvents_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::GameStateReply>* GameService::Stub::PrepareAsyncListenToEventsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::GameStateReply>::Create(channel_.get(), cq, rpcmethod_ListenToEvents_, context, request, false, nullptr);
}

::grpc::Status GameService::Stub::GetState(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::GameStateReply* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetState_, context, request, response);
}

void GameService::Stub::experimental_async::GetState(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GameStateReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetState_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::GetState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GameStateReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetState_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::GetState(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GameStateReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetState_, context, request, response, reactor);
}

void GameService::Stub::experimental_async::GetState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GameStateReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetState_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::GameStateReply>* GameService::Stub::AsyncGetStateRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::GameStateReply>::Create(channel_.get(), cq, rpcmethod_GetState_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::GameStateReply>* GameService::Stub::PrepareAsyncGetStateRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::GameStateReply>::Create(channel_.get(), cq, rpcmethod_GetState_, context, request, false);
}

::grpc::Status GameService::Stub::Setup(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::SetupReply* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Setup_, context, request, response);
}

void GameService::Stub::experimental_async::Setup(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::SetupReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Setup_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::Setup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SetupReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Setup_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::Setup(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::SetupReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Setup_, context, request, response, reactor);
}

void GameService::Stub::experimental_async::Setup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SetupReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Setup_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::SetupReply>* GameService::Stub::AsyncSetupRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::SetupReply>::Create(channel_.get(), cq, rpcmethod_Setup_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::SetupReply>* GameService::Stub::PrepareAsyncSetupRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::SetupReply>::Create(channel_.get(), cq, rpcmethod_Setup_, context, request, false);
}

::grpc::Status GameService::Stub::CancelSetup(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_CancelSetup_, context, request, response);
}

void GameService::Stub::experimental_async::CancelSetup(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_CancelSetup_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::CancelSetup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_CancelSetup_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::CancelSetup(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_CancelSetup_, context, request, response, reactor);
}

void GameService::Stub::experimental_async::CancelSetup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_CancelSetup_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* GameService::Stub::AsyncCancelSetupRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_CancelSetup_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* GameService::Stub::PrepareAsyncCancelSetupRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_CancelSetup_, context, request, false);
}

::grpc::Status GameService::Stub::SetPlaceable(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest& request, ::AR51::SetPlaceableReply* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetPlaceable_, context, request, response);
}

void GameService::Stub::experimental_async::SetPlaceable(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest* request, ::AR51::SetPlaceableReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetPlaceable_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::SetPlaceable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SetPlaceableReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetPlaceable_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::SetPlaceable(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest* request, ::AR51::SetPlaceableReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetPlaceable_, context, request, response, reactor);
}

void GameService::Stub::experimental_async::SetPlaceable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::SetPlaceableReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetPlaceable_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::SetPlaceableReply>* GameService::Stub::AsyncSetPlaceableRaw(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::SetPlaceableReply>::Create(channel_.get(), cq, rpcmethod_SetPlaceable_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::SetPlaceableReply>* GameService::Stub::PrepareAsyncSetPlaceableRaw(::grpc::ClientContext* context, const ::AR51::SetPlaceableRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::SetPlaceableReply>::Create(channel_.get(), cq, rpcmethod_SetPlaceable_, context, request, false);
}

::grpc::Status GameService::Stub::SetPlayerName(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetPlayerName_, context, request, response);
}

void GameService::Stub::experimental_async::SetPlayerName(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetPlayerName_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::SetPlayerName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetPlayerName_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::SetPlayerName(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetPlayerName_, context, request, response, reactor);
}

void GameService::Stub::experimental_async::SetPlayerName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetPlayerName_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* GameService::Stub::AsyncSetPlayerNameRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetPlayerName_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* GameService::Stub::PrepareAsyncSetPlayerNameRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetPlayerName_, context, request, false);
}

::grpc::Status GameService::Stub::GetPlayerName(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::StringMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetPlayerName_, context, request, response);
}

void GameService::Stub::experimental_async::GetPlayerName(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::StringMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetPlayerName_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::GetPlayerName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::StringMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetPlayerName_, context, request, response, std::move(f));
}

void GameService::Stub::experimental_async::GetPlayerName(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::StringMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetPlayerName_, context, request, response, reactor);
}

void GameService::Stub::experimental_async::GetPlayerName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::StringMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetPlayerName_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::StringMessage>* GameService::Stub::AsyncGetPlayerNameRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::StringMessage>::Create(channel_.get(), cq, rpcmethod_GetPlayerName_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::StringMessage>* GameService::Stub::PrepareAsyncGetPlayerNameRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::StringMessage>::Create(channel_.get(), cq, rpcmethod_GetPlayerName_, context, request, false);
}

GameService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      GameService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< GameService::Service, ::AR51::Empty, ::AR51::Empty>(
          std::mem_fn(&GameService::Service::EnterLobby), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      GameService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< GameService::Service, ::AR51::Empty, ::AR51::Empty>(
          std::mem_fn(&GameService::Service::Start), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      GameService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< GameService::Service, ::AR51::Empty, ::AR51::Empty>(
          std::mem_fn(&GameService::Service::Stop), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      GameService_method_names[3],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< GameService::Service, ::AR51::Empty, ::AR51::GameStateReply>(
          std::mem_fn(&GameService::Service::ListenToEvents), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      GameService_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< GameService::Service, ::AR51::Empty, ::AR51::GameStateReply>(
          std::mem_fn(&GameService::Service::GetState), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      GameService_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< GameService::Service, ::AR51::Empty, ::AR51::SetupReply>(
          std::mem_fn(&GameService::Service::Setup), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      GameService_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< GameService::Service, ::AR51::Empty, ::AR51::Empty>(
          std::mem_fn(&GameService::Service::CancelSetup), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      GameService_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< GameService::Service, ::AR51::SetPlaceableRequest, ::AR51::SetPlaceableReply>(
          std::mem_fn(&GameService::Service::SetPlaceable), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      GameService_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< GameService::Service, ::AR51::StringMessage, ::AR51::Empty>(
          std::mem_fn(&GameService::Service::SetPlayerName), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      GameService_method_names[9],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< GameService::Service, ::AR51::Empty, ::AR51::StringMessage>(
          std::mem_fn(&GameService::Service::GetPlayerName), this)));
}

GameService::Service::~Service() {
}

::grpc::Status GameService::Service::EnterLobby(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status GameService::Service::Start(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status GameService::Service::Stop(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status GameService::Service::ListenToEvents(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::GameStateReply>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status GameService::Service::GetState(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GameStateReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status GameService::Service::Setup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::SetupReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status GameService::Service::CancelSetup(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status GameService::Service::SetPlaceable(::grpc::ServerContext* context, const ::AR51::SetPlaceableRequest* request, ::AR51::SetPlaceableReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status GameService::Service::SetPlayerName(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status GameService::Service::GetPlayerName(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::StringMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* CameraService_method_names[] = {
  "/AR51.CameraService/StartStreaming",
  "/AR51.CameraService/StartRecorderStreaming",
  "/AR51.CameraService/GetIsStreaming",
  "/AR51.CameraService/GetHologramsEnabled",
  "/AR51.CameraService/SetHologramsEnabled",
  "/AR51.CameraService/GetPreviewWidth",
  "/AR51.CameraService/SetPreviewWidth",
  "/AR51.CameraService/GetPreviewHeight",
  "/AR51.CameraService/SetPreviewHeight",
  "/AR51.CameraService/GetExposureLock",
  "/AR51.CameraService/SetExposureLock",
  "/AR51.CameraService/GetExposureBiasMin",
  "/AR51.CameraService/GetExposureBiasMax",
  "/AR51.CameraService/GetExposureBias",
  "/AR51.CameraService/SetExposureBias",
  "/AR51.CameraService/GetAutoFocus",
  "/AR51.CameraService/SetAutoFocus",
  "/AR51.CameraService/GetIsRecording",
  "/AR51.CameraService/GetIsRecordingReady",
  "/AR51.CameraService/GetAutoExposureEnabled",
  "/AR51.CameraService/SetAutoExposureEnabled",
  "/AR51.CameraService/GetSensorExposureTime",
  "/AR51.CameraService/SetSensorExposureTime",
  "/AR51.CameraService/GetSensorSensitivity",
  "/AR51.CameraService/SetSensorSensitivity",
  "/AR51.CameraService/GetVideoRecordingSetting",
  "/AR51.CameraService/StartRecording",
  "/AR51.CameraService/StartMediaRecoder",
  "/AR51.CameraService/StopRecording",
  "/AR51.CameraService/DownloadVideo",
  "/AR51.CameraService/DeleteVideo",
  "/AR51.CameraService/DeleteAllVideos",
  "/AR51.CameraService/GetAllVideoFiles",
  "/AR51.CameraService/GetCameraCharacteristics",
  "/AR51.CameraService/GetRecorderField",
  "/AR51.CameraService/SetRecorderField",
};

std::unique_ptr< CameraService::Stub> CameraService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< CameraService::Stub> stub(new CameraService::Stub(channel));
  return stub;
}

CameraService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_StartStreaming_(CameraService_method_names[0], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  , rpcmethod_StartRecorderStreaming_(CameraService_method_names[1], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  , rpcmethod_GetIsStreaming_(CameraService_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetHologramsEnabled_(CameraService_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetHologramsEnabled_(CameraService_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetPreviewWidth_(CameraService_method_names[5], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetPreviewWidth_(CameraService_method_names[6], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetPreviewHeight_(CameraService_method_names[7], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetPreviewHeight_(CameraService_method_names[8], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetExposureLock_(CameraService_method_names[9], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetExposureLock_(CameraService_method_names[10], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetExposureBiasMin_(CameraService_method_names[11], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetExposureBiasMax_(CameraService_method_names[12], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetExposureBias_(CameraService_method_names[13], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetExposureBias_(CameraService_method_names[14], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetAutoFocus_(CameraService_method_names[15], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetAutoFocus_(CameraService_method_names[16], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetIsRecording_(CameraService_method_names[17], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetIsRecordingReady_(CameraService_method_names[18], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetAutoExposureEnabled_(CameraService_method_names[19], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetAutoExposureEnabled_(CameraService_method_names[20], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetSensorExposureTime_(CameraService_method_names[21], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetSensorExposureTime_(CameraService_method_names[22], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetSensorSensitivity_(CameraService_method_names[23], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetSensorSensitivity_(CameraService_method_names[24], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetVideoRecordingSetting_(CameraService_method_names[25], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_StartRecording_(CameraService_method_names[26], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_StartMediaRecoder_(CameraService_method_names[27], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_StopRecording_(CameraService_method_names[28], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_DownloadVideo_(CameraService_method_names[29], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  , rpcmethod_DeleteVideo_(CameraService_method_names[30], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_DeleteAllVideos_(CameraService_method_names[31], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetAllVideoFiles_(CameraService_method_names[32], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetCameraCharacteristics_(CameraService_method_names[33], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetRecorderField_(CameraService_method_names[34], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetRecorderField_(CameraService_method_names[35], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::ClientReader< ::AR51::CameraFeedResponse>* CameraService::Stub::StartStreamingRaw(::grpc::ClientContext* context, const ::AR51::CameraFeedRequest& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::CameraFeedResponse>::Create(channel_.get(), rpcmethod_StartStreaming_, context, request);
}

void CameraService::Stub::experimental_async::StartStreaming(::grpc::ClientContext* context, ::AR51::CameraFeedRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::CameraFeedResponse>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::CameraFeedResponse>::Create(stub_->channel_.get(), stub_->rpcmethod_StartStreaming_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::CameraFeedResponse>* CameraService::Stub::AsyncStartStreamingRaw(::grpc::ClientContext* context, const ::AR51::CameraFeedRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::CameraFeedResponse>::Create(channel_.get(), cq, rpcmethod_StartStreaming_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::CameraFeedResponse>* CameraService::Stub::PrepareAsyncStartStreamingRaw(::grpc::ClientContext* context, const ::AR51::CameraFeedRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::CameraFeedResponse>::Create(channel_.get(), cq, rpcmethod_StartStreaming_, context, request, false, nullptr);
}

::grpc::ClientReader< ::AR51::BytesMessage>* CameraService::Stub::StartRecorderStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::BytesMessage>::Create(channel_.get(), rpcmethod_StartRecorderStreaming_, context, request);
}

void CameraService::Stub::experimental_async::StartRecorderStreaming(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::BytesMessage>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::BytesMessage>::Create(stub_->channel_.get(), stub_->rpcmethod_StartRecorderStreaming_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::BytesMessage>* CameraService::Stub::AsyncStartRecorderStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::BytesMessage>::Create(channel_.get(), cq, rpcmethod_StartRecorderStreaming_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::BytesMessage>* CameraService::Stub::PrepareAsyncStartRecorderStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::BytesMessage>::Create(channel_.get(), cq, rpcmethod_StartRecorderStreaming_, context, request, false, nullptr);
}

::grpc::Status CameraService::Stub::GetIsStreaming(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetIsStreaming_, context, request, response);
}

void CameraService::Stub::experimental_async::GetIsStreaming(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetIsStreaming_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetIsStreaming(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetIsStreaming_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetIsStreaming(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetIsStreaming_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetIsStreaming(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetIsStreaming_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraService::Stub::AsyncGetIsStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetIsStreaming_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraService::Stub::PrepareAsyncGetIsStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetIsStreaming_, context, request, false);
}

::grpc::Status CameraService::Stub::GetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetHologramsEnabled_, context, request, response);
}

void CameraService::Stub::experimental_async::GetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetHologramsEnabled_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetHologramsEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetHologramsEnabled_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetHologramsEnabled_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetHologramsEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetHologramsEnabled_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraService::Stub::AsyncGetHologramsEnabledRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetHologramsEnabled_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraService::Stub::PrepareAsyncGetHologramsEnabledRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetHologramsEnabled_, context, request, false);
}

::grpc::Status CameraService::Stub::SetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetHologramsEnabled_, context, request, response);
}

void CameraService::Stub::experimental_async::SetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetHologramsEnabled_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetHologramsEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetHologramsEnabled_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetHologramsEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetHologramsEnabled_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::SetHologramsEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetHologramsEnabled_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::AsyncSetHologramsEnabledRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetHologramsEnabled_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::PrepareAsyncSetHologramsEnabledRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetHologramsEnabled_, context, request, false);
}

::grpc::Status CameraService::Stub::GetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Int32Message* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetPreviewWidth_, context, request, response);
}

void CameraService::Stub::experimental_async::GetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetPreviewWidth_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetPreviewWidth(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetPreviewWidth_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetPreviewWidth_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetPreviewWidth(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetPreviewWidth_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>* CameraService::Stub::AsyncGetPreviewWidthRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Int32Message>::Create(channel_.get(), cq, rpcmethod_GetPreviewWidth_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>* CameraService::Stub::PrepareAsyncGetPreviewWidthRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Int32Message>::Create(channel_.get(), cq, rpcmethod_GetPreviewWidth_, context, request, false);
}

::grpc::Status CameraService::Stub::SetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetPreviewWidth_, context, request, response);
}

void CameraService::Stub::experimental_async::SetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetPreviewWidth_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetPreviewWidth(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetPreviewWidth_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetPreviewWidth(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetPreviewWidth_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::SetPreviewWidth(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetPreviewWidth_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::AsyncSetPreviewWidthRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetPreviewWidth_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::PrepareAsyncSetPreviewWidthRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetPreviewWidth_, context, request, false);
}

::grpc::Status CameraService::Stub::GetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Int32Message* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetPreviewHeight_, context, request, response);
}

void CameraService::Stub::experimental_async::GetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetPreviewHeight_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetPreviewHeight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetPreviewHeight_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetPreviewHeight_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetPreviewHeight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetPreviewHeight_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>* CameraService::Stub::AsyncGetPreviewHeightRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Int32Message>::Create(channel_.get(), cq, rpcmethod_GetPreviewHeight_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>* CameraService::Stub::PrepareAsyncGetPreviewHeightRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Int32Message>::Create(channel_.get(), cq, rpcmethod_GetPreviewHeight_, context, request, false);
}

::grpc::Status CameraService::Stub::SetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetPreviewHeight_, context, request, response);
}

void CameraService::Stub::experimental_async::SetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetPreviewHeight_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetPreviewHeight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetPreviewHeight_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetPreviewHeight(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetPreviewHeight_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::SetPreviewHeight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetPreviewHeight_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::AsyncSetPreviewHeightRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetPreviewHeight_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::PrepareAsyncSetPreviewHeightRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetPreviewHeight_, context, request, false);
}

::grpc::Status CameraService::Stub::GetExposureLock(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetExposureLock_, context, request, response);
}

void CameraService::Stub::experimental_async::GetExposureLock(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetExposureLock_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetExposureLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetExposureLock_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetExposureLock(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetExposureLock_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetExposureLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetExposureLock_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraService::Stub::AsyncGetExposureLockRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetExposureLock_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraService::Stub::PrepareAsyncGetExposureLockRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetExposureLock_, context, request, false);
}

::grpc::Status CameraService::Stub::SetExposureLock(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetExposureLock_, context, request, response);
}

void CameraService::Stub::experimental_async::SetExposureLock(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetExposureLock_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetExposureLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetExposureLock_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetExposureLock(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetExposureLock_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::SetExposureLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetExposureLock_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::AsyncSetExposureLockRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetExposureLock_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::PrepareAsyncSetExposureLockRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetExposureLock_, context, request, false);
}

::grpc::Status CameraService::Stub::GetExposureBiasMin(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Float32Message* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetExposureBiasMin_, context, request, response);
}

void CameraService::Stub::experimental_async::GetExposureBiasMin(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetExposureBiasMin_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetExposureBiasMin(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetExposureBiasMin_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetExposureBiasMin(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetExposureBiasMin_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetExposureBiasMin(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetExposureBiasMin_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>* CameraService::Stub::AsyncGetExposureBiasMinRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float32Message>::Create(channel_.get(), cq, rpcmethod_GetExposureBiasMin_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>* CameraService::Stub::PrepareAsyncGetExposureBiasMinRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float32Message>::Create(channel_.get(), cq, rpcmethod_GetExposureBiasMin_, context, request, false);
}

::grpc::Status CameraService::Stub::GetExposureBiasMax(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Float32Message* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetExposureBiasMax_, context, request, response);
}

void CameraService::Stub::experimental_async::GetExposureBiasMax(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetExposureBiasMax_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetExposureBiasMax(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetExposureBiasMax_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetExposureBiasMax(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetExposureBiasMax_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetExposureBiasMax(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetExposureBiasMax_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>* CameraService::Stub::AsyncGetExposureBiasMaxRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float32Message>::Create(channel_.get(), cq, rpcmethod_GetExposureBiasMax_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>* CameraService::Stub::PrepareAsyncGetExposureBiasMaxRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float32Message>::Create(channel_.get(), cq, rpcmethod_GetExposureBiasMax_, context, request, false);
}

::grpc::Status CameraService::Stub::GetExposureBias(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Float32Message* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetExposureBias_, context, request, response);
}

void CameraService::Stub::experimental_async::GetExposureBias(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetExposureBias_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetExposureBias(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetExposureBias_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetExposureBias(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetExposureBias_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetExposureBias(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetExposureBias_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>* CameraService::Stub::AsyncGetExposureBiasRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float32Message>::Create(channel_.get(), cq, rpcmethod_GetExposureBias_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float32Message>* CameraService::Stub::PrepareAsyncGetExposureBiasRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float32Message>::Create(channel_.get(), cq, rpcmethod_GetExposureBias_, context, request, false);
}

::grpc::Status CameraService::Stub::SetExposureBias(::grpc::ClientContext* context, const ::AR51::Float32Message& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetExposureBias_, context, request, response);
}

void CameraService::Stub::experimental_async::SetExposureBias(::grpc::ClientContext* context, const ::AR51::Float32Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetExposureBias_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetExposureBias(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetExposureBias_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetExposureBias(::grpc::ClientContext* context, const ::AR51::Float32Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetExposureBias_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::SetExposureBias(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetExposureBias_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::AsyncSetExposureBiasRaw(::grpc::ClientContext* context, const ::AR51::Float32Message& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetExposureBias_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::PrepareAsyncSetExposureBiasRaw(::grpc::ClientContext* context, const ::AR51::Float32Message& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetExposureBias_, context, request, false);
}

::grpc::Status CameraService::Stub::GetAutoFocus(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetAutoFocus_, context, request, response);
}

void CameraService::Stub::experimental_async::GetAutoFocus(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAutoFocus_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetAutoFocus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAutoFocus_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetAutoFocus(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAutoFocus_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetAutoFocus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAutoFocus_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraService::Stub::AsyncGetAutoFocusRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetAutoFocus_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraService::Stub::PrepareAsyncGetAutoFocusRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetAutoFocus_, context, request, false);
}

::grpc::Status CameraService::Stub::SetAutoFocus(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetAutoFocus_, context, request, response);
}

void CameraService::Stub::experimental_async::SetAutoFocus(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetAutoFocus_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetAutoFocus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetAutoFocus_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetAutoFocus(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetAutoFocus_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::SetAutoFocus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetAutoFocus_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::AsyncSetAutoFocusRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetAutoFocus_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::PrepareAsyncSetAutoFocusRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetAutoFocus_, context, request, false);
}

::grpc::Status CameraService::Stub::GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetIsRecording_, context, request, response);
}

void CameraService::Stub::experimental_async::GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetIsRecording_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetIsRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetIsRecording_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetIsRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetIsRecording_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetIsRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetIsRecording_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraService::Stub::AsyncGetIsRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetIsRecording_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraService::Stub::PrepareAsyncGetIsRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetIsRecording_, context, request, false);
}

::grpc::Status CameraService::Stub::GetIsRecordingReady(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetIsRecordingReady_, context, request, response);
}

void CameraService::Stub::experimental_async::GetIsRecordingReady(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetIsRecordingReady_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetIsRecordingReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetIsRecordingReady_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetIsRecordingReady(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetIsRecordingReady_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetIsRecordingReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetIsRecordingReady_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraService::Stub::AsyncGetIsRecordingReadyRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetIsRecordingReady_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraService::Stub::PrepareAsyncGetIsRecordingReadyRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetIsRecordingReady_, context, request, false);
}

::grpc::Status CameraService::Stub::GetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::BoolMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetAutoExposureEnabled_, context, request, response);
}

void CameraService::Stub::experimental_async::GetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAutoExposureEnabled_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetAutoExposureEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAutoExposureEnabled_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAutoExposureEnabled_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetAutoExposureEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAutoExposureEnabled_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraService::Stub::AsyncGetAutoExposureEnabledRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetAutoExposureEnabled_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* CameraService::Stub::PrepareAsyncGetAutoExposureEnabledRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetAutoExposureEnabled_, context, request, false);
}

::grpc::Status CameraService::Stub::SetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetAutoExposureEnabled_, context, request, response);
}

void CameraService::Stub::experimental_async::SetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetAutoExposureEnabled_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetAutoExposureEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetAutoExposureEnabled_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetAutoExposureEnabled(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetAutoExposureEnabled_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::SetAutoExposureEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetAutoExposureEnabled_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::AsyncSetAutoExposureEnabledRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetAutoExposureEnabled_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::PrepareAsyncSetAutoExposureEnabledRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetAutoExposureEnabled_, context, request, false);
}

::grpc::Status CameraService::Stub::GetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Int64Message* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetSensorExposureTime_, context, request, response);
}

void CameraService::Stub::experimental_async::GetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int64Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetSensorExposureTime_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetSensorExposureTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int64Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetSensorExposureTime_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetSensorExposureTime_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetSensorExposureTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetSensorExposureTime_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Int64Message>* CameraService::Stub::AsyncGetSensorExposureTimeRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Int64Message>::Create(channel_.get(), cq, rpcmethod_GetSensorExposureTime_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Int64Message>* CameraService::Stub::PrepareAsyncGetSensorExposureTimeRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Int64Message>::Create(channel_.get(), cq, rpcmethod_GetSensorExposureTime_, context, request, false);
}

::grpc::Status CameraService::Stub::SetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Int64Message& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetSensorExposureTime_, context, request, response);
}

void CameraService::Stub::experimental_async::SetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Int64Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetSensorExposureTime_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetSensorExposureTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetSensorExposureTime_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetSensorExposureTime(::grpc::ClientContext* context, const ::AR51::Int64Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetSensorExposureTime_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::SetSensorExposureTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetSensorExposureTime_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::AsyncSetSensorExposureTimeRaw(::grpc::ClientContext* context, const ::AR51::Int64Message& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetSensorExposureTime_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::PrepareAsyncSetSensorExposureTimeRaw(::grpc::ClientContext* context, const ::AR51::Int64Message& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetSensorExposureTime_, context, request, false);
}

::grpc::Status CameraService::Stub::GetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Int32Message* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetSensorSensitivity_, context, request, response);
}

void CameraService::Stub::experimental_async::GetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetSensorSensitivity_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetSensorSensitivity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetSensorSensitivity_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetSensorSensitivity_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetSensorSensitivity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Int32Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetSensorSensitivity_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>* CameraService::Stub::AsyncGetSensorSensitivityRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Int32Message>::Create(channel_.get(), cq, rpcmethod_GetSensorSensitivity_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Int32Message>* CameraService::Stub::PrepareAsyncGetSensorSensitivityRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Int32Message>::Create(channel_.get(), cq, rpcmethod_GetSensorSensitivity_, context, request, false);
}

::grpc::Status CameraService::Stub::SetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetSensorSensitivity_, context, request, response);
}

void CameraService::Stub::experimental_async::SetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetSensorSensitivity_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetSensorSensitivity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetSensorSensitivity_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetSensorSensitivity(::grpc::ClientContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetSensorSensitivity_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::SetSensorSensitivity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetSensorSensitivity_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::AsyncSetSensorSensitivityRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetSensorSensitivity_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::PrepareAsyncSetSensorSensitivityRaw(::grpc::ClientContext* context, const ::AR51::Int32Message& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetSensorSensitivity_, context, request, false);
}

::grpc::Status CameraService::Stub::GetVideoRecordingSetting(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::GetVideoRecordingSettingResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetVideoRecordingSetting_, context, request, response);
}

void CameraService::Stub::experimental_async::GetVideoRecordingSetting(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetVideoRecordingSettingResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetVideoRecordingSetting_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetVideoRecordingSetting(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetVideoRecordingSettingResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetVideoRecordingSetting_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetVideoRecordingSetting(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetVideoRecordingSettingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetVideoRecordingSetting_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetVideoRecordingSetting(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetVideoRecordingSettingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetVideoRecordingSetting_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::GetVideoRecordingSettingResponse>* CameraService::Stub::AsyncGetVideoRecordingSettingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::GetVideoRecordingSettingResponse>::Create(channel_.get(), cq, rpcmethod_GetVideoRecordingSetting_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::GetVideoRecordingSettingResponse>* CameraService::Stub::PrepareAsyncGetVideoRecordingSettingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::GetVideoRecordingSettingResponse>::Create(channel_.get(), cq, rpcmethod_GetVideoRecordingSetting_, context, request, false);
}

::grpc::Status CameraService::Stub::StartRecording(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest& request, ::AR51::StartRecordingResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_StartRecording_, context, request, response);
}

void CameraService::Stub::experimental_async::StartRecording(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest* request, ::AR51::StartRecordingResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StartRecording_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::StartRecordingResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StartRecording_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::StartRecording(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest* request, ::AR51::StartRecordingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StartRecording_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::StartRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::StartRecordingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StartRecording_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::StartRecordingResponse>* CameraService::Stub::AsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::StartRecordingResponse>::Create(channel_.get(), cq, rpcmethod_StartRecording_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::StartRecordingResponse>* CameraService::Stub::PrepareAsyncStartRecordingRaw(::grpc::ClientContext* context, const ::AR51::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::StartRecordingResponse>::Create(channel_.get(), cq, rpcmethod_StartRecording_, context, request, false);
}

::grpc::Status CameraService::Stub::StartMediaRecoder(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_StartMediaRecoder_, context, request, response);
}

void CameraService::Stub::experimental_async::StartMediaRecoder(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StartMediaRecoder_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::StartMediaRecoder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StartMediaRecoder_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::StartMediaRecoder(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StartMediaRecoder_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::StartMediaRecoder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StartMediaRecoder_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::AsyncStartMediaRecoderRaw(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_StartMediaRecoder_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::PrepareAsyncStartMediaRecoderRaw(::grpc::ClientContext* context, const ::AR51::StartMediaRecoderRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_StartMediaRecoder_, context, request, false);
}

::grpc::Status CameraService::Stub::StopRecording(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_StopRecording_, context, request, response);
}

void CameraService::Stub::experimental_async::StopRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StopRecording_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StopRecording_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::StopRecording(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StopRecording_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::StopRecording(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StopRecording_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::AsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_StopRecording_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::PrepareAsyncStopRecordingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_StopRecording_, context, request, false);
}

::grpc::ClientReader< ::AR51::BytesMessage>* CameraService::Stub::DownloadVideoRaw(::grpc::ClientContext* context, const ::AR51::DownloadVideoRequest& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::BytesMessage>::Create(channel_.get(), rpcmethod_DownloadVideo_, context, request);
}

void CameraService::Stub::experimental_async::DownloadVideo(::grpc::ClientContext* context, ::AR51::DownloadVideoRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::BytesMessage>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::BytesMessage>::Create(stub_->channel_.get(), stub_->rpcmethod_DownloadVideo_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::BytesMessage>* CameraService::Stub::AsyncDownloadVideoRaw(::grpc::ClientContext* context, const ::AR51::DownloadVideoRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::BytesMessage>::Create(channel_.get(), cq, rpcmethod_DownloadVideo_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::BytesMessage>* CameraService::Stub::PrepareAsyncDownloadVideoRaw(::grpc::ClientContext* context, const ::AR51::DownloadVideoRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::BytesMessage>::Create(channel_.get(), cq, rpcmethod_DownloadVideo_, context, request, false, nullptr);
}

::grpc::Status CameraService::Stub::DeleteVideo(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_DeleteVideo_, context, request, response);
}

void CameraService::Stub::experimental_async::DeleteVideo(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_DeleteVideo_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::DeleteVideo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_DeleteVideo_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::DeleteVideo(::grpc::ClientContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_DeleteVideo_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::DeleteVideo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_DeleteVideo_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::AsyncDeleteVideoRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_DeleteVideo_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::PrepareAsyncDeleteVideoRaw(::grpc::ClientContext* context, const ::AR51::StringMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_DeleteVideo_, context, request, false);
}

::grpc::Status CameraService::Stub::DeleteAllVideos(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_DeleteAllVideos_, context, request, response);
}

void CameraService::Stub::experimental_async::DeleteAllVideos(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_DeleteAllVideos_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::DeleteAllVideos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_DeleteAllVideos_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::DeleteAllVideos(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_DeleteAllVideos_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::DeleteAllVideos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_DeleteAllVideos_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::AsyncDeleteAllVideosRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_DeleteAllVideos_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::PrepareAsyncDeleteAllVideosRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_DeleteAllVideos_, context, request, false);
}

::grpc::Status CameraService::Stub::GetAllVideoFiles(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::GetAllVideoFilesResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetAllVideoFiles_, context, request, response);
}

void CameraService::Stub::experimental_async::GetAllVideoFiles(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetAllVideoFilesResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAllVideoFiles_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetAllVideoFiles(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetAllVideoFilesResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAllVideoFiles_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetAllVideoFiles(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetAllVideoFilesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAllVideoFiles_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetAllVideoFiles(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetAllVideoFilesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAllVideoFiles_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::GetAllVideoFilesResponse>* CameraService::Stub::AsyncGetAllVideoFilesRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::GetAllVideoFilesResponse>::Create(channel_.get(), cq, rpcmethod_GetAllVideoFiles_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::GetAllVideoFilesResponse>* CameraService::Stub::PrepareAsyncGetAllVideoFilesRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::GetAllVideoFilesResponse>::Create(channel_.get(), cq, rpcmethod_GetAllVideoFiles_, context, request, false);
}

::grpc::Status CameraService::Stub::GetCameraCharacteristics(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest& request, ::AR51::BytesMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetCameraCharacteristics_, context, request, response);
}

void CameraService::Stub::experimental_async::GetCameraCharacteristics(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest* request, ::AR51::BytesMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetCameraCharacteristics_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetCameraCharacteristics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BytesMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetCameraCharacteristics_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetCameraCharacteristics(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest* request, ::AR51::BytesMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetCameraCharacteristics_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetCameraCharacteristics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BytesMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetCameraCharacteristics_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BytesMessage>* CameraService::Stub::AsyncGetCameraCharacteristicsRaw(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BytesMessage>::Create(channel_.get(), cq, rpcmethod_GetCameraCharacteristics_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BytesMessage>* CameraService::Stub::PrepareAsyncGetCameraCharacteristicsRaw(::grpc::ClientContext* context, const ::AR51::GetCameraCharacteristicsRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BytesMessage>::Create(channel_.get(), cq, rpcmethod_GetCameraCharacteristics_, context, request, false);
}

::grpc::Status CameraService::Stub::GetRecorderField(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest& request, ::AR51::BytesMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetRecorderField_, context, request, response);
}

void CameraService::Stub::experimental_async::GetRecorderField(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest* request, ::AR51::BytesMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetRecorderField_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetRecorderField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BytesMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetRecorderField_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::GetRecorderField(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest* request, ::AR51::BytesMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetRecorderField_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::GetRecorderField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BytesMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetRecorderField_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BytesMessage>* CameraService::Stub::AsyncGetRecorderFieldRaw(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BytesMessage>::Create(channel_.get(), cq, rpcmethod_GetRecorderField_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BytesMessage>* CameraService::Stub::PrepareAsyncGetRecorderFieldRaw(::grpc::ClientContext* context, const ::AR51::GetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BytesMessage>::Create(channel_.get(), cq, rpcmethod_GetRecorderField_, context, request, false);
}

::grpc::Status CameraService::Stub::SetRecorderField(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetRecorderField_, context, request, response);
}

void CameraService::Stub::experimental_async::SetRecorderField(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetRecorderField_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetRecorderField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetRecorderField_, context, request, response, std::move(f));
}

void CameraService::Stub::experimental_async::SetRecorderField(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetRecorderField_, context, request, response, reactor);
}

void CameraService::Stub::experimental_async::SetRecorderField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetRecorderField_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::AsyncSetRecorderFieldRaw(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetRecorderField_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* CameraService::Stub::PrepareAsyncSetRecorderFieldRaw(::grpc::ClientContext* context, const ::AR51::SetRecorderFieldRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetRecorderField_, context, request, false);
}

CameraService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[0],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< CameraService::Service, ::AR51::CameraFeedRequest, ::AR51::CameraFeedResponse>(
          std::mem_fn(&CameraService::Service::StartStreaming), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[1],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< CameraService::Service, ::AR51::Empty, ::AR51::BytesMessage>(
          std::mem_fn(&CameraService::Service::StartRecorderStreaming), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::BoolMessage>(
          std::mem_fn(&CameraService::Service::GetIsStreaming), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::BoolMessage>(
          std::mem_fn(&CameraService::Service::GetHologramsEnabled), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::BoolMessage, ::AR51::Empty>(
          std::mem_fn(&CameraService::Service::SetHologramsEnabled), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::Int32Message>(
          std::mem_fn(&CameraService::Service::GetPreviewWidth), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Int32Message, ::AR51::Empty>(
          std::mem_fn(&CameraService::Service::SetPreviewWidth), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::Int32Message>(
          std::mem_fn(&CameraService::Service::GetPreviewHeight), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Int32Message, ::AR51::Empty>(
          std::mem_fn(&CameraService::Service::SetPreviewHeight), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[9],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::BoolMessage>(
          std::mem_fn(&CameraService::Service::GetExposureLock), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[10],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::BoolMessage, ::AR51::Empty>(
          std::mem_fn(&CameraService::Service::SetExposureLock), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[11],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::Float32Message>(
          std::mem_fn(&CameraService::Service::GetExposureBiasMin), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[12],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::Float32Message>(
          std::mem_fn(&CameraService::Service::GetExposureBiasMax), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[13],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::Float32Message>(
          std::mem_fn(&CameraService::Service::GetExposureBias), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[14],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Float32Message, ::AR51::Empty>(
          std::mem_fn(&CameraService::Service::SetExposureBias), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[15],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::BoolMessage>(
          std::mem_fn(&CameraService::Service::GetAutoFocus), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[16],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::BoolMessage, ::AR51::Empty>(
          std::mem_fn(&CameraService::Service::SetAutoFocus), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[17],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::BoolMessage>(
          std::mem_fn(&CameraService::Service::GetIsRecording), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[18],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::BoolMessage>(
          std::mem_fn(&CameraService::Service::GetIsRecordingReady), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[19],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::BoolMessage>(
          std::mem_fn(&CameraService::Service::GetAutoExposureEnabled), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[20],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::BoolMessage, ::AR51::Empty>(
          std::mem_fn(&CameraService::Service::SetAutoExposureEnabled), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[21],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::Int64Message>(
          std::mem_fn(&CameraService::Service::GetSensorExposureTime), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[22],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Int64Message, ::AR51::Empty>(
          std::mem_fn(&CameraService::Service::SetSensorExposureTime), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[23],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::Int32Message>(
          std::mem_fn(&CameraService::Service::GetSensorSensitivity), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[24],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Int32Message, ::AR51::Empty>(
          std::mem_fn(&CameraService::Service::SetSensorSensitivity), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[25],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::GetVideoRecordingSettingResponse>(
          std::mem_fn(&CameraService::Service::GetVideoRecordingSetting), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[26],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::StartRecordingRequest, ::AR51::StartRecordingResponse>(
          std::mem_fn(&CameraService::Service::StartRecording), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[27],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::StartMediaRecoderRequest, ::AR51::Empty>(
          std::mem_fn(&CameraService::Service::StartMediaRecoder), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[28],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::Empty>(
          std::mem_fn(&CameraService::Service::StopRecording), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[29],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< CameraService::Service, ::AR51::DownloadVideoRequest, ::AR51::BytesMessage>(
          std::mem_fn(&CameraService::Service::DownloadVideo), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[30],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::StringMessage, ::AR51::Empty>(
          std::mem_fn(&CameraService::Service::DeleteVideo), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[31],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::Empty>(
          std::mem_fn(&CameraService::Service::DeleteAllVideos), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[32],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::Empty, ::AR51::GetAllVideoFilesResponse>(
          std::mem_fn(&CameraService::Service::GetAllVideoFiles), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[33],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::GetCameraCharacteristicsRequest, ::AR51::BytesMessage>(
          std::mem_fn(&CameraService::Service::GetCameraCharacteristics), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[34],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::GetRecorderFieldRequest, ::AR51::BytesMessage>(
          std::mem_fn(&CameraService::Service::GetRecorderField), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CameraService_method_names[35],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CameraService::Service, ::AR51::SetRecorderFieldRequest, ::AR51::Empty>(
          std::mem_fn(&CameraService::Service::SetRecorderField), this)));
}

CameraService::Service::~Service() {
}

::grpc::Status CameraService::Service::StartStreaming(::grpc::ServerContext* context, const ::AR51::CameraFeedRequest* request, ::grpc::ServerWriter< ::AR51::CameraFeedResponse>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::StartRecorderStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::BytesMessage>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetIsStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::SetHologramsEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::SetPreviewWidth(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::SetPreviewHeight(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetExposureLock(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::SetExposureLock(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetExposureBiasMin(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetExposureBiasMax(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetExposureBias(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float32Message* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::SetExposureBias(::grpc::ServerContext* context, const ::AR51::Float32Message* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetAutoFocus(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::SetAutoFocus(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetIsRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetIsRecordingReady(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::BoolMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::SetAutoExposureEnabled(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int64Message* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::SetSensorExposureTime(::grpc::ServerContext* context, const ::AR51::Int64Message* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Int32Message* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::SetSensorSensitivity(::grpc::ServerContext* context, const ::AR51::Int32Message* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetVideoRecordingSetting(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetVideoRecordingSettingResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::StartRecording(::grpc::ServerContext* context, const ::AR51::StartRecordingRequest* request, ::AR51::StartRecordingResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::StartMediaRecoder(::grpc::ServerContext* context, const ::AR51::StartMediaRecoderRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::StopRecording(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::DownloadVideo(::grpc::ServerContext* context, const ::AR51::DownloadVideoRequest* request, ::grpc::ServerWriter< ::AR51::BytesMessage>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::DeleteVideo(::grpc::ServerContext* context, const ::AR51::StringMessage* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::DeleteAllVideos(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetAllVideoFiles(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetAllVideoFilesResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetCameraCharacteristics(::grpc::ServerContext* context, const ::AR51::GetCameraCharacteristicsRequest* request, ::AR51::BytesMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::GetRecorderField(::grpc::ServerContext* context, const ::AR51::GetRecorderFieldRequest* request, ::AR51::BytesMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CameraService::Service::SetRecorderField(::grpc::ServerContext* context, const ::AR51::SetRecorderFieldRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* RenderService_method_names[] = {
  "/AR51.RenderService/StartRendering",
};

std::unique_ptr< RenderService::Stub> RenderService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< RenderService::Stub> stub(new RenderService::Stub(channel));
  return stub;
}

RenderService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_StartRendering_(RenderService_method_names[0], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  {}

::grpc::ClientReader< ::AR51::RenderingResponse>* RenderService::Stub::StartRenderingRaw(::grpc::ClientContext* context, const ::AR51::RenderingRequest& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::RenderingResponse>::Create(channel_.get(), rpcmethod_StartRendering_, context, request);
}

void RenderService::Stub::experimental_async::StartRendering(::grpc::ClientContext* context, ::AR51::RenderingRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::RenderingResponse>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::RenderingResponse>::Create(stub_->channel_.get(), stub_->rpcmethod_StartRendering_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::RenderingResponse>* RenderService::Stub::AsyncStartRenderingRaw(::grpc::ClientContext* context, const ::AR51::RenderingRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::RenderingResponse>::Create(channel_.get(), cq, rpcmethod_StartRendering_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::RenderingResponse>* RenderService::Stub::PrepareAsyncStartRenderingRaw(::grpc::ClientContext* context, const ::AR51::RenderingRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::RenderingResponse>::Create(channel_.get(), cq, rpcmethod_StartRendering_, context, request, false, nullptr);
}

RenderService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RenderService_method_names[0],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< RenderService::Service, ::AR51::RenderingRequest, ::AR51::RenderingResponse>(
          std::mem_fn(&RenderService::Service::StartRendering), this)));
}

RenderService::Service::~Service() {
}

::grpc::Status RenderService::Service::StartRendering(::grpc::ServerContext* context, const ::AR51::RenderingRequest* request, ::grpc::ServerWriter< ::AR51::RenderingResponse>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* DrawService_method_names[] = {
  "/AR51.DrawService/Line2D",
  "/AR51.DrawService/Line3D",
  "/AR51.DrawService/Rect",
  "/AR51.DrawService/Cube",
  "/AR51.DrawService/Circle",
  "/AR51.DrawService/Sphere",
  "/AR51.DrawService/Clear",
};

std::unique_ptr< DrawService::Stub> DrawService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< DrawService::Stub> stub(new DrawService::Stub(channel));
  return stub;
}

DrawService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_Line2D_(DrawService_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Line3D_(DrawService_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Rect_(DrawService_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Cube_(DrawService_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Circle_(DrawService_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Sphere_(DrawService_method_names[5], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Clear_(DrawService_method_names[6], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status DrawService::Stub::Line2D(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Line2D_, context, request, response);
}

void DrawService::Stub::experimental_async::Line2D(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Line2D_, context, request, response, std::move(f));
}

void DrawService::Stub::experimental_async::Line2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Line2D_, context, request, response, std::move(f));
}

void DrawService::Stub::experimental_async::Line2D(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Line2D_, context, request, response, reactor);
}

void DrawService::Stub::experimental_async::Line2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Line2D_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* DrawService::Stub::AsyncLine2DRaw(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Line2D_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* DrawService::Stub::PrepareAsyncLine2DRaw(::grpc::ClientContext* context, const ::AR51::DrawLine2DRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Line2D_, context, request, false);
}

::grpc::Status DrawService::Stub::Line3D(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Line3D_, context, request, response);
}

void DrawService::Stub::experimental_async::Line3D(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Line3D_, context, request, response, std::move(f));
}

void DrawService::Stub::experimental_async::Line3D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Line3D_, context, request, response, std::move(f));
}

void DrawService::Stub::experimental_async::Line3D(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Line3D_, context, request, response, reactor);
}

void DrawService::Stub::experimental_async::Line3D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Line3D_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* DrawService::Stub::AsyncLine3DRaw(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Line3D_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* DrawService::Stub::PrepareAsyncLine3DRaw(::grpc::ClientContext* context, const ::AR51::DrawLine3DRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Line3D_, context, request, false);
}

::grpc::Status DrawService::Stub::Rect(::grpc::ClientContext* context, const ::AR51::DrawRectRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Rect_, context, request, response);
}

void DrawService::Stub::experimental_async::Rect(::grpc::ClientContext* context, const ::AR51::DrawRectRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Rect_, context, request, response, std::move(f));
}

void DrawService::Stub::experimental_async::Rect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Rect_, context, request, response, std::move(f));
}

void DrawService::Stub::experimental_async::Rect(::grpc::ClientContext* context, const ::AR51::DrawRectRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Rect_, context, request, response, reactor);
}

void DrawService::Stub::experimental_async::Rect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Rect_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* DrawService::Stub::AsyncRectRaw(::grpc::ClientContext* context, const ::AR51::DrawRectRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Rect_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* DrawService::Stub::PrepareAsyncRectRaw(::grpc::ClientContext* context, const ::AR51::DrawRectRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Rect_, context, request, false);
}

::grpc::Status DrawService::Stub::Cube(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Cube_, context, request, response);
}

void DrawService::Stub::experimental_async::Cube(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Cube_, context, request, response, std::move(f));
}

void DrawService::Stub::experimental_async::Cube(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Cube_, context, request, response, std::move(f));
}

void DrawService::Stub::experimental_async::Cube(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Cube_, context, request, response, reactor);
}

void DrawService::Stub::experimental_async::Cube(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Cube_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* DrawService::Stub::AsyncCubeRaw(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Cube_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* DrawService::Stub::PrepareAsyncCubeRaw(::grpc::ClientContext* context, const ::AR51::DrawCubeRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Cube_, context, request, false);
}

::grpc::Status DrawService::Stub::Circle(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Circle_, context, request, response);
}

void DrawService::Stub::experimental_async::Circle(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Circle_, context, request, response, std::move(f));
}

void DrawService::Stub::experimental_async::Circle(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Circle_, context, request, response, std::move(f));
}

void DrawService::Stub::experimental_async::Circle(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Circle_, context, request, response, reactor);
}

void DrawService::Stub::experimental_async::Circle(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Circle_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* DrawService::Stub::AsyncCircleRaw(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Circle_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* DrawService::Stub::PrepareAsyncCircleRaw(::grpc::ClientContext* context, const ::AR51::DrawCircleRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Circle_, context, request, false);
}

::grpc::Status DrawService::Stub::Sphere(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Sphere_, context, request, response);
}

void DrawService::Stub::experimental_async::Sphere(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Sphere_, context, request, response, std::move(f));
}

void DrawService::Stub::experimental_async::Sphere(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Sphere_, context, request, response, std::move(f));
}

void DrawService::Stub::experimental_async::Sphere(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Sphere_, context, request, response, reactor);
}

void DrawService::Stub::experimental_async::Sphere(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Sphere_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* DrawService::Stub::AsyncSphereRaw(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Sphere_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* DrawService::Stub::PrepareAsyncSphereRaw(::grpc::ClientContext* context, const ::AR51::DrawSphereRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Sphere_, context, request, false);
}

::grpc::Status DrawService::Stub::Clear(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Clear_, context, request, response);
}

void DrawService::Stub::experimental_async::Clear(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Clear_, context, request, response, std::move(f));
}

void DrawService::Stub::experimental_async::Clear(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Clear_, context, request, response, std::move(f));
}

void DrawService::Stub::experimental_async::Clear(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Clear_, context, request, response, reactor);
}

void DrawService::Stub::experimental_async::Clear(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Clear_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* DrawService::Stub::AsyncClearRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Clear_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* DrawService::Stub::PrepareAsyncClearRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Clear_, context, request, false);
}

DrawService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DrawService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DrawService::Service, ::AR51::DrawLine2DRequest, ::AR51::Empty>(
          std::mem_fn(&DrawService::Service::Line2D), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DrawService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DrawService::Service, ::AR51::DrawLine3DRequest, ::AR51::Empty>(
          std::mem_fn(&DrawService::Service::Line3D), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DrawService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DrawService::Service, ::AR51::DrawRectRequest, ::AR51::Empty>(
          std::mem_fn(&DrawService::Service::Rect), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DrawService_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DrawService::Service, ::AR51::DrawCubeRequest, ::AR51::Empty>(
          std::mem_fn(&DrawService::Service::Cube), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DrawService_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DrawService::Service, ::AR51::DrawCircleRequest, ::AR51::Empty>(
          std::mem_fn(&DrawService::Service::Circle), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DrawService_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DrawService::Service, ::AR51::DrawSphereRequest, ::AR51::Empty>(
          std::mem_fn(&DrawService::Service::Sphere), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DrawService_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DrawService::Service, ::AR51::Empty, ::AR51::Empty>(
          std::mem_fn(&DrawService::Service::Clear), this)));
}

DrawService::Service::~Service() {
}

::grpc::Status DrawService::Service::Line2D(::grpc::ServerContext* context, const ::AR51::DrawLine2DRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DrawService::Service::Line3D(::grpc::ServerContext* context, const ::AR51::DrawLine3DRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DrawService::Service::Rect(::grpc::ServerContext* context, const ::AR51::DrawRectRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DrawService::Service::Cube(::grpc::ServerContext* context, const ::AR51::DrawCubeRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DrawService::Service::Circle(::grpc::ServerContext* context, const ::AR51::DrawCircleRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DrawService::Service::Sphere(::grpc::ServerContext* context, const ::AR51::DrawSphereRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DrawService::Service::Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* UnityService_method_names[] = {
  "/AR51.UnityService/GetPyTime",
  "/AR51.UnityService/GetPyTimeOffset",
  "/AR51.UnityService/SetPyTimeOffset",
  "/AR51.UnityService/Instantiate",
  "/AR51.UnityService/FindGameObject",
  "/AR51.UnityService/FindAnchorGameObject",
  "/AR51.UnityService/GetMainCamera",
  "/AR51.UnityService/Destroy",
  "/AR51.UnityService/CreatePrimitive",
  "/AR51.UnityService/NewGameObject",
  "/AR51.UnityService/ClearInstances",
  "/AR51.UnityService/SetParent",
  "/AR51.UnityService/GetName",
  "/AR51.UnityService/SetName",
  "/AR51.UnityService/GetActive",
  "/AR51.UnityService/SetActive",
  "/AR51.UnityService/GetTransform",
  "/AR51.UnityService/SetTransform",
  "/AR51.UnityService/StreamTransform",
  "/AR51.UnityService/GetComponent",
  "/AR51.UnityService/GetComponentField",
  "/AR51.UnityService/SetComponentField",
  "/AR51.UnityService/SetCameraProject",
  "/AR51.UnityService/SetRendererEnabled",
  "/AR51.UnityService/SetMaterialTexture",
  "/AR51.UnityService/SetMaterialInt32",
  "/AR51.UnityService/SetMaterialFloat",
  "/AR51.UnityService/SetMaterialColor",
  "/AR51.UnityService/GetMaterialColor",
};

std::unique_ptr< UnityService::Stub> UnityService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< UnityService::Stub> stub(new UnityService::Stub(channel));
  return stub;
}

UnityService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_GetPyTime_(UnityService_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetPyTimeOffset_(UnityService_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetPyTimeOffset_(UnityService_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Instantiate_(UnityService_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_FindGameObject_(UnityService_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_FindAnchorGameObject_(UnityService_method_names[5], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetMainCamera_(UnityService_method_names[6], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Destroy_(UnityService_method_names[7], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_CreatePrimitive_(UnityService_method_names[8], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_NewGameObject_(UnityService_method_names[9], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ClearInstances_(UnityService_method_names[10], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetParent_(UnityService_method_names[11], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetName_(UnityService_method_names[12], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetName_(UnityService_method_names[13], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetActive_(UnityService_method_names[14], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetActive_(UnityService_method_names[15], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetTransform_(UnityService_method_names[16], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetTransform_(UnityService_method_names[17], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_StreamTransform_(UnityService_method_names[18], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  , rpcmethod_GetComponent_(UnityService_method_names[19], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetComponentField_(UnityService_method_names[20], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetComponentField_(UnityService_method_names[21], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetCameraProject_(UnityService_method_names[22], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetRendererEnabled_(UnityService_method_names[23], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetMaterialTexture_(UnityService_method_names[24], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetMaterialInt32_(UnityService_method_names[25], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetMaterialFloat_(UnityService_method_names[26], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetMaterialColor_(UnityService_method_names[27], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetMaterialColor_(UnityService_method_names[28], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status UnityService::Stub::GetPyTime(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Float64Message* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetPyTime_, context, request, response);
}

void UnityService::Stub::experimental_async::GetPyTime(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetPyTime_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetPyTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetPyTime_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetPyTime(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetPyTime_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::GetPyTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetPyTime_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* UnityService::Stub::AsyncGetPyTimeRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float64Message>::Create(channel_.get(), cq, rpcmethod_GetPyTime_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* UnityService::Stub::PrepareAsyncGetPyTimeRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float64Message>::Create(channel_.get(), cq, rpcmethod_GetPyTime_, context, request, false);
}

::grpc::Status UnityService::Stub::GetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Float64Message* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetPyTimeOffset_, context, request, response);
}

void UnityService::Stub::experimental_async::GetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetPyTimeOffset_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetPyTimeOffset(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetPyTimeOffset_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetPyTimeOffset_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::GetPyTimeOffset(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Float64Message* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetPyTimeOffset_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* UnityService::Stub::AsyncGetPyTimeOffsetRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float64Message>::Create(channel_.get(), cq, rpcmethod_GetPyTimeOffset_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Float64Message>* UnityService::Stub::PrepareAsyncGetPyTimeOffsetRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Float64Message>::Create(channel_.get(), cq, rpcmethod_GetPyTimeOffset_, context, request, false);
}

::grpc::Status UnityService::Stub::SetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Float64Message& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetPyTimeOffset_, context, request, response);
}

void UnityService::Stub::experimental_async::SetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Float64Message* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetPyTimeOffset_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetPyTimeOffset(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetPyTimeOffset_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetPyTimeOffset(::grpc::ClientContext* context, const ::AR51::Float64Message* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetPyTimeOffset_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::SetPyTimeOffset(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetPyTimeOffset_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::AsyncSetPyTimeOffsetRaw(::grpc::ClientContext* context, const ::AR51::Float64Message& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetPyTimeOffset_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::PrepareAsyncSetPyTimeOffsetRaw(::grpc::ClientContext* context, const ::AR51::Float64Message& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetPyTimeOffset_, context, request, false);
}

::grpc::Status UnityService::Stub::Instantiate(::grpc::ClientContext* context, const ::AR51::InstantiateRequest& request, ::AR51::ObjectIdMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Instantiate_, context, request, response);
}

void UnityService::Stub::experimental_async::Instantiate(::grpc::ClientContext* context, const ::AR51::InstantiateRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Instantiate_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::Instantiate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Instantiate_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::Instantiate(::grpc::ClientContext* context, const ::AR51::InstantiateRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Instantiate_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::Instantiate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Instantiate_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* UnityService::Stub::AsyncInstantiateRaw(::grpc::ClientContext* context, const ::AR51::InstantiateRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ObjectIdMessage>::Create(channel_.get(), cq, rpcmethod_Instantiate_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* UnityService::Stub::PrepareAsyncInstantiateRaw(::grpc::ClientContext* context, const ::AR51::InstantiateRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ObjectIdMessage>::Create(channel_.get(), cq, rpcmethod_Instantiate_, context, request, false);
}

::grpc::Status UnityService::Stub::FindGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::AR51::ObjectIdMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_FindGameObject_, context, request, response);
}

void UnityService::Stub::experimental_async::FindGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_FindGameObject_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::FindGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_FindGameObject_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::FindGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_FindGameObject_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::FindGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_FindGameObject_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* UnityService::Stub::AsyncFindGameObjectRaw(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ObjectIdMessage>::Create(channel_.get(), cq, rpcmethod_FindGameObject_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* UnityService::Stub::PrepareAsyncFindGameObjectRaw(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ObjectIdMessage>::Create(channel_.get(), cq, rpcmethod_FindGameObject_, context, request, false);
}

::grpc::Status UnityService::Stub::FindAnchorGameObject(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::AR51::ObjectIdMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_FindAnchorGameObject_, context, request, response);
}

void UnityService::Stub::experimental_async::FindAnchorGameObject(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_FindAnchorGameObject_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::FindAnchorGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_FindAnchorGameObject_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::FindAnchorGameObject(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_FindAnchorGameObject_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::FindAnchorGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_FindAnchorGameObject_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* UnityService::Stub::AsyncFindAnchorGameObjectRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ObjectIdMessage>::Create(channel_.get(), cq, rpcmethod_FindAnchorGameObject_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* UnityService::Stub::PrepareAsyncFindAnchorGameObjectRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ObjectIdMessage>::Create(channel_.get(), cq, rpcmethod_FindAnchorGameObject_, context, request, false);
}

::grpc::Status UnityService::Stub::GetMainCamera(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::ObjectIdMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetMainCamera_, context, request, response);
}

void UnityService::Stub::experimental_async::GetMainCamera(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetMainCamera_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetMainCamera(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetMainCamera_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetMainCamera(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetMainCamera_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::GetMainCamera(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetMainCamera_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* UnityService::Stub::AsyncGetMainCameraRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ObjectIdMessage>::Create(channel_.get(), cq, rpcmethod_GetMainCamera_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* UnityService::Stub::PrepareAsyncGetMainCameraRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ObjectIdMessage>::Create(channel_.get(), cq, rpcmethod_GetMainCamera_, context, request, false);
}

::grpc::Status UnityService::Stub::Destroy(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Destroy_, context, request, response);
}

void UnityService::Stub::experimental_async::Destroy(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Destroy_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::Destroy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Destroy_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::Destroy(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Destroy_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::Destroy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Destroy_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::AsyncDestroyRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Destroy_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::PrepareAsyncDestroyRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Destroy_, context, request, false);
}

::grpc::Status UnityService::Stub::CreatePrimitive(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest& request, ::AR51::ObjectIdMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_CreatePrimitive_, context, request, response);
}

void UnityService::Stub::experimental_async::CreatePrimitive(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_CreatePrimitive_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::CreatePrimitive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_CreatePrimitive_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::CreatePrimitive(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_CreatePrimitive_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::CreatePrimitive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_CreatePrimitive_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* UnityService::Stub::AsyncCreatePrimitiveRaw(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ObjectIdMessage>::Create(channel_.get(), cq, rpcmethod_CreatePrimitive_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* UnityService::Stub::PrepareAsyncCreatePrimitiveRaw(::grpc::ClientContext* context, const ::AR51::CreatePrimitiveRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ObjectIdMessage>::Create(channel_.get(), cq, rpcmethod_CreatePrimitive_, context, request, false);
}

::grpc::Status UnityService::Stub::NewGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::AR51::ObjectIdMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_NewGameObject_, context, request, response);
}

void UnityService::Stub::experimental_async::NewGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_NewGameObject_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::NewGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_NewGameObject_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::NewGameObject(::grpc::ClientContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_NewGameObject_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::NewGameObject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_NewGameObject_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* UnityService::Stub::AsyncNewGameObjectRaw(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ObjectIdMessage>::Create(channel_.get(), cq, rpcmethod_NewGameObject_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* UnityService::Stub::PrepareAsyncNewGameObjectRaw(::grpc::ClientContext* context, const ::AR51::NameRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ObjectIdMessage>::Create(channel_.get(), cq, rpcmethod_NewGameObject_, context, request, false);
}

::grpc::Status UnityService::Stub::ClearInstances(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ClearInstances_, context, request, response);
}

void UnityService::Stub::experimental_async::ClearInstances(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ClearInstances_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::ClearInstances(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ClearInstances_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::ClearInstances(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ClearInstances_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::ClearInstances(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ClearInstances_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::AsyncClearInstancesRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_ClearInstances_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::PrepareAsyncClearInstancesRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_ClearInstances_, context, request, false);
}

::grpc::Status UnityService::Stub::SetParent(::grpc::ClientContext* context, const ::AR51::SetParentRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetParent_, context, request, response);
}

void UnityService::Stub::experimental_async::SetParent(::grpc::ClientContext* context, const ::AR51::SetParentRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetParent_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetParent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetParent_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetParent(::grpc::ClientContext* context, const ::AR51::SetParentRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetParent_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::SetParent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetParent_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::AsyncSetParentRaw(::grpc::ClientContext* context, const ::AR51::SetParentRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetParent_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::PrepareAsyncSetParentRaw(::grpc::ClientContext* context, const ::AR51::SetParentRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetParent_, context, request, false);
}

::grpc::Status UnityService::Stub::GetName(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::AR51::NameRequest* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetName_, context, request, response);
}

void UnityService::Stub::experimental_async::GetName(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::NameRequest* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetName_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::NameRequest* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetName_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetName(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::NameRequest* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetName_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::GetName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::NameRequest* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetName_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::NameRequest>* UnityService::Stub::AsyncGetNameRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::NameRequest>::Create(channel_.get(), cq, rpcmethod_GetName_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::NameRequest>* UnityService::Stub::PrepareAsyncGetNameRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::NameRequest>::Create(channel_.get(), cq, rpcmethod_GetName_, context, request, false);
}

::grpc::Status UnityService::Stub::SetName(::grpc::ClientContext* context, const ::AR51::SetNameRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetName_, context, request, response);
}

void UnityService::Stub::experimental_async::SetName(::grpc::ClientContext* context, const ::AR51::SetNameRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetName_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetName_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetName(::grpc::ClientContext* context, const ::AR51::SetNameRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetName_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::SetName(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetName_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::AsyncSetNameRaw(::grpc::ClientContext* context, const ::AR51::SetNameRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetName_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::PrepareAsyncSetNameRaw(::grpc::ClientContext* context, const ::AR51::SetNameRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetName_, context, request, false);
}

::grpc::Status UnityService::Stub::GetActive(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::AR51::ActiveMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetActive_, context, request, response);
}

void UnityService::Stub::experimental_async::GetActive(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::ActiveMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetActive_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetActive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ActiveMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetActive_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetActive(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::ActiveMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetActive_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::GetActive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ActiveMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetActive_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::ActiveMessage>* UnityService::Stub::AsyncGetActiveRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ActiveMessage>::Create(channel_.get(), cq, rpcmethod_GetActive_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::ActiveMessage>* UnityService::Stub::PrepareAsyncGetActiveRaw(::grpc::ClientContext* context, const ::AR51::ObjectIdMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ActiveMessage>::Create(channel_.get(), cq, rpcmethod_GetActive_, context, request, false);
}

::grpc::Status UnityService::Stub::SetActive(::grpc::ClientContext* context, const ::AR51::ActiveMessage& request, ::AR51::ActiveMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetActive_, context, request, response);
}

void UnityService::Stub::experimental_async::SetActive(::grpc::ClientContext* context, const ::AR51::ActiveMessage* request, ::AR51::ActiveMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetActive_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetActive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ActiveMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetActive_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetActive(::grpc::ClientContext* context, const ::AR51::ActiveMessage* request, ::AR51::ActiveMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetActive_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::SetActive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ActiveMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetActive_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::ActiveMessage>* UnityService::Stub::AsyncSetActiveRaw(::grpc::ClientContext* context, const ::AR51::ActiveMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ActiveMessage>::Create(channel_.get(), cq, rpcmethod_SetActive_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::ActiveMessage>* UnityService::Stub::PrepareAsyncSetActiveRaw(::grpc::ClientContext* context, const ::AR51::ActiveMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ActiveMessage>::Create(channel_.get(), cq, rpcmethod_SetActive_, context, request, false);
}

::grpc::Status UnityService::Stub::GetTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::AR51::TransformMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetTransform_, context, request, response);
}

void UnityService::Stub::experimental_async::GetTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest* request, ::AR51::TransformMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetTransform_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetTransform(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::TransformMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetTransform_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetTransform(::grpc::ClientContext* context, const ::AR51::GetTransformRequest* request, ::AR51::TransformMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetTransform_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::GetTransform(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::TransformMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetTransform_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::TransformMessage>* UnityService::Stub::AsyncGetTransformRaw(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::TransformMessage>::Create(channel_.get(), cq, rpcmethod_GetTransform_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::TransformMessage>* UnityService::Stub::PrepareAsyncGetTransformRaw(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::TransformMessage>::Create(channel_.get(), cq, rpcmethod_GetTransform_, context, request, false);
}

::grpc::Status UnityService::Stub::SetTransform(::grpc::ClientContext* context, const ::AR51::SetTransformRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetTransform_, context, request, response);
}

void UnityService::Stub::experimental_async::SetTransform(::grpc::ClientContext* context, const ::AR51::SetTransformRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetTransform_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetTransform(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetTransform_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetTransform(::grpc::ClientContext* context, const ::AR51::SetTransformRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetTransform_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::SetTransform(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetTransform_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::AsyncSetTransformRaw(::grpc::ClientContext* context, const ::AR51::SetTransformRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetTransform_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::PrepareAsyncSetTransformRaw(::grpc::ClientContext* context, const ::AR51::SetTransformRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetTransform_, context, request, false);
}

::grpc::ClientReader< ::AR51::TransformMessage>* UnityService::Stub::StreamTransformRaw(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::TransformMessage>::Create(channel_.get(), rpcmethod_StreamTransform_, context, request);
}

void UnityService::Stub::experimental_async::StreamTransform(::grpc::ClientContext* context, ::AR51::GetTransformRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::TransformMessage>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::TransformMessage>::Create(stub_->channel_.get(), stub_->rpcmethod_StreamTransform_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::TransformMessage>* UnityService::Stub::AsyncStreamTransformRaw(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::TransformMessage>::Create(channel_.get(), cq, rpcmethod_StreamTransform_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::TransformMessage>* UnityService::Stub::PrepareAsyncStreamTransformRaw(::grpc::ClientContext* context, const ::AR51::GetTransformRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::TransformMessage>::Create(channel_.get(), cq, rpcmethod_StreamTransform_, context, request, false, nullptr);
}

::grpc::Status UnityService::Stub::GetComponent(::grpc::ClientContext* context, const ::AR51::ComponentRequest& request, ::AR51::ObjectIdMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetComponent_, context, request, response);
}

void UnityService::Stub::experimental_async::GetComponent(::grpc::ClientContext* context, const ::AR51::ComponentRequest* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetComponent_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetComponent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetComponent_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetComponent(::grpc::ClientContext* context, const ::AR51::ComponentRequest* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetComponent_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::GetComponent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ObjectIdMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetComponent_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* UnityService::Stub::AsyncGetComponentRaw(::grpc::ClientContext* context, const ::AR51::ComponentRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ObjectIdMessage>::Create(channel_.get(), cq, rpcmethod_GetComponent_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::ObjectIdMessage>* UnityService::Stub::PrepareAsyncGetComponentRaw(::grpc::ClientContext* context, const ::AR51::ComponentRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ObjectIdMessage>::Create(channel_.get(), cq, rpcmethod_GetComponent_, context, request, false);
}

::grpc::Status UnityService::Stub::GetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::AR51::ComponentFieldMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetComponentField_, context, request, response);
}

void UnityService::Stub::experimental_async::GetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::ComponentFieldMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetComponentField_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetComponentField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ComponentFieldMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetComponentField_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::ComponentFieldMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetComponentField_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::GetComponentField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::ComponentFieldMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetComponentField_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::ComponentFieldMessage>* UnityService::Stub::AsyncGetComponentFieldRaw(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ComponentFieldMessage>::Create(channel_.get(), cq, rpcmethod_GetComponentField_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::ComponentFieldMessage>* UnityService::Stub::PrepareAsyncGetComponentFieldRaw(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::ComponentFieldMessage>::Create(channel_.get(), cq, rpcmethod_GetComponentField_, context, request, false);
}

::grpc::Status UnityService::Stub::SetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetComponentField_, context, request, response);
}

void UnityService::Stub::experimental_async::SetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetComponentField_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetComponentField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetComponentField_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetComponentField(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetComponentField_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::SetComponentField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetComponentField_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::AsyncSetComponentFieldRaw(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetComponentField_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::PrepareAsyncSetComponentFieldRaw(::grpc::ClientContext* context, const ::AR51::ComponentFieldMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetComponentField_, context, request, false);
}

::grpc::Status UnityService::Stub::SetCameraProject(::grpc::ClientContext* context, const ::AR51::TransformMessage& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetCameraProject_, context, request, response);
}

void UnityService::Stub::experimental_async::SetCameraProject(::grpc::ClientContext* context, const ::AR51::TransformMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetCameraProject_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetCameraProject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetCameraProject_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetCameraProject(::grpc::ClientContext* context, const ::AR51::TransformMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetCameraProject_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::SetCameraProject(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetCameraProject_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::AsyncSetCameraProjectRaw(::grpc::ClientContext* context, const ::AR51::TransformMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetCameraProject_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::PrepareAsyncSetCameraProjectRaw(::grpc::ClientContext* context, const ::AR51::TransformMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetCameraProject_, context, request, false);
}

::grpc::Status UnityService::Stub::SetRendererEnabled(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetRendererEnabled_, context, request, response);
}

void UnityService::Stub::experimental_async::SetRendererEnabled(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetRendererEnabled_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetRendererEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetRendererEnabled_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetRendererEnabled(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetRendererEnabled_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::SetRendererEnabled(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetRendererEnabled_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::AsyncSetRendererEnabledRaw(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetRendererEnabled_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::PrepareAsyncSetRendererEnabledRaw(::grpc::ClientContext* context, const ::AR51::SetRendererEnabledRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetRendererEnabled_, context, request, false);
}

::grpc::Status UnityService::Stub::SetMaterialTexture(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetMaterialTexture_, context, request, response);
}

void UnityService::Stub::experimental_async::SetMaterialTexture(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetMaterialTexture_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetMaterialTexture(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetMaterialTexture_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetMaterialTexture(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetMaterialTexture_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::SetMaterialTexture(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetMaterialTexture_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::AsyncSetMaterialTextureRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetMaterialTexture_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::PrepareAsyncSetMaterialTextureRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialTextureRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetMaterialTexture_, context, request, false);
}

::grpc::Status UnityService::Stub::SetMaterialInt32(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetMaterialInt32_, context, request, response);
}

void UnityService::Stub::experimental_async::SetMaterialInt32(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetMaterialInt32_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetMaterialInt32(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetMaterialInt32_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetMaterialInt32(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetMaterialInt32_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::SetMaterialInt32(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetMaterialInt32_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::AsyncSetMaterialInt32Raw(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetMaterialInt32_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::PrepareAsyncSetMaterialInt32Raw(::grpc::ClientContext* context, const ::AR51::SetMaterialInt32Request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetMaterialInt32_, context, request, false);
}

::grpc::Status UnityService::Stub::SetMaterialFloat(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetMaterialFloat_, context, request, response);
}

void UnityService::Stub::experimental_async::SetMaterialFloat(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetMaterialFloat_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetMaterialFloat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetMaterialFloat_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetMaterialFloat(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetMaterialFloat_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::SetMaterialFloat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetMaterialFloat_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::AsyncSetMaterialFloatRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetMaterialFloat_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::PrepareAsyncSetMaterialFloatRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialFloatRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetMaterialFloat_, context, request, false);
}

::grpc::Status UnityService::Stub::SetMaterialColor(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetMaterialColor_, context, request, response);
}

void UnityService::Stub::experimental_async::SetMaterialColor(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetMaterialColor_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetMaterialColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetMaterialColor_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::SetMaterialColor(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetMaterialColor_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::SetMaterialColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetMaterialColor_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::AsyncSetMaterialColorRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetMaterialColor_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* UnityService::Stub::PrepareAsyncSetMaterialColorRaw(::grpc::ClientContext* context, const ::AR51::SetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetMaterialColor_, context, request, false);
}

::grpc::Status UnityService::Stub::GetMaterialColor(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest& request, ::AR51::Color* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetMaterialColor_, context, request, response);
}

void UnityService::Stub::experimental_async::GetMaterialColor(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest* request, ::AR51::Color* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetMaterialColor_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetMaterialColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Color* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetMaterialColor_, context, request, response, std::move(f));
}

void UnityService::Stub::experimental_async::GetMaterialColor(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest* request, ::AR51::Color* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetMaterialColor_, context, request, response, reactor);
}

void UnityService::Stub::experimental_async::GetMaterialColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Color* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetMaterialColor_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Color>* UnityService::Stub::AsyncGetMaterialColorRaw(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Color>::Create(channel_.get(), cq, rpcmethod_GetMaterialColor_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Color>* UnityService::Stub::PrepareAsyncGetMaterialColorRaw(::grpc::ClientContext* context, const ::AR51::GetMaterialColorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Color>::Create(channel_.get(), cq, rpcmethod_GetMaterialColor_, context, request, false);
}

UnityService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::Empty, ::AR51::Float64Message>(
          std::mem_fn(&UnityService::Service::GetPyTime), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::Empty, ::AR51::Float64Message>(
          std::mem_fn(&UnityService::Service::GetPyTimeOffset), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::Float64Message, ::AR51::Empty>(
          std::mem_fn(&UnityService::Service::SetPyTimeOffset), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::InstantiateRequest, ::AR51::ObjectIdMessage>(
          std::mem_fn(&UnityService::Service::Instantiate), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::NameRequest, ::AR51::ObjectIdMessage>(
          std::mem_fn(&UnityService::Service::FindGameObject), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::AnchorRequest, ::AR51::ObjectIdMessage>(
          std::mem_fn(&UnityService::Service::FindAnchorGameObject), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::Empty, ::AR51::ObjectIdMessage>(
          std::mem_fn(&UnityService::Service::GetMainCamera), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::ObjectIdMessage, ::AR51::Empty>(
          std::mem_fn(&UnityService::Service::Destroy), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::CreatePrimitiveRequest, ::AR51::ObjectIdMessage>(
          std::mem_fn(&UnityService::Service::CreatePrimitive), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[9],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::NameRequest, ::AR51::ObjectIdMessage>(
          std::mem_fn(&UnityService::Service::NewGameObject), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[10],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::Empty, ::AR51::Empty>(
          std::mem_fn(&UnityService::Service::ClearInstances), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[11],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::SetParentRequest, ::AR51::Empty>(
          std::mem_fn(&UnityService::Service::SetParent), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[12],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::ObjectIdMessage, ::AR51::NameRequest>(
          std::mem_fn(&UnityService::Service::GetName), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[13],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::SetNameRequest, ::AR51::Empty>(
          std::mem_fn(&UnityService::Service::SetName), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[14],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::ObjectIdMessage, ::AR51::ActiveMessage>(
          std::mem_fn(&UnityService::Service::GetActive), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[15],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::ActiveMessage, ::AR51::ActiveMessage>(
          std::mem_fn(&UnityService::Service::SetActive), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[16],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::GetTransformRequest, ::AR51::TransformMessage>(
          std::mem_fn(&UnityService::Service::GetTransform), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[17],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::SetTransformRequest, ::AR51::Empty>(
          std::mem_fn(&UnityService::Service::SetTransform), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[18],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< UnityService::Service, ::AR51::GetTransformRequest, ::AR51::TransformMessage>(
          std::mem_fn(&UnityService::Service::StreamTransform), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[19],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::ComponentRequest, ::AR51::ObjectIdMessage>(
          std::mem_fn(&UnityService::Service::GetComponent), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[20],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::ComponentFieldMessage, ::AR51::ComponentFieldMessage>(
          std::mem_fn(&UnityService::Service::GetComponentField), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[21],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::ComponentFieldMessage, ::AR51::Empty>(
          std::mem_fn(&UnityService::Service::SetComponentField), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[22],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::TransformMessage, ::AR51::Empty>(
          std::mem_fn(&UnityService::Service::SetCameraProject), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[23],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::SetRendererEnabledRequest, ::AR51::Empty>(
          std::mem_fn(&UnityService::Service::SetRendererEnabled), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[24],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::SetMaterialTextureRequest, ::AR51::Empty>(
          std::mem_fn(&UnityService::Service::SetMaterialTexture), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[25],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::SetMaterialInt32Request, ::AR51::Empty>(
          std::mem_fn(&UnityService::Service::SetMaterialInt32), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[26],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::SetMaterialFloatRequest, ::AR51::Empty>(
          std::mem_fn(&UnityService::Service::SetMaterialFloat), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[27],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::SetMaterialColorRequest, ::AR51::Empty>(
          std::mem_fn(&UnityService::Service::SetMaterialColor), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UnityService_method_names[28],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UnityService::Service, ::AR51::GetMaterialColorRequest, ::AR51::Color>(
          std::mem_fn(&UnityService::Service::GetMaterialColor), this)));
}

UnityService::Service::~Service() {
}

::grpc::Status UnityService::Service::GetPyTime(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::GetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Float64Message* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::SetPyTimeOffset(::grpc::ServerContext* context, const ::AR51::Float64Message* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::Instantiate(::grpc::ServerContext* context, const ::AR51::InstantiateRequest* request, ::AR51::ObjectIdMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::FindGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::FindAnchorGameObject(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::ObjectIdMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::GetMainCamera(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::ObjectIdMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::Destroy(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::CreatePrimitive(::grpc::ServerContext* context, const ::AR51::CreatePrimitiveRequest* request, ::AR51::ObjectIdMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::NewGameObject(::grpc::ServerContext* context, const ::AR51::NameRequest* request, ::AR51::ObjectIdMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::ClearInstances(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::SetParent(::grpc::ServerContext* context, const ::AR51::SetParentRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::GetName(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::NameRequest* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::SetName(::grpc::ServerContext* context, const ::AR51::SetNameRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::GetActive(::grpc::ServerContext* context, const ::AR51::ObjectIdMessage* request, ::AR51::ActiveMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::SetActive(::grpc::ServerContext* context, const ::AR51::ActiveMessage* request, ::AR51::ActiveMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::GetTransform(::grpc::ServerContext* context, const ::AR51::GetTransformRequest* request, ::AR51::TransformMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::SetTransform(::grpc::ServerContext* context, const ::AR51::SetTransformRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::StreamTransform(::grpc::ServerContext* context, const ::AR51::GetTransformRequest* request, ::grpc::ServerWriter< ::AR51::TransformMessage>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::GetComponent(::grpc::ServerContext* context, const ::AR51::ComponentRequest* request, ::AR51::ObjectIdMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::GetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::ComponentFieldMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::SetComponentField(::grpc::ServerContext* context, const ::AR51::ComponentFieldMessage* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::SetCameraProject(::grpc::ServerContext* context, const ::AR51::TransformMessage* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::SetRendererEnabled(::grpc::ServerContext* context, const ::AR51::SetRendererEnabledRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::SetMaterialTexture(::grpc::ServerContext* context, const ::AR51::SetMaterialTextureRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::SetMaterialInt32(::grpc::ServerContext* context, const ::AR51::SetMaterialInt32Request* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::SetMaterialFloat(::grpc::ServerContext* context, const ::AR51::SetMaterialFloatRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::SetMaterialColor(::grpc::ServerContext* context, const ::AR51::SetMaterialColorRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status UnityService::Service::GetMaterialColor(::grpc::ServerContext* context, const ::AR51::GetMaterialColorRequest* request, ::AR51::Color* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* AnchorService_method_names[] = {
  "/AR51.AnchorService/CreateAnchor",
  "/AR51.AnchorService/DeleteAnchor",
  "/AR51.AnchorService/GetAnchorVisibility",
  "/AR51.AnchorService/SetAnchorVisibility",
  "/AR51.AnchorService/TapToPlaceAnchor",
  "/AR51.AnchorService/DownloadAnchor",
  "/AR51.AnchorService/UploadAnchor",
  "/AR51.AnchorService/GetAnchorIds",
  "/AR51.AnchorService/SetAllAnchorVisibility",
  "/AR51.AnchorService/Clear",
  "/AR51.AnchorService/GetGuardian",
  "/AR51.AnchorService/GetGuardianIds",
  "/AR51.AnchorService/CreateGuardian",
  "/AR51.AnchorService/DestroyGuardian",
  "/AR51.AnchorService/ClearGuardians",
  "/AR51.AnchorService/ShowGuardian",
  "/AR51.AnchorService/HideGuardian",
  "/AR51.AnchorService/ShowAllGuardians",
  "/AR51.AnchorService/HideAllGuardians",
};

std::unique_ptr< AnchorService::Stub> AnchorService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< AnchorService::Stub> stub(new AnchorService::Stub(channel));
  return stub;
}

AnchorService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_CreateAnchor_(AnchorService_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_DeleteAnchor_(AnchorService_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetAnchorVisibility_(AnchorService_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetAnchorVisibility_(AnchorService_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_TapToPlaceAnchor_(AnchorService_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_DownloadAnchor_(AnchorService_method_names[5], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  , rpcmethod_UploadAnchor_(AnchorService_method_names[6], ::grpc::internal::RpcMethod::CLIENT_STREAMING, channel)
  , rpcmethod_GetAnchorIds_(AnchorService_method_names[7], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetAllAnchorVisibility_(AnchorService_method_names[8], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Clear_(AnchorService_method_names[9], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetGuardian_(AnchorService_method_names[10], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetGuardianIds_(AnchorService_method_names[11], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_CreateGuardian_(AnchorService_method_names[12], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_DestroyGuardian_(AnchorService_method_names[13], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ClearGuardians_(AnchorService_method_names[14], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ShowGuardian_(AnchorService_method_names[15], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_HideGuardian_(AnchorService_method_names[16], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ShowAllGuardians_(AnchorService_method_names[17], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_HideAllGuardians_(AnchorService_method_names[18], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status AnchorService::Stub::CreateAnchor(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_CreateAnchor_, context, request, response);
}

void AnchorService::Stub::experimental_async::CreateAnchor(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_CreateAnchor_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::CreateAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_CreateAnchor_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::CreateAnchor(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_CreateAnchor_, context, request, response, reactor);
}

void AnchorService::Stub::experimental_async::CreateAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_CreateAnchor_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::AsyncCreateAnchorRaw(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_CreateAnchor_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::PrepareAsyncCreateAnchorRaw(::grpc::ClientContext* context, const ::AR51::CreateAnchorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_CreateAnchor_, context, request, false);
}

::grpc::Status AnchorService::Stub::DeleteAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_DeleteAnchor_, context, request, response);
}

void AnchorService::Stub::experimental_async::DeleteAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_DeleteAnchor_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::DeleteAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_DeleteAnchor_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::DeleteAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_DeleteAnchor_, context, request, response, reactor);
}

void AnchorService::Stub::experimental_async::DeleteAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_DeleteAnchor_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::AsyncDeleteAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_DeleteAnchor_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::PrepareAsyncDeleteAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_DeleteAnchor_, context, request, false);
}

::grpc::Status AnchorService::Stub::GetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::AR51::BoolMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetAnchorVisibility_, context, request, response);
}

void AnchorService::Stub::experimental_async::GetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAnchorVisibility_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::GetAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAnchorVisibility_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::GetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAnchorVisibility_, context, request, response, reactor);
}

void AnchorService::Stub::experimental_async::GetAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::BoolMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAnchorVisibility_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AnchorService::Stub::AsyncGetAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetAnchorVisibility_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::BoolMessage>* AnchorService::Stub::PrepareAsyncGetAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::BoolMessage>::Create(channel_.get(), cq, rpcmethod_GetAnchorVisibility_, context, request, false);
}

::grpc::Status AnchorService::Stub::SetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetAnchorVisibility_, context, request, response);
}

void AnchorService::Stub::experimental_async::SetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetAnchorVisibility_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::SetAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetAnchorVisibility_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::SetAnchorVisibility(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetAnchorVisibility_, context, request, response, reactor);
}

void AnchorService::Stub::experimental_async::SetAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetAnchorVisibility_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::AsyncSetAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetAnchorVisibility_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::PrepareAsyncSetAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::SetAnchorVisiliblityRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetAnchorVisibility_, context, request, false);
}

::grpc::Status AnchorService::Stub::TapToPlaceAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_TapToPlaceAnchor_, context, request, response);
}

void AnchorService::Stub::experimental_async::TapToPlaceAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_TapToPlaceAnchor_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::TapToPlaceAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_TapToPlaceAnchor_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::TapToPlaceAnchor(::grpc::ClientContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_TapToPlaceAnchor_, context, request, response, reactor);
}

void AnchorService::Stub::experimental_async::TapToPlaceAnchor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_TapToPlaceAnchor_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::AsyncTapToPlaceAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_TapToPlaceAnchor_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::PrepareAsyncTapToPlaceAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_TapToPlaceAnchor_, context, request, false);
}

::grpc::ClientReader< ::AR51::AnchorBytes>* AnchorService::Stub::DownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::AnchorBytes>::Create(channel_.get(), rpcmethod_DownloadAnchor_, context, request);
}

void AnchorService::Stub::experimental_async::DownloadAnchor(::grpc::ClientContext* context, ::AR51::AnchorRequest* request, ::grpc::experimental::ClientReadReactor< ::AR51::AnchorBytes>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::AnchorBytes>::Create(stub_->channel_.get(), stub_->rpcmethod_DownloadAnchor_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::AnchorBytes>* AnchorService::Stub::AsyncDownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::AnchorBytes>::Create(channel_.get(), cq, rpcmethod_DownloadAnchor_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::AnchorBytes>* AnchorService::Stub::PrepareAsyncDownloadAnchorRaw(::grpc::ClientContext* context, const ::AR51::AnchorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::AnchorBytes>::Create(channel_.get(), cq, rpcmethod_DownloadAnchor_, context, request, false, nullptr);
}

::grpc::ClientWriter< ::AR51::AnchorBytes>* AnchorService::Stub::UploadAnchorRaw(::grpc::ClientContext* context, ::AR51::Empty* response) {
  return ::grpc_impl::internal::ClientWriterFactory< ::AR51::AnchorBytes>::Create(channel_.get(), rpcmethod_UploadAnchor_, context, response);
}

void AnchorService::Stub::experimental_async::UploadAnchor(::grpc::ClientContext* context, ::AR51::Empty* response, ::grpc::experimental::ClientWriteReactor< ::AR51::AnchorBytes>* reactor) {
  ::grpc_impl::internal::ClientCallbackWriterFactory< ::AR51::AnchorBytes>::Create(stub_->channel_.get(), stub_->rpcmethod_UploadAnchor_, context, response, reactor);
}

::grpc::ClientAsyncWriter< ::AR51::AnchorBytes>* AnchorService::Stub::AsyncUploadAnchorRaw(::grpc::ClientContext* context, ::AR51::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncWriterFactory< ::AR51::AnchorBytes>::Create(channel_.get(), cq, rpcmethod_UploadAnchor_, context, response, true, tag);
}

::grpc::ClientAsyncWriter< ::AR51::AnchorBytes>* AnchorService::Stub::PrepareAsyncUploadAnchorRaw(::grpc::ClientContext* context, ::AR51::Empty* response, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncWriterFactory< ::AR51::AnchorBytes>::Create(channel_.get(), cq, rpcmethod_UploadAnchor_, context, response, false, nullptr);
}

::grpc::Status AnchorService::Stub::GetAnchorIds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::AnchorIdsReply* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetAnchorIds_, context, request, response);
}

void AnchorService::Stub::experimental_async::GetAnchorIds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::AnchorIdsReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAnchorIds_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::GetAnchorIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::AnchorIdsReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAnchorIds_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::GetAnchorIds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::AnchorIdsReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAnchorIds_, context, request, response, reactor);
}

void AnchorService::Stub::experimental_async::GetAnchorIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::AnchorIdsReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAnchorIds_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::AnchorIdsReply>* AnchorService::Stub::AsyncGetAnchorIdsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::AnchorIdsReply>::Create(channel_.get(), cq, rpcmethod_GetAnchorIds_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::AnchorIdsReply>* AnchorService::Stub::PrepareAsyncGetAnchorIdsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::AnchorIdsReply>::Create(channel_.get(), cq, rpcmethod_GetAnchorIds_, context, request, false);
}

::grpc::Status AnchorService::Stub::SetAllAnchorVisibility(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetAllAnchorVisibility_, context, request, response);
}

void AnchorService::Stub::experimental_async::SetAllAnchorVisibility(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetAllAnchorVisibility_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::SetAllAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetAllAnchorVisibility_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::SetAllAnchorVisibility(::grpc::ClientContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetAllAnchorVisibility_, context, request, response, reactor);
}

void AnchorService::Stub::experimental_async::SetAllAnchorVisibility(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetAllAnchorVisibility_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::AsyncSetAllAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetAllAnchorVisibility_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::PrepareAsyncSetAllAnchorVisibilityRaw(::grpc::ClientContext* context, const ::AR51::BoolMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetAllAnchorVisibility_, context, request, false);
}

::grpc::Status AnchorService::Stub::Clear(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Clear_, context, request, response);
}

void AnchorService::Stub::experimental_async::Clear(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Clear_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::Clear(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Clear_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::Clear(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Clear_, context, request, response, reactor);
}

void AnchorService::Stub::experimental_async::Clear(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Clear_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::AsyncClearRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Clear_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::PrepareAsyncClearRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_Clear_, context, request, false);
}

::grpc::Status AnchorService::Stub::GetGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::AR51::GetGuardianResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetGuardian_, context, request, response);
}

void AnchorService::Stub::experimental_async::GetGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::GetGuardianResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetGuardian_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::GetGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetGuardianResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetGuardian_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::GetGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::GetGuardianResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetGuardian_, context, request, response, reactor);
}

void AnchorService::Stub::experimental_async::GetGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetGuardianResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetGuardian_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::GetGuardianResponse>* AnchorService::Stub::AsyncGetGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::GetGuardianResponse>::Create(channel_.get(), cq, rpcmethod_GetGuardian_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::GetGuardianResponse>* AnchorService::Stub::PrepareAsyncGetGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::GetGuardianResponse>::Create(channel_.get(), cq, rpcmethod_GetGuardian_, context, request, false);
}

::grpc::Status AnchorService::Stub::GetGuardianIds(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::GetGuardianIdsResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetGuardianIds_, context, request, response);
}

void AnchorService::Stub::experimental_async::GetGuardianIds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetGuardianIdsResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetGuardianIds_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::GetGuardianIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetGuardianIdsResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetGuardianIds_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::GetGuardianIds(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::GetGuardianIdsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetGuardianIds_, context, request, response, reactor);
}

void AnchorService::Stub::experimental_async::GetGuardianIds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::GetGuardianIdsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetGuardianIds_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::GetGuardianIdsResponse>* AnchorService::Stub::AsyncGetGuardianIdsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::GetGuardianIdsResponse>::Create(channel_.get(), cq, rpcmethod_GetGuardianIds_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::GetGuardianIdsResponse>* AnchorService::Stub::PrepareAsyncGetGuardianIdsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::GetGuardianIdsResponse>::Create(channel_.get(), cq, rpcmethod_GetGuardianIds_, context, request, false);
}

::grpc::Status AnchorService::Stub::CreateGuardian(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_CreateGuardian_, context, request, response);
}

void AnchorService::Stub::experimental_async::CreateGuardian(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_CreateGuardian_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::CreateGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_CreateGuardian_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::CreateGuardian(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_CreateGuardian_, context, request, response, reactor);
}

void AnchorService::Stub::experimental_async::CreateGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_CreateGuardian_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::AsyncCreateGuardianRaw(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_CreateGuardian_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::PrepareAsyncCreateGuardianRaw(::grpc::ClientContext* context, const ::AR51::CreateGuardianRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_CreateGuardian_, context, request, false);
}

::grpc::Status AnchorService::Stub::DestroyGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_DestroyGuardian_, context, request, response);
}

void AnchorService::Stub::experimental_async::DestroyGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_DestroyGuardian_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::DestroyGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_DestroyGuardian_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::DestroyGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_DestroyGuardian_, context, request, response, reactor);
}

void AnchorService::Stub::experimental_async::DestroyGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_DestroyGuardian_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::AsyncDestroyGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_DestroyGuardian_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::PrepareAsyncDestroyGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_DestroyGuardian_, context, request, false);
}

::grpc::Status AnchorService::Stub::ClearGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ClearGuardians_, context, request, response);
}

void AnchorService::Stub::experimental_async::ClearGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ClearGuardians_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::ClearGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ClearGuardians_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::ClearGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ClearGuardians_, context, request, response, reactor);
}

void AnchorService::Stub::experimental_async::ClearGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ClearGuardians_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::AsyncClearGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_ClearGuardians_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::PrepareAsyncClearGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_ClearGuardians_, context, request, false);
}

::grpc::Status AnchorService::Stub::ShowGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ShowGuardian_, context, request, response);
}

void AnchorService::Stub::experimental_async::ShowGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ShowGuardian_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::ShowGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ShowGuardian_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::ShowGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ShowGuardian_, context, request, response, reactor);
}

void AnchorService::Stub::experimental_async::ShowGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ShowGuardian_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::AsyncShowGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_ShowGuardian_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::PrepareAsyncShowGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_ShowGuardian_, context, request, false);
}

::grpc::Status AnchorService::Stub::HideGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_HideGuardian_, context, request, response);
}

void AnchorService::Stub::experimental_async::HideGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_HideGuardian_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::HideGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_HideGuardian_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::HideGuardian(::grpc::ClientContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_HideGuardian_, context, request, response, reactor);
}

void AnchorService::Stub::experimental_async::HideGuardian(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_HideGuardian_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::AsyncHideGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_HideGuardian_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::PrepareAsyncHideGuardianRaw(::grpc::ClientContext* context, const ::AR51::GuardianRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_HideGuardian_, context, request, false);
}

::grpc::Status AnchorService::Stub::ShowAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ShowAllGuardians_, context, request, response);
}

void AnchorService::Stub::experimental_async::ShowAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ShowAllGuardians_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::ShowAllGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ShowAllGuardians_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::ShowAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ShowAllGuardians_, context, request, response, reactor);
}

void AnchorService::Stub::experimental_async::ShowAllGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ShowAllGuardians_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::AsyncShowAllGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_ShowAllGuardians_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::PrepareAsyncShowAllGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_ShowAllGuardians_, context, request, false);
}

::grpc::Status AnchorService::Stub::HideAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_HideAllGuardians_, context, request, response);
}

void AnchorService::Stub::experimental_async::HideAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_HideAllGuardians_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::HideAllGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_HideAllGuardians_, context, request, response, std::move(f));
}

void AnchorService::Stub::experimental_async::HideAllGuardians(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_HideAllGuardians_, context, request, response, reactor);
}

void AnchorService::Stub::experimental_async::HideAllGuardians(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_HideAllGuardians_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::AsyncHideAllGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_HideAllGuardians_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* AnchorService::Stub::PrepareAsyncHideAllGuardiansRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_HideAllGuardians_, context, request, false);
}

AnchorService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AnchorService::Service, ::AR51::CreateAnchorRequest, ::AR51::Empty>(
          std::mem_fn(&AnchorService::Service::CreateAnchor), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AnchorService::Service, ::AR51::AnchorRequest, ::AR51::Empty>(
          std::mem_fn(&AnchorService::Service::DeleteAnchor), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AnchorService::Service, ::AR51::AnchorRequest, ::AR51::BoolMessage>(
          std::mem_fn(&AnchorService::Service::GetAnchorVisibility), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AnchorService::Service, ::AR51::SetAnchorVisiliblityRequest, ::AR51::Empty>(
          std::mem_fn(&AnchorService::Service::SetAnchorVisibility), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AnchorService::Service, ::AR51::AnchorRequest, ::AR51::Empty>(
          std::mem_fn(&AnchorService::Service::TapToPlaceAnchor), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[5],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< AnchorService::Service, ::AR51::AnchorRequest, ::AR51::AnchorBytes>(
          std::mem_fn(&AnchorService::Service::DownloadAnchor), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[6],
      ::grpc::internal::RpcMethod::CLIENT_STREAMING,
      new ::grpc::internal::ClientStreamingHandler< AnchorService::Service, ::AR51::AnchorBytes, ::AR51::Empty>(
          std::mem_fn(&AnchorService::Service::UploadAnchor), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AnchorService::Service, ::AR51::Empty, ::AR51::AnchorIdsReply>(
          std::mem_fn(&AnchorService::Service::GetAnchorIds), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AnchorService::Service, ::AR51::BoolMessage, ::AR51::Empty>(
          std::mem_fn(&AnchorService::Service::SetAllAnchorVisibility), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[9],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AnchorService::Service, ::AR51::Empty, ::AR51::Empty>(
          std::mem_fn(&AnchorService::Service::Clear), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[10],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AnchorService::Service, ::AR51::GuardianRequest, ::AR51::GetGuardianResponse>(
          std::mem_fn(&AnchorService::Service::GetGuardian), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[11],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AnchorService::Service, ::AR51::Empty, ::AR51::GetGuardianIdsResponse>(
          std::mem_fn(&AnchorService::Service::GetGuardianIds), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[12],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AnchorService::Service, ::AR51::CreateGuardianRequest, ::AR51::Empty>(
          std::mem_fn(&AnchorService::Service::CreateGuardian), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[13],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AnchorService::Service, ::AR51::GuardianRequest, ::AR51::Empty>(
          std::mem_fn(&AnchorService::Service::DestroyGuardian), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[14],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AnchorService::Service, ::AR51::Empty, ::AR51::Empty>(
          std::mem_fn(&AnchorService::Service::ClearGuardians), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[15],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AnchorService::Service, ::AR51::GuardianRequest, ::AR51::Empty>(
          std::mem_fn(&AnchorService::Service::ShowGuardian), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[16],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AnchorService::Service, ::AR51::GuardianRequest, ::AR51::Empty>(
          std::mem_fn(&AnchorService::Service::HideGuardian), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[17],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AnchorService::Service, ::AR51::Empty, ::AR51::Empty>(
          std::mem_fn(&AnchorService::Service::ShowAllGuardians), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      AnchorService_method_names[18],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< AnchorService::Service, ::AR51::Empty, ::AR51::Empty>(
          std::mem_fn(&AnchorService::Service::HideAllGuardians), this)));
}

AnchorService::Service::~Service() {
}

::grpc::Status AnchorService::Service::CreateAnchor(::grpc::ServerContext* context, const ::AR51::CreateAnchorRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::DeleteAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::GetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::BoolMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::SetAnchorVisibility(::grpc::ServerContext* context, const ::AR51::SetAnchorVisiliblityRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::TapToPlaceAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::DownloadAnchor(::grpc::ServerContext* context, const ::AR51::AnchorRequest* request, ::grpc::ServerWriter< ::AR51::AnchorBytes>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::UploadAnchor(::grpc::ServerContext* context, ::grpc::ServerReader< ::AR51::AnchorBytes>* reader, ::AR51::Empty* response) {
  (void) context;
  (void) reader;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::GetAnchorIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::AnchorIdsReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::SetAllAnchorVisibility(::grpc::ServerContext* context, const ::AR51::BoolMessage* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::Clear(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::GetGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::GetGuardianResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::GetGuardianIds(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::GetGuardianIdsResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::CreateGuardian(::grpc::ServerContext* context, const ::AR51::CreateGuardianRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::DestroyGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::ClearGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::ShowGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::HideGuardian(::grpc::ServerContext* context, const ::AR51::GuardianRequest* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::ShowAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status AnchorService::Service::HideAllGuardians(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* DebugService_method_names[] = {
  "/AR51.DebugService/GetAllFields",
  "/AR51.DebugService/SetField",
  "/AR51.DebugService/GetField",
};

std::unique_ptr< DebugService::Stub> DebugService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< DebugService::Stub> stub(new DebugService::Stub(channel));
  return stub;
}

DebugService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_GetAllFields_(DebugService_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetField_(DebugService_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetField_(DebugService_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status DebugService::Stub::GetAllFields(::grpc::ClientContext* context, const ::AR51::Empty& request, ::AR51::FieldInfos* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetAllFields_, context, request, response);
}

void DebugService::Stub::experimental_async::GetAllFields(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::FieldInfos* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAllFields_, context, request, response, std::move(f));
}

void DebugService::Stub::experimental_async::GetAllFields(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::FieldInfos* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAllFields_, context, request, response, std::move(f));
}

void DebugService::Stub::experimental_async::GetAllFields(::grpc::ClientContext* context, const ::AR51::Empty* request, ::AR51::FieldInfos* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAllFields_, context, request, response, reactor);
}

void DebugService::Stub::experimental_async::GetAllFields(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::FieldInfos* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAllFields_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::FieldInfos>* DebugService::Stub::AsyncGetAllFieldsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::FieldInfos>::Create(channel_.get(), cq, rpcmethod_GetAllFields_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::FieldInfos>* DebugService::Stub::PrepareAsyncGetAllFieldsRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::FieldInfos>::Create(channel_.get(), cq, rpcmethod_GetAllFields_, context, request, false);
}

::grpc::Status DebugService::Stub::SetField(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::AR51::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SetField_, context, request, response);
}

void DebugService::Stub::experimental_async::SetField(::grpc::ClientContext* context, const ::AR51::FieldInfo* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetField_, context, request, response, std::move(f));
}

void DebugService::Stub::experimental_async::SetField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SetField_, context, request, response, std::move(f));
}

void DebugService::Stub::experimental_async::SetField(::grpc::ClientContext* context, const ::AR51::FieldInfo* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetField_, context, request, response, reactor);
}

void DebugService::Stub::experimental_async::SetField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SetField_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* DebugService::Stub::AsyncSetFieldRaw(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetField_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::Empty>* DebugService::Stub::PrepareAsyncSetFieldRaw(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::Empty>::Create(channel_.get(), cq, rpcmethod_SetField_, context, request, false);
}

::grpc::Status DebugService::Stub::GetField(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::AR51::FieldInfo* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetField_, context, request, response);
}

void DebugService::Stub::experimental_async::GetField(::grpc::ClientContext* context, const ::AR51::FieldInfo* request, ::AR51::FieldInfo* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetField_, context, request, response, std::move(f));
}

void DebugService::Stub::experimental_async::GetField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::FieldInfo* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetField_, context, request, response, std::move(f));
}

void DebugService::Stub::experimental_async::GetField(::grpc::ClientContext* context, const ::AR51::FieldInfo* request, ::AR51::FieldInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetField_, context, request, response, reactor);
}

void DebugService::Stub::experimental_async::GetField(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::AR51::FieldInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetField_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::AR51::FieldInfo>* DebugService::Stub::AsyncGetFieldRaw(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::FieldInfo>::Create(channel_.get(), cq, rpcmethod_GetField_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::AR51::FieldInfo>* DebugService::Stub::PrepareAsyncGetFieldRaw(::grpc::ClientContext* context, const ::AR51::FieldInfo& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::AR51::FieldInfo>::Create(channel_.get(), cq, rpcmethod_GetField_, context, request, false);
}

DebugService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DebugService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DebugService::Service, ::AR51::Empty, ::AR51::FieldInfos>(
          std::mem_fn(&DebugService::Service::GetAllFields), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DebugService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DebugService::Service, ::AR51::FieldInfo, ::AR51::Empty>(
          std::mem_fn(&DebugService::Service::SetField), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DebugService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DebugService::Service, ::AR51::FieldInfo, ::AR51::FieldInfo>(
          std::mem_fn(&DebugService::Service::GetField), this)));
}

DebugService::Service::~Service() {
}

::grpc::Status DebugService::Service::GetAllFields(::grpc::ServerContext* context, const ::AR51::Empty* request, ::AR51::FieldInfos* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DebugService::Service::SetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DebugService::Service::GetField(::grpc::ServerContext* context, const ::AR51::FieldInfo* request, ::AR51::FieldInfo* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* HandSkeletonService_method_names[] = {
  "/AR51.HandSkeletonService/StartStreaming",
};

std::unique_ptr< HandSkeletonService::Stub> HandSkeletonService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< HandSkeletonService::Stub> stub(new HandSkeletonService::Stub(channel));
  return stub;
}

HandSkeletonService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_StartStreaming_(HandSkeletonService_method_names[0], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  {}

::grpc::ClientReader< ::AR51::TwoHandsInfoResponse>* HandSkeletonService::Stub::StartStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request) {
  return ::grpc_impl::internal::ClientReaderFactory< ::AR51::TwoHandsInfoResponse>::Create(channel_.get(), rpcmethod_StartStreaming_, context, request);
}

void HandSkeletonService::Stub::experimental_async::StartStreaming(::grpc::ClientContext* context, ::AR51::Empty* request, ::grpc::experimental::ClientReadReactor< ::AR51::TwoHandsInfoResponse>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderFactory< ::AR51::TwoHandsInfoResponse>::Create(stub_->channel_.get(), stub_->rpcmethod_StartStreaming_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::AR51::TwoHandsInfoResponse>* HandSkeletonService::Stub::AsyncStartStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::TwoHandsInfoResponse>::Create(channel_.get(), cq, rpcmethod_StartStreaming_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::AR51::TwoHandsInfoResponse>* HandSkeletonService::Stub::PrepareAsyncStartStreamingRaw(::grpc::ClientContext* context, const ::AR51::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderFactory< ::AR51::TwoHandsInfoResponse>::Create(channel_.get(), cq, rpcmethod_StartStreaming_, context, request, false, nullptr);
}

HandSkeletonService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      HandSkeletonService_method_names[0],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< HandSkeletonService::Service, ::AR51::Empty, ::AR51::TwoHandsInfoResponse>(
          std::mem_fn(&HandSkeletonService::Service::StartStreaming), this)));
}

HandSkeletonService::Service::~Service() {
}

::grpc::Status HandSkeletonService::Service::StartStreaming(::grpc::ServerContext* context, const ::AR51::Empty* request, ::grpc::ServerWriter< ::AR51::TwoHandsInfoResponse>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace AR51

